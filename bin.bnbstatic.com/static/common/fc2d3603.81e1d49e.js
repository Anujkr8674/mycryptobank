(self["webpackChunkproject"] = self["webpackChunkproject"] || []).push([
    [617], {

        /***/
        "QNan":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "yV": () => ( /* reexport */ utils /* getLangFromCode */ .yV),
                    "QT": () => ( /* reexport */ c)
                });

                // UNUSED EXPORTS: I18nProvider, Trans, defaultPathResolver, dir, getCode, getI18nValue, getLabel, getLang, getRegion, getRegionFromCode, parseCode, renderAsNsKey, toArray, trans2NsKey, useLanguage

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_sliced_to_array.mjs + 2 modules
                var _sliced_to_array = __webpack_require__("/++K");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@pika+utils@0.3.0/node_modules/@pika/utils/dist/esm/index.js + 1 modules
                var esm = __webpack_require__("i2Sz");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@pika+plugin-i18n@0.3.36_@swc+core@1.3.96_@types+react@18.0.28_react-dom@18.2.0_react@18.2.0_sass@1.50.1_webpack@5.97.1/node_modules/@pika/plugin-i18n/dist/esm/i18n/i18nCore.js + 5 modules
                var i18nCore = __webpack_require__("KEwK");; // CONCATENATED MODULE: ./node_modules/.pnpm/@pika+plugin-i18n@0.3.36_@swc+core@1.3.96_@types+react@18.0.28_react-dom@18.2.0_react@18.2.0_sass@1.50.1_webpack@5.97.1/node_modules/@pika/plugin-i18n/dist/esm/i18n/mock/index.js
                var createMock = function() {
                    return null;
                };

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/@pika+plugin-i18n@0.3.36_@swc+core@1.3.96_@types+react@18.0.28_react-dom@18.2.0_react@18.2.0_sass@1.50.1_webpack@5.97.1/node_modules/@pika/plugin-i18n/dist/esm/i18n/index.js






                var c = function(o) {
                        var ref = (0, external_React_.useContext)(i18nCore /* i18nContext */ .g),
                            _$a = ref.i18n,
                            _$l = ref.__count__,
                            c = _$a.i18nextIns,
                            ref1 = (0, _sliced_to_array /* default */ .Z)((0, external_React_.useState)(c.language), 2),
                            d = ref1[0],
                            u = ref1[1],
                            g = (0, external_React_.useCallback)(function(e) {
                                return e;
                            }, []),
                            m = (0, external_React_.useMemo)(function() {
                                return c.getFixedT(d, o);
                            }, [
                                d,
                                o,
                                _$l
                            ]);
                        return (0, external_React_.useEffect)(function() {
                            if (c.isInitialized) {
                                if (o) {
                                    (Array.isArray(o) ? o : [
                                        o
                                    ]).forEach(function(e) {
                                        c.hasResourceBundle(d, e) || c.loadNamespaces(e);
                                    });
                                }
                            } else _$a.init();
                            return c.on("languageChanged", u),
                                function() {
                                    c.off("languageChanged", u);
                                };
                        }, []), {
                            locale: d,
                            language: d,
                            setLocale: _$a.setLocale,
                            t: c.isInitialized ? m : g,
                            i18n: c
                        };
                    },
                    d = function(e) {
                        var i = t(s).i18n;
                        return o(Object.assign({
                            i18n: i.i18nextIns.isInitialized ? i.i18nextIns : void 0
                        }, e));
                    };
                var u = null === esm /* GLOBAL_OBJ */ .n2 || void 0 === esm /* GLOBAL_OBJ */ .n2 ? void 0 : esm /* GLOBAL_OBJ.PRERENDER */ .n2.PRERENDER;
                if (u) {
                    var e1 = createMock();
                    e1 && (c = e1.useI18n, d = e1.Trans);
                }

                var I18nProvider = i18nCore /* i18nContext.Provider */ .g.Provider;

                // EXTERNAL MODULE: ./node_modules/.pnpm/@pika+plugin-i18n@0.3.36_@swc+core@1.3.96_@types+react@18.0.28_react-dom@18.2.0_react@18.2.0_sass@1.50.1_webpack@5.97.1/node_modules/@pika/plugin-i18n/dist/esm/i18n/utils/index.js + 3 modules
                var utils = __webpack_require__("KH5z");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@pika+plugin-language@0.3.23_@swc+core@1.3.96_sass@1.50.1_webpack@5.97.1/node_modules/@pika/plugin-language/dist/esm/context.js
                var context = __webpack_require__("UyVv");; // CONCATENATED MODULE: ./node_modules/.pnpm/@pika+plugin-language@0.3.23_@swc+core@1.3.96_sass@1.50.1_webpack@5.97.1/node_modules/@pika/plugin-language/dist/esm/api/index.js


                ; // CONCATENATED MODULE: ./.shuvi/app/runtime/bn/i18n.ts





                /***/
            }),

        /***/
        "FWOm":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "fx": () => ( /* binding */ fetchDappList$),
                    "EX": () => ( /* binding */ fetchEarnList$),
                    "cQ": () => ( /* binding */ fetchNetworkList$)
                });

                // NAMESPACE OBJECT: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/common/utils.js
                var common_utils_namespaceObject = {};
                __webpack_require__.r(common_utils_namespaceObject);
                __webpack_require__.d(common_utils_namespaceObject, {
                    "hasBrowserEnv": () => (hasBrowserEnv),
                    "hasStandardBrowserEnv": () => (hasStandardBrowserEnv),
                    "hasStandardBrowserWebWorkerEnv": () => (hasStandardBrowserWebWorkerEnv),
                    "navigator": () => (_navigator),
                    "origin": () => (origin)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_async_to_generator.mjs
                var _async_to_generator = __webpack_require__("ttNT");
                // EXTERNAL MODULE: external "regeneratorRuntime"
                var external_regeneratorRuntime_ = __webpack_require__("Pz56");
                var external_regeneratorRuntime_default = /*#__PURE__*/ __webpack_require__.n(external_regeneratorRuntime_);; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/bind.js


                function bind(fn, thisArg) {
                    return function wrap() {
                        return fn.apply(thisArg, arguments);
                    };
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/utils.js
                /* provided dependency */
                var process = __webpack_require__("FXEK");




                // utils is a library of generic helper functions non-specific to axios

                const {
                    toString: utils_toString
                } = Object.prototype;
                const {
                    getPrototypeOf
                } = Object;

                const kindOf = (cache => thing => {
                    const str = utils_toString.call(thing);
                    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
                })(Object.create(null));

                const kindOfTest = (type) => {
                    type = type.toLowerCase();
                    return (thing) => kindOf(thing) === type
                }

                const typeOfTest = type => thing => typeof thing === type;

                /**
                 * Determine if a value is an Array
                 *
                 * @param {Object} val The value to test
                 *
                 * @returns {boolean} True if value is an Array, otherwise false
                 */
                const {
                    isArray
                } = Array;

                /**
                 * Determine if a value is undefined
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if the value is undefined, otherwise false
                 */
                const isUndefined = typeOfTest('undefined');

                /**
                 * Determine if a value is a Buffer
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a Buffer, otherwise false
                 */
                function isBuffer(val) {
                    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) &&
                        isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
                }

                /**
                 * Determine if a value is an ArrayBuffer
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
                 */
                const isArrayBuffer = kindOfTest('ArrayBuffer');


                /**
                 * Determine if a value is a view on an ArrayBuffer
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
                 */
                function isArrayBufferView(val) {
                    let result;
                    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
                        result = ArrayBuffer.isView(val);
                    } else {
                        result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
                    }
                    return result;
                }

                /**
                 * Determine if a value is a String
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a String, otherwise false
                 */
                const isString = typeOfTest('string');

                /**
                 * Determine if a value is a Function
                 *
                 * @param {*} val The value to test
                 * @returns {boolean} True if value is a Function, otherwise false
                 */
                const isFunction = typeOfTest('function');

                /**
                 * Determine if a value is a Number
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a Number, otherwise false
                 */
                const isNumber = typeOfTest('number');

                /**
                 * Determine if a value is an Object
                 *
                 * @param {*} thing The value to test
                 *
                 * @returns {boolean} True if value is an Object, otherwise false
                 */
                const isObject = (thing) => thing !== null && typeof thing === 'object';

                /**
                 * Determine if a value is a Boolean
                 *
                 * @param {*} thing The value to test
                 * @returns {boolean} True if value is a Boolean, otherwise false
                 */
                const isBoolean = thing => thing === true || thing === false;

                /**
                 * Determine if a value is a plain Object
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a plain Object, otherwise false
                 */
                const isPlainObject = (val) => {
                    if (kindOf(val) !== 'object') {
                        return false;
                    }

                    const prototype = getPrototypeOf(val);
                    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
                }

                /**
                 * Determine if a value is a Date
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a Date, otherwise false
                 */
                const isDate = kindOfTest('Date');

                /**
                 * Determine if a value is a File
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a File, otherwise false
                 */
                const isFile = kindOfTest('File');

                /**
                 * Determine if a value is a Blob
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a Blob, otherwise false
                 */
                const isBlob = kindOfTest('Blob');

                /**
                 * Determine if a value is a FileList
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a File, otherwise false
                 */
                const isFileList = kindOfTest('FileList');

                /**
                 * Determine if a value is a Stream
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a Stream, otherwise false
                 */
                const isStream = (val) => isObject(val) && isFunction(val.pipe);

                /**
                 * Determine if a value is a FormData
                 *
                 * @param {*} thing The value to test
                 *
                 * @returns {boolean} True if value is an FormData, otherwise false
                 */
                const isFormData = (thing) => {
                    let kind;
                    return thing && (
                        (typeof FormData === 'function' && thing instanceof FormData) || (
                            isFunction(thing.append) && (
                                (kind = kindOf(thing)) === 'formdata' ||
                                // detect form-data instance
                                (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
                            )
                        )
                    )
                }

                /**
                 * Determine if a value is a URLSearchParams object
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
                 */
                const isURLSearchParams = kindOfTest('URLSearchParams');

                const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

                /**
                 * Trim excess whitespace off the beginning and end of a string
                 *
                 * @param {String} str The String to trim
                 *
                 * @returns {String} The String freed of excess whitespace
                 */
                const trim = (str) => str.trim ?
                    str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

                /**
                 * Iterate over an Array or an Object invoking a function for each item.
                 *
                 * If `obj` is an Array callback will be called passing
                 * the value, index, and complete array for each item.
                 *
                 * If 'obj' is an Object callback will be called passing
                 * the value, key, and complete object for each property.
                 *
                 * @param {Object|Array} obj The object to iterate
                 * @param {Function} fn The callback to invoke for each item
                 *
                 * @param {Boolean} [allOwnKeys = false]
                 * @returns {any}
                 */
                function forEach(obj, fn, {
                    allOwnKeys = false
                } = {}) {
                    // Don't bother if no value provided
                    if (obj === null || typeof obj === 'undefined') {
                        return;
                    }

                    let i;
                    let l;

                    // Force an array if not already something iterable
                    if (typeof obj !== 'object') {
                        /*eslint no-param-reassign:0*/
                        obj = [obj];
                    }

                    if (isArray(obj)) {
                        // Iterate over array values
                        for (i = 0, l = obj.length; i < l; i++) {
                            fn.call(null, obj[i], i, obj);
                        }
                    } else {
                        // Iterate over object keys
                        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
                        const len = keys.length;
                        let key;

                        for (i = 0; i < len; i++) {
                            key = keys[i];
                            fn.call(null, obj[key], key, obj);
                        }
                    }
                }

                function findKey(obj, key) {
                    key = key.toLowerCase();
                    const keys = Object.keys(obj);
                    let i = keys.length;
                    let _key;
                    while (i-- > 0) {
                        _key = keys[i];
                        if (key === _key.toLowerCase()) {
                            return _key;
                        }
                    }
                    return null;
                }

                const _global = (() => {
                    /*eslint no-undef:0*/
                    if (typeof globalThis !== "undefined") return globalThis;
                    return typeof self !== "undefined" ? self : (true ? window : 0)
                })();

                const isContextDefined = (context) => !isUndefined(context) && context !== _global;

                /**
                 * Accepts varargs expecting each argument to be an object, then
                 * immutably merges the properties of each object and returns result.
                 *
                 * When multiple objects contain the same key the later object in
                 * the arguments list will take precedence.
                 *
                 * Example:
                 *
                 * ```js
                 * var result = merge({foo: 123}, {foo: 456});
                 * console.log(result.foo); // outputs 456
                 * ```
                 *
                 * @param {Object} obj1 Object to merge
                 *
                 * @returns {Object} Result of all merge properties
                 */
                function merge( /* obj1, obj2, obj3, ... */ ) {
                    const {
                        caseless
                    } = isContextDefined(this) && this || {};
                    const result = {};
                    const assignValue = (val, key) => {
                        const targetKey = caseless && findKey(result, key) || key;
                        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
                            result[targetKey] = merge(result[targetKey], val);
                        } else if (isPlainObject(val)) {
                            result[targetKey] = merge({}, val);
                        } else if (isArray(val)) {
                            result[targetKey] = val.slice();
                        } else {
                            result[targetKey] = val;
                        }
                    }

                    for (let i = 0, l = arguments.length; i < l; i++) {
                        arguments[i] && forEach(arguments[i], assignValue);
                    }
                    return result;
                }

                /**
                 * Extends object a by mutably adding to it the properties of object b.
                 *
                 * @param {Object} a The object to be extended
                 * @param {Object} b The object to copy properties from
                 * @param {Object} thisArg The object to bind function to
                 *
                 * @param {Boolean} [allOwnKeys]
                 * @returns {Object} The resulting value of object a
                 */
                const extend = (a, b, thisArg, {
                    allOwnKeys
                } = {}) => {
                    forEach(b, (val, key) => {
                        if (thisArg && isFunction(val)) {
                            a[key] = bind(val, thisArg);
                        } else {
                            a[key] = val;
                        }
                    }, {
                        allOwnKeys
                    });
                    return a;
                }

                /**
                 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
                 *
                 * @param {string} content with BOM
                 *
                 * @returns {string} content value without BOM
                 */
                const stripBOM = (content) => {
                    if (content.charCodeAt(0) === 0xFEFF) {
                        content = content.slice(1);
                    }
                    return content;
                }

                /**
                 * Inherit the prototype methods from one constructor into another
                 * @param {function} constructor
                 * @param {function} superConstructor
                 * @param {object} [props]
                 * @param {object} [descriptors]
                 *
                 * @returns {void}
                 */
                const inherits = (constructor, superConstructor, props, descriptors) => {
                    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
                    constructor.prototype.constructor = constructor;
                    Object.defineProperty(constructor, 'super', {
                        value: superConstructor.prototype
                    });
                    props && Object.assign(constructor.prototype, props);
                }

                /**
                 * Resolve object with deep prototype chain to a flat object
                 * @param {Object} sourceObj source object
                 * @param {Object} [destObj]
                 * @param {Function|Boolean} [filter]
                 * @param {Function} [propFilter]
                 *
                 * @returns {Object}
                 */
                const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
                    let props;
                    let i;
                    let prop;
                    const merged = {};

                    destObj = destObj || {};
                    // eslint-disable-next-line no-eq-null,eqeqeq
                    if (sourceObj == null) return destObj;

                    do {
                        props = Object.getOwnPropertyNames(sourceObj);
                        i = props.length;
                        while (i-- > 0) {
                            prop = props[i];
                            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                                destObj[prop] = sourceObj[prop];
                                merged[prop] = true;
                            }
                        }
                        sourceObj = filter !== false && getPrototypeOf(sourceObj);
                    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

                    return destObj;
                }

                /**
                 * Determines whether a string ends with the characters of a specified string
                 *
                 * @param {String} str
                 * @param {String} searchString
                 * @param {Number} [position= 0]
                 *
                 * @returns {boolean}
                 */
                const endsWith = (str, searchString, position) => {
                    str = String(str);
                    if (position === undefined || position > str.length) {
                        position = str.length;
                    }
                    position -= searchString.length;
                    const lastIndex = str.indexOf(searchString, position);
                    return lastIndex !== -1 && lastIndex === position;
                }


                /**
                 * Returns new array from array like object or null if failed
                 *
                 * @param {*} [thing]
                 *
                 * @returns {?Array}
                 */
                const toArray = (thing) => {
                    if (!thing) return null;
                    if (isArray(thing)) return thing;
                    let i = thing.length;
                    if (!isNumber(i)) return null;
                    const arr = new Array(i);
                    while (i-- > 0) {
                        arr[i] = thing[i];
                    }
                    return arr;
                }

                /**
                 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
                 * thing passed in is an instance of Uint8Array
                 *
                 * @param {TypedArray}
                 *
                 * @returns {Array}
                 */
                // eslint-disable-next-line func-names
                const isTypedArray = (TypedArray => {
                    // eslint-disable-next-line func-names
                    return thing => {
                        return TypedArray && thing instanceof TypedArray;
                    };
                })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

                /**
                 * For each entry in the object, call the function with the key and value.
                 *
                 * @param {Object<any, any>} obj - The object to iterate over.
                 * @param {Function} fn - The function to call for each entry.
                 *
                 * @returns {void}
                 */
                const forEachEntry = (obj, fn) => {
                    const generator = obj && obj[Symbol.iterator];

                    const iterator = generator.call(obj);

                    let result;

                    while ((result = iterator.next()) && !result.done) {
                        const pair = result.value;
                        fn.call(obj, pair[0], pair[1]);
                    }
                }

                /**
                 * It takes a regular expression and a string, and returns an array of all the matches
                 *
                 * @param {string} regExp - The regular expression to match against.
                 * @param {string} str - The string to search.
                 *
                 * @returns {Array<boolean>}
                 */
                const matchAll = (regExp, str) => {
                    let matches;
                    const arr = [];

                    while ((matches = regExp.exec(str)) !== null) {
                        arr.push(matches);
                    }

                    return arr;
                }

                /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
                const isHTMLForm = kindOfTest('HTMLFormElement');

                const toCamelCase = str => {
                    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
                        function replacer(m, p1, p2) {
                            return p1.toUpperCase() + p2;
                        }
                    );
                };

                /* Creating a function that will check if an object has a property. */
                const utils_hasOwnProperty = (({
                    hasOwnProperty
                }) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

                /**
                 * Determine if a value is a RegExp object
                 *
                 * @param {*} val The value to test
                 *
                 * @returns {boolean} True if value is a RegExp object, otherwise false
                 */
                const isRegExp = kindOfTest('RegExp');

                const reduceDescriptors = (obj, reducer) => {
                    const descriptors = Object.getOwnPropertyDescriptors(obj);
                    const reducedDescriptors = {};

                    forEach(descriptors, (descriptor, name) => {
                        let ret;
                        if ((ret = reducer(descriptor, name, obj)) !== false) {
                            reducedDescriptors[name] = ret || descriptor;
                        }
                    });

                    Object.defineProperties(obj, reducedDescriptors);
                }

                /**
                 * Makes all methods read-only
                 * @param {Object} obj
                 */

                const freezeMethods = (obj) => {
                    reduceDescriptors(obj, (descriptor, name) => {
                        // skip restricted props in strict mode
                        if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
                            return false;
                        }

                        const value = obj[name];

                        if (!isFunction(value)) return;

                        descriptor.enumerable = false;

                        if ('writable' in descriptor) {
                            descriptor.writable = false;
                            return;
                        }

                        if (!descriptor.set) {
                            descriptor.set = () => {
                                throw Error('Can not rewrite read-only method \'' + name + '\'');
                            };
                        }
                    });
                }

                const toObjectSet = (arrayOrString, delimiter) => {
                    const obj = {};

                    const define = (arr) => {
                        arr.forEach(value => {
                            obj[value] = true;
                        });
                    }

                    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

                    return obj;
                }

                const noop = () => {}

                const toFiniteNumber = (value, defaultValue) => {
                    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
                }

                const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

                const DIGIT = '0123456789';

                const ALPHABET = {
                    DIGIT,
                    ALPHA,
                    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
                }

                const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
                    let str = '';
                    const {
                        length
                    } = alphabet;
                    while (size--) {
                        str += alphabet[Math.random() * length | 0]
                    }

                    return str;
                }

                /**
                 * If the thing is a FormData object, return true, otherwise return false.
                 *
                 * @param {unknown} thing - The thing to check.
                 *
                 * @returns {boolean}
                 */
                function isSpecCompliantForm(thing) {
                    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
                }

                const toJSONObject = (obj) => {
                    const stack = new Array(10);

                    const visit = (source, i) => {

                        if (isObject(source)) {
                            if (stack.indexOf(source) >= 0) {
                                return;
                            }

                            if (!('toJSON' in source)) {
                                stack[i] = source;
                                const target = isArray(source) ? [] : {};

                                forEach(source, (value, key) => {
                                    const reducedValue = visit(value, i + 1);
                                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                                });

                                stack[i] = undefined;

                                return target;
                            }
                        }

                        return source;
                    }

                    return visit(obj, 0);
                }

                const isAsyncFn = kindOfTest('AsyncFunction');

                const isThenable = (thing) =>
                    thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

                // original code
                // https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

                const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
                    if (setImmediateSupported) {
                        return setImmediate;
                    }

                    return postMessageSupported ? ((token, callbacks) => {
                        _global.addEventListener("message", ({
                            source,
                            data
                        }) => {
                            if (source === _global && data === token) {
                                callbacks.length && callbacks.shift()();
                            }
                        }, false);

                        return (cb) => {
                            callbacks.push(cb);
                            _global.postMessage(token, "*");
                        }
                    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
                })(
                    typeof setImmediate === 'function',
                    isFunction(_global.postMessage)
                );

                const asap = typeof queueMicrotask !== 'undefined' ?
                    queueMicrotask.bind(_global) : (typeof process !== 'undefined' && process.nextTick || _setImmediate);

                // *********************

                /* harmony default export */
                const utils = ({
                    isArray,
                    isArrayBuffer,
                    isBuffer,
                    isFormData,
                    isArrayBufferView,
                    isString,
                    isNumber,
                    isBoolean,
                    isObject,
                    isPlainObject,
                    isReadableStream,
                    isRequest,
                    isResponse,
                    isHeaders,
                    isUndefined,
                    isDate,
                    isFile,
                    isBlob,
                    isRegExp,
                    isFunction,
                    isStream,
                    isURLSearchParams,
                    isTypedArray,
                    isFileList,
                    forEach,
                    merge,
                    extend,
                    trim,
                    stripBOM,
                    inherits,
                    toFlatObject,
                    kindOf,
                    kindOfTest,
                    endsWith,
                    toArray,
                    forEachEntry,
                    matchAll,
                    isHTMLForm,
                    hasOwnProperty: utils_hasOwnProperty,
                    hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
                    reduceDescriptors,
                    freezeMethods,
                    toObjectSet,
                    toCamelCase,
                    noop,
                    toFiniteNumber,
                    findKey,
                    global: _global,
                    isContextDefined,
                    ALPHABET,
                    generateString,
                    isSpecCompliantForm,
                    toJSONObject,
                    isAsyncFn,
                    isThenable,
                    setImmediate: _setImmediate,
                    asap
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/AxiosError.js




                /**
                 * Create an Error with the specified message, config, error code, request and response.
                 *
                 * @param {string} message The error message.
                 * @param {string} [code] The error code (for example, 'ECONNABORTED').
                 * @param {Object} [config] The config.
                 * @param {Object} [request] The request.
                 * @param {Object} [response] The response.
                 *
                 * @returns {Error} The created error.
                 */
                function AxiosError(message, code, config, request, response) {
                    Error.call(this);

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    } else {
                        this.stack = (new Error()).stack;
                    }

                    this.message = message;
                    this.name = 'AxiosError';
                    code && (this.code = code);
                    config && (this.config = config);
                    request && (this.request = request);
                    if (response) {
                        this.response = response;
                        this.status = response.status ? response.status : null;
                    }
                }

                utils.inherits(AxiosError, Error, {
                    toJSON: function toJSON() {
                        return {
                            // Standard
                            message: this.message,
                            name: this.name,
                            // Microsoft
                            description: this.description,
                            number: this.number,
                            // Mozilla
                            fileName: this.fileName,
                            lineNumber: this.lineNumber,
                            columnNumber: this.columnNumber,
                            stack: this.stack,
                            // Axios
                            config: utils.toJSONObject(this.config),
                            code: this.code,
                            status: this.status
                        };
                    }
                });

                const AxiosError_prototype = AxiosError.prototype;
                const descriptors = {};

                [
                    'ERR_BAD_OPTION_VALUE',
                    'ERR_BAD_OPTION',
                    'ECONNABORTED',
                    'ETIMEDOUT',
                    'ERR_NETWORK',
                    'ERR_FR_TOO_MANY_REDIRECTS',
                    'ERR_DEPRECATED',
                    'ERR_BAD_RESPONSE',
                    'ERR_BAD_REQUEST',
                    'ERR_CANCELED',
                    'ERR_NOT_SUPPORT',
                    'ERR_INVALID_URL'
                    // eslint-disable-next-line func-names
                ].forEach(code => {
                    descriptors[code] = {
                        value: code
                    };
                });

                Object.defineProperties(AxiosError, descriptors);
                Object.defineProperty(AxiosError_prototype, 'isAxiosError', {
                    value: true
                });

                // eslint-disable-next-line func-names
                AxiosError.from = (error, code, config, request, response, customProps) => {
                    const axiosError = Object.create(AxiosError_prototype);

                    utils.toFlatObject(error, axiosError, function filter(obj) {
                        return obj !== Error.prototype;
                    }, prop => {
                        return prop !== 'isAxiosError';
                    });

                    AxiosError.call(axiosError, error.message, code, config, request, response);

                    axiosError.cause = error;

                    axiosError.name = error.name;

                    customProps && Object.assign(axiosError, customProps);

                    return axiosError;
                };

                /* harmony default export */
                const core_AxiosError = (AxiosError);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/null.js
                // eslint-disable-next-line strict
                /* harmony default export */
                const helpers_null = (null);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/toFormData.js
                /* provided dependency */
                var Buffer = __webpack_require__("pMyr")["Buffer"];




                // temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


                /**
                 * Determines if the given thing is a array or js object.
                 *
                 * @param {string} thing - The object or array to be visited.
                 *
                 * @returns {boolean}
                 */
                function isVisitable(thing) {
                    return utils.isPlainObject(thing) || utils.isArray(thing);
                }

                /**
                 * It removes the brackets from the end of a string
                 *
                 * @param {string} key - The key of the parameter.
                 *
                 * @returns {string} the key without the brackets.
                 */
                function removeBrackets(key) {
                    return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
                }

                /**
                 * It takes a path, a key, and a boolean, and returns a string
                 *
                 * @param {string} path - The path to the current key.
                 * @param {string} key - The key of the current object being iterated over.
                 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
                 *
                 * @returns {string} The path to the current key.
                 */
                function renderKey(path, key, dots) {
                    if (!path) return key;
                    return path.concat(key).map(function each(token, i) {
                        // eslint-disable-next-line no-param-reassign
                        token = removeBrackets(token);
                        return !dots && i ? '[' + token + ']' : token;
                    }).join(dots ? '.' : '');
                }

                /**
                 * If the array is an array and none of its elements are visitable, then it's a flat array.
                 *
                 * @param {Array<any>} arr - The array to check
                 *
                 * @returns {boolean}
                 */
                function isFlatArray(arr) {
                    return utils.isArray(arr) && !arr.some(isVisitable);
                }

                const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
                    return /^is[A-Z]/.test(prop);
                });

                /**
                 * Convert a data object to FormData
                 *
                 * @param {Object} obj
                 * @param {?Object} [formData]
                 * @param {?Object} [options]
                 * @param {Function} [options.visitor]
                 * @param {Boolean} [options.metaTokens = true]
                 * @param {Boolean} [options.dots = false]
                 * @param {?Boolean} [options.indexes = false]
                 *
                 * @returns {Object}
                 **/

                /**
                 * It converts an object into a FormData object
                 *
                 * @param {Object<any, any>} obj - The object to convert to form data.
                 * @param {string} formData - The FormData object to append to.
                 * @param {Object<string, any>} options
                 *
                 * @returns
                 */
                function toFormData(obj, formData, options) {
                    if (!utils.isObject(obj)) {
                        throw new TypeError('target must be an object');
                    }

                    // eslint-disable-next-line no-param-reassign
                    formData = formData || new(helpers_null || FormData)();

                    // eslint-disable-next-line no-param-reassign
                    options = utils.toFlatObject(options, {
                        metaTokens: true,
                        dots: false,
                        indexes: false
                    }, false, function defined(option, source) {
                        // eslint-disable-next-line no-eq-null,eqeqeq
                        return !utils.isUndefined(source[option]);
                    });

                    const metaTokens = options.metaTokens;
                    // eslint-disable-next-line no-use-before-define
                    const visitor = options.visitor || defaultVisitor;
                    const dots = options.dots;
                    const indexes = options.indexes;
                    const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
                    const useBlob = _Blob && utils.isSpecCompliantForm(formData);

                    if (!utils.isFunction(visitor)) {
                        throw new TypeError('visitor must be a function');
                    }

                    function convertValue(value) {
                        if (value === null) return '';

                        if (utils.isDate(value)) {
                            return value.toISOString();
                        }

                        if (!useBlob && utils.isBlob(value)) {
                            throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
                        }

                        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
                            return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
                        }

                        return value;
                    }

                    /**
                     * Default visitor.
                     *
                     * @param {*} value
                     * @param {String|Number} key
                     * @param {Array<String|Number>} path
                     * @this {FormData}
                     *
                     * @returns {boolean} return true to visit the each prop of the value recursively
                     */
                    function defaultVisitor(value, key, path) {
                        let arr = value;

                        if (value && !path && typeof value === 'object') {
                            if (utils.endsWith(key, '{}')) {
                                // eslint-disable-next-line no-param-reassign
                                key = metaTokens ? key : key.slice(0, -2);
                                // eslint-disable-next-line no-param-reassign
                                value = JSON.stringify(value);
                            } else if (
                                (utils.isArray(value) && isFlatArray(value)) ||
                                ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value)))) {
                                // eslint-disable-next-line no-param-reassign
                                key = removeBrackets(key);

                                arr.forEach(function each(el, index) {
                                    !(utils.isUndefined(el) || el === null) && formData.append(
                                        // eslint-disable-next-line no-nested-ternary
                                        indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
                                        convertValue(el)
                                    );
                                });
                                return false;
                            }
                        }

                        if (isVisitable(value)) {
                            return true;
                        }

                        formData.append(renderKey(path, key, dots), convertValue(value));

                        return false;
                    }

                    const stack = [];

                    const exposedHelpers = Object.assign(predicates, {
                        defaultVisitor,
                        convertValue,
                        isVisitable
                    });

                    function build(value, path) {
                        if (utils.isUndefined(value)) return;

                        if (stack.indexOf(value) !== -1) {
                            throw Error('Circular reference detected in ' + path.join('.'));
                        }

                        stack.push(value);

                        utils.forEach(value, function each(el, key) {
                            const result = !(utils.isUndefined(el) || el === null) && visitor.call(
                                formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
                            );

                            if (result === true) {
                                build(el, path ? path.concat(key) : [key]);
                            }
                        });

                        stack.pop();
                    }

                    if (!utils.isObject(obj)) {
                        throw new TypeError('data must be an object');
                    }

                    build(obj);

                    return formData;
                }

                /* harmony default export */
                const helpers_toFormData = (toFormData);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/AxiosURLSearchParams.js




                /**
                 * It encodes a string by replacing all characters that are not in the unreserved set with
                 * their percent-encoded equivalents
                 *
                 * @param {string} str - The string to encode.
                 *
                 * @returns {string} The encoded string.
                 */
                function encode(str) {
                    const charMap = {
                        '!': '%21',
                        "'": '%27',
                        '(': '%28',
                        ')': '%29',
                        '~': '%7E',
                        '%20': '+',
                        '%00': '\x00'
                    };
                    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
                        return charMap[match];
                    });
                }

                /**
                 * It takes a params object and converts it to a FormData object
                 *
                 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
                 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
                 *
                 * @returns {void}
                 */
                function AxiosURLSearchParams(params, options) {
                    this._pairs = [];

                    params && helpers_toFormData(params, this, options);
                }

                const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

                AxiosURLSearchParams_prototype.append = function append(name, value) {
                    this._pairs.push([name, value]);
                };

                AxiosURLSearchParams_prototype.toString = function toString(encoder) {
                    const _encode = encoder ? function(value) {
                        return encoder.call(this, value, encode);
                    } : encode;

                    return this._pairs.map(function each(pair) {
                        return _encode(pair[0]) + '=' + _encode(pair[1]);
                    }, '').join('&');
                };

                /* harmony default export */
                const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/buildURL.js





                /**
                 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
                 * URI encoded counterparts
                 *
                 * @param {string} val The value to be encoded.
                 *
                 * @returns {string} The encoded value.
                 */
                function buildURL_encode(val) {
                    return encodeURIComponent(val).
                    replace(/%3A/gi, ':').
                    replace(/%24/g, '$').
                    replace(/%2C/gi, ',').
                    replace(/%20/g, '+').
                    replace(/%5B/gi, '[').
                    replace(/%5D/gi, ']');
                }

                /**
                 * Build a URL by appending params to the end
                 *
                 * @param {string} url The base of the url (e.g., http://www.google.com)
                 * @param {object} [params] The params to be appended
                 * @param {?(object|Function)} options
                 *
                 * @returns {string} The formatted url
                 */
                function buildURL(url, params, options) {
                    /*eslint no-param-reassign:0*/
                    if (!params) {
                        return url;
                    }

                    const _encode = options && options.encode || buildURL_encode;

                    if (utils.isFunction(options)) {
                        options = {
                            serialize: options
                        };
                    }

                    const serializeFn = options && options.serialize;

                    let serializedParams;

                    if (serializeFn) {
                        serializedParams = serializeFn(params, options);
                    } else {
                        serializedParams = utils.isURLSearchParams(params) ?
                            params.toString() :
                            new helpers_AxiosURLSearchParams(params, options).toString(_encode);
                    }

                    if (serializedParams) {
                        const hashmarkIndex = url.indexOf("#");

                        if (hashmarkIndex !== -1) {
                            url = url.slice(0, hashmarkIndex);
                        }
                        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
                    }

                    return url;
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/InterceptorManager.js




                class InterceptorManager {
                    constructor() {
                        this.handlers = [];
                    }

                    /**
                     * Add a new interceptor to the stack
                     *
                     * @param {Function} fulfilled The function to handle `then` for a `Promise`
                     * @param {Function} rejected The function to handle `reject` for a `Promise`
                     *
                     * @return {Number} An ID used to remove interceptor later
                     */
                    use(fulfilled, rejected, options) {
                        this.handlers.push({
                            fulfilled,
                            rejected,
                            synchronous: options ? options.synchronous : false,
                            runWhen: options ? options.runWhen : null
                        });
                        return this.handlers.length - 1;
                    }

                    /**
                     * Remove an interceptor from the stack
                     *
                     * @param {Number} id The ID that was returned by `use`
                     *
                     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
                     */
                    eject(id) {
                        if (this.handlers[id]) {
                            this.handlers[id] = null;
                        }
                    }

                    /**
                     * Clear all interceptors from the stack
                     *
                     * @returns {void}
                     */
                    clear() {
                        if (this.handlers) {
                            this.handlers = [];
                        }
                    }

                    /**
                     * Iterate over all the registered interceptors
                     *
                     * This method is particularly useful for skipping over any
                     * interceptors that may have become `null` calling `eject`.
                     *
                     * @param {Function} fn The function to call for each interceptor
                     *
                     * @returns {void}
                     */
                    forEach(fn) {
                        utils.forEach(this.handlers, function forEachHandler(h) {
                            if (h !== null) {
                                fn(h);
                            }
                        });
                    }
                }

                /* harmony default export */
                const core_InterceptorManager = (InterceptorManager);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/defaults/transitional.js


                /* harmony default export */
                const defaults_transitional = ({
                    silentJSONParsing: true,
                    forcedJSONParsing: true,
                    clarifyTimeoutError: false
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



                /* harmony default export */
                const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/browser/classes/FormData.js


                /* harmony default export */
                const classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/browser/classes/Blob.js


                /* harmony default export */
                const classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/browser/index.js




                /* harmony default export */
                const browser = ({
                    isBrowser: true,
                    classes: {
                        URLSearchParams: classes_URLSearchParams,
                        FormData: classes_FormData,
                        Blob: classes_Blob
                    },
                    protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/common/utils.js
                const hasBrowserEnv = true && typeof document !== 'undefined';

                const _navigator = typeof navigator === 'object' && navigator || undefined;

                /**
                 * Determine if we're running in a standard browser environment
                 *
                 * This allows axios to run in a web worker, and react-native.
                 * Both environments support XMLHttpRequest, but not fully standard globals.
                 *
                 * web workers:
                 *  typeof window -> undefined
                 *  typeof document -> undefined
                 *
                 * react-native:
                 *  navigator.product -> 'ReactNative'
                 * nativescript
                 *  navigator.product -> 'NativeScript' or 'NS'
                 *
                 * @returns {boolean}
                 */
                const hasStandardBrowserEnv = hasBrowserEnv &&
                    (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

                /**
                 * Determine if we're running in a standard browser webWorker environment
                 *
                 * Although the `isStandardBrowserEnv` method indicates that
                 * `allows axios to run in a web worker`, the WebWorker will still be
                 * filtered out due to its judgment standard
                 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
                 * This leads to a problem when axios post `FormData` in webWorker
                 */
                const hasStandardBrowserWebWorkerEnv = (() => {
                    return (
                        typeof WorkerGlobalScope !== 'undefined' &&
                        // eslint-disable-next-line no-undef
                        self instanceof WorkerGlobalScope &&
                        typeof self.importScripts === 'function'
                    );
                })();

                const origin = hasBrowserEnv && window.location.href || 'http://localhost';



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/index.js



                /* harmony default export */
                const platform = ({
                    ...common_utils_namespaceObject,
                    ...browser
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/toURLEncodedForm.js






                function toURLEncodedForm(data, options) {
                    return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
                        visitor: function(value, key, path, helpers) {
                            if (platform.isNode && utils.isBuffer(value)) {
                                this.append(key, value.toString('base64'));
                                return false;
                            }

                            return helpers.defaultVisitor.apply(this, arguments);
                        }
                    }, options));
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/formDataToJSON.js




                /**
                 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
                 *
                 * @param {string} name - The name of the property to get.
                 *
                 * @returns An array of strings.
                 */
                function parsePropPath(name) {
                    // foo[x][y][z]
                    // foo.x.y.z
                    // foo-x-y-z
                    // foo x y z
                    return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
                        return match[0] === '[]' ? '' : match[1] || match[0];
                    });
                }

                /**
                 * Convert an array to an object.
                 *
                 * @param {Array<any>} arr - The array to convert to an object.
                 *
                 * @returns An object with the same keys and values as the array.
                 */
                function arrayToObject(arr) {
                    const obj = {};
                    const keys = Object.keys(arr);
                    let i;
                    const len = keys.length;
                    let key;
                    for (i = 0; i < len; i++) {
                        key = keys[i];
                        obj[key] = arr[key];
                    }
                    return obj;
                }

                /**
                 * It takes a FormData object and returns a JavaScript object
                 *
                 * @param {string} formData The FormData object to convert to JSON.
                 *
                 * @returns {Object<string, any> | null} The converted object.
                 */
                function formDataToJSON(formData) {
                    function buildPath(path, value, target, index) {
                        let name = path[index++];

                        if (name === '__proto__') return true;

                        const isNumericKey = Number.isFinite(+name);
                        const isLast = index >= path.length;
                        name = !name && utils.isArray(target) ? target.length : name;

                        if (isLast) {
                            if (utils.hasOwnProp(target, name)) {
                                target[name] = [target[name], value];
                            } else {
                                target[name] = value;
                            }

                            return !isNumericKey;
                        }

                        if (!target[name] || !utils.isObject(target[name])) {
                            target[name] = [];
                        }

                        const result = buildPath(path, value, target[name], index);

                        if (result && utils.isArray(target[name])) {
                            target[name] = arrayToObject(target[name]);
                        }

                        return !isNumericKey;
                    }

                    if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
                        const obj = {};

                        utils.forEachEntry(formData, (name, value) => {
                            buildPath(parsePropPath(name), value, obj, 0);
                        });

                        return obj;
                    }

                    return null;
                }

                /* harmony default export */
                const helpers_formDataToJSON = (formDataToJSON);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/defaults/index.js










                /**
                 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
                 * of the input
                 *
                 * @param {any} rawValue - The value to be stringified.
                 * @param {Function} parser - A function that parses a string into a JavaScript object.
                 * @param {Function} encoder - A function that takes a value and returns a string.
                 *
                 * @returns {string} A stringified version of the rawValue.
                 */
                function stringifySafely(rawValue, parser, encoder) {
                    if (utils.isString(rawValue)) {
                        try {
                            (parser || JSON.parse)(rawValue);
                            return utils.trim(rawValue);
                        } catch (e) {
                            if (e.name !== 'SyntaxError') {
                                throw e;
                            }
                        }
                    }

                    return (encoder || JSON.stringify)(rawValue);
                }

                const defaults = {

                    transitional: defaults_transitional,

                    adapter: ['xhr', 'http', 'fetch'],

                    transformRequest: [function transformRequest(data, headers) {
                        const contentType = headers.getContentType() || '';
                        const hasJSONContentType = contentType.indexOf('application/json') > -1;
                        const isObjectPayload = utils.isObject(data);

                        if (isObjectPayload && utils.isHTMLForm(data)) {
                            data = new FormData(data);
                        }

                        const isFormData = utils.isFormData(data);

                        if (isFormData) {
                            return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
                        }

                        if (utils.isArrayBuffer(data) ||
                            utils.isBuffer(data) ||
                            utils.isStream(data) ||
                            utils.isFile(data) ||
                            utils.isBlob(data) ||
                            utils.isReadableStream(data)
                        ) {
                            return data;
                        }
                        if (utils.isArrayBufferView(data)) {
                            return data.buffer;
                        }
                        if (utils.isURLSearchParams(data)) {
                            headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
                            return data.toString();
                        }

                        let isFileList;

                        if (isObjectPayload) {
                            if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
                                return toURLEncodedForm(data, this.formSerializer).toString();
                            }

                            if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
                                const _FormData = this.env && this.env.FormData;

                                return helpers_toFormData(
                                    isFileList ? {
                                        'files[]': data
                                    } : data,
                                    _FormData && new _FormData(),
                                    this.formSerializer
                                );
                            }
                        }

                        if (isObjectPayload || hasJSONContentType) {
                            headers.setContentType('application/json', false);
                            return stringifySafely(data);
                        }

                        return data;
                    }],

                    transformResponse: [function transformResponse(data) {
                        const transitional = this.transitional || defaults.transitional;
                        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
                        const JSONRequested = this.responseType === 'json';

                        if (utils.isResponse(data) || utils.isReadableStream(data)) {
                            return data;
                        }

                        if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
                            const silentJSONParsing = transitional && transitional.silentJSONParsing;
                            const strictJSONParsing = !silentJSONParsing && JSONRequested;

                            try {
                                return JSON.parse(data);
                            } catch (e) {
                                if (strictJSONParsing) {
                                    if (e.name === 'SyntaxError') {
                                        throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                                    }
                                    throw e;
                                }
                            }
                        }

                        return data;
                    }],

                    /**
                     * A timeout in milliseconds to abort a request. If set to 0 (default) a
                     * timeout is not created.
                     */
                    timeout: 0,

                    xsrfCookieName: 'XSRF-TOKEN',
                    xsrfHeaderName: 'X-XSRF-TOKEN',

                    maxContentLength: -1,
                    maxBodyLength: -1,

                    env: {
                        FormData: platform.classes.FormData,
                        Blob: platform.classes.Blob
                    },

                    validateStatus: function validateStatus(status) {
                        return status >= 200 && status < 300;
                    },

                    headers: {
                        common: {
                            'Accept': 'application/json, text/plain, */*',
                            'Content-Type': undefined
                        }
                    }
                };

                utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
                    defaults.headers[method] = {};
                });

                /* harmony default export */
                const lib_defaults = (defaults);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/parseHeaders.js




                // RawAxiosHeaders whose duplicates are ignored by node
                // c.f. https://nodejs.org/api/http.html#http_message_headers
                const ignoreDuplicateOf = utils.toObjectSet([
                    'age', 'authorization', 'content-length', 'content-type', 'etag',
                    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
                    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
                    'referer', 'retry-after', 'user-agent'
                ]);

                /**
                 * Parse headers into an object
                 *
                 * ```
                 * Date: Wed, 27 Aug 2014 08:58:49 GMT
                 * Content-Type: application/json
                 * Connection: keep-alive
                 * Transfer-Encoding: chunked
                 * ```
                 *
                 * @param {String} rawHeaders Headers needing to be parsed
                 *
                 * @returns {Object} Headers parsed into an object
                 */
                /* harmony default export */
                const parseHeaders = (rawHeaders => {
                    const parsed = {};
                    let key;
                    let val;
                    let i;

                    rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
                        i = line.indexOf(':');
                        key = line.substring(0, i).trim().toLowerCase();
                        val = line.substring(i + 1).trim();

                        if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
                            return;
                        }

                        if (key === 'set-cookie') {
                            if (parsed[key]) {
                                parsed[key].push(val);
                            } else {
                                parsed[key] = [val];
                            }
                        } else {
                            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                        }
                    });

                    return parsed;
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/AxiosHeaders.js





                const $internals = Symbol('internals');

                function normalizeHeader(header) {
                    return header && String(header).trim().toLowerCase();
                }

                function normalizeValue(value) {
                    if (value === false || value == null) {
                        return value;
                    }

                    return utils.isArray(value) ? value.map(normalizeValue) : String(value);
                }

                function parseTokens(str) {
                    const tokens = Object.create(null);
                    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                    let match;

                    while ((match = tokensRE.exec(str))) {
                        tokens[match[1]] = match[2];
                    }

                    return tokens;
                }

                const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

                function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
                    if (utils.isFunction(filter)) {
                        return filter.call(this, value, header);
                    }

                    if (isHeaderNameFilter) {
                        value = header;
                    }

                    if (!utils.isString(value)) return;

                    if (utils.isString(filter)) {
                        return value.indexOf(filter) !== -1;
                    }

                    if (utils.isRegExp(filter)) {
                        return filter.test(value);
                    }
                }

                function formatHeader(header) {
                    return header.trim()
                        .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
                            return char.toUpperCase() + str;
                        });
                }

                function buildAccessors(obj, header) {
                    const accessorName = utils.toCamelCase(' ' + header);

                    ['get', 'set', 'has'].forEach(methodName => {
                        Object.defineProperty(obj, methodName + accessorName, {
                            value: function(arg1, arg2, arg3) {
                                return this[methodName].call(this, header, arg1, arg2, arg3);
                            },
                            configurable: true
                        });
                    });
                }

                class AxiosHeaders {
                    constructor(headers) {
                        headers && this.set(headers);
                    }

                    set(header, valueOrRewrite, rewrite) {
                        const self = this;

                        function setHeader(_value, _header, _rewrite) {
                            const lHeader = normalizeHeader(_header);

                            if (!lHeader) {
                                throw new Error('header name must be a non-empty string');
                            }

                            const key = utils.findKey(self, lHeader);

                            if (!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
                                self[key || _header] = normalizeValue(_value);
                            }
                        }

                        const setHeaders = (headers, _rewrite) =>
                            utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

                        if (utils.isPlainObject(header) || header instanceof this.constructor) {
                            setHeaders(header, valueOrRewrite)
                        } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
                            setHeaders(parseHeaders(header), valueOrRewrite);
                        } else if (utils.isHeaders(header)) {
                            for (const [key, value] of header.entries()) {
                                setHeader(value, key, rewrite);
                            }
                        } else {
                            header != null && setHeader(valueOrRewrite, header, rewrite);
                        }

                        return this;
                    }

                    get(header, parser) {
                        header = normalizeHeader(header);

                        if (header) {
                            const key = utils.findKey(this, header);

                            if (key) {
                                const value = this[key];

                                if (!parser) {
                                    return value;
                                }

                                if (parser === true) {
                                    return parseTokens(value);
                                }

                                if (utils.isFunction(parser)) {
                                    return parser.call(this, value, key);
                                }

                                if (utils.isRegExp(parser)) {
                                    return parser.exec(value);
                                }

                                throw new TypeError('parser must be boolean|regexp|function');
                            }
                        }
                    }

                    has(header, matcher) {
                        header = normalizeHeader(header);

                        if (header) {
                            const key = utils.findKey(this, header);

                            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
                        }

                        return false;
                    }

                    delete(header, matcher) {
                        const self = this;
                        let deleted = false;

                        function deleteHeader(_header) {
                            _header = normalizeHeader(_header);

                            if (_header) {
                                const key = utils.findKey(self, _header);

                                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                                    delete self[key];

                                    deleted = true;
                                }
                            }
                        }

                        if (utils.isArray(header)) {
                            header.forEach(deleteHeader);
                        } else {
                            deleteHeader(header);
                        }

                        return deleted;
                    }

                    clear(matcher) {
                        const keys = Object.keys(this);
                        let i = keys.length;
                        let deleted = false;

                        while (i--) {
                            const key = keys[i];
                            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                                delete this[key];
                                deleted = true;
                            }
                        }

                        return deleted;
                    }

                    normalize(format) {
                        const self = this;
                        const headers = {};

                        utils.forEach(this, (value, header) => {
                            const key = utils.findKey(headers, header);

                            if (key) {
                                self[key] = normalizeValue(value);
                                delete self[header];
                                return;
                            }

                            const normalized = format ? formatHeader(header) : String(header).trim();

                            if (normalized !== header) {
                                delete self[header];
                            }

                            self[normalized] = normalizeValue(value);

                            headers[normalized] = true;
                        });

                        return this;
                    }

                    concat(...targets) {
                        return this.constructor.concat(this, ...targets);
                    }

                    toJSON(asStrings) {
                        const obj = Object.create(null);

                        utils.forEach(this, (value, header) => {
                            value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
                        });

                        return obj;
                    }

                    [Symbol.iterator]() {
                        return Object.entries(this.toJSON())[Symbol.iterator]();
                    }

                    toString() {
                        return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
                    }

                    get[Symbol.toStringTag]() {
                        return 'AxiosHeaders';
                    }

                    static from(thing) {
                        return thing instanceof this ? thing : new this(thing);
                    }

                    static concat(first, ...targets) {
                        const computed = new this(first);

                        targets.forEach((target) => computed.set(target));

                        return computed;
                    }

                    static accessor(header) {
                        const internals = this[$internals] = (this[$internals] = {
                            accessors: {}
                        });

                        const accessors = internals.accessors;
                        const prototype = this.prototype;

                        function defineAccessor(_header) {
                            const lHeader = normalizeHeader(_header);

                            if (!accessors[lHeader]) {
                                buildAccessors(prototype, _header);
                                accessors[lHeader] = true;
                            }
                        }

                        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

                        return this;
                    }
                }

                AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

                // reserved names hotfix
                utils.reduceDescriptors(AxiosHeaders.prototype, ({
                    value
                }, key) => {
                    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
                    return {
                        get: () => value,
                        set(headerValue) {
                            this[mapped] = headerValue;
                        }
                    }
                });

                utils.freezeMethods(AxiosHeaders);

                /* harmony default export */
                const core_AxiosHeaders = (AxiosHeaders);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/transformData.js






                /**
                 * Transform the data for a request or a response
                 *
                 * @param {Array|Function} fns A single function or Array of functions
                 * @param {?Object} response The response object
                 *
                 * @returns {*} The resulting transformed data
                 */
                function transformData(fns, response) {
                    const config = this || lib_defaults;
                    const context = response || config;
                    const headers = core_AxiosHeaders.from(context.headers);
                    let data = context.data;

                    utils.forEach(fns, function transform(fn) {
                        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
                    });

                    headers.normalize();

                    return data;
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/cancel/isCancel.js


                function isCancel(value) {
                    return !!(value && value.__CANCEL__);
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/cancel/CanceledError.js





                /**
                 * A `CanceledError` is an object that is thrown when an operation is canceled.
                 *
                 * @param {string=} message The message.
                 * @param {Object=} config The config.
                 * @param {Object=} request The request.
                 *
                 * @returns {CanceledError} The created error.
                 */
                function CanceledError(message, config, request) {
                    // eslint-disable-next-line no-eq-null,eqeqeq
                    core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
                    this.name = 'CanceledError';
                }

                utils.inherits(CanceledError, core_AxiosError, {
                    __CANCEL__: true
                });

                /* harmony default export */
                const cancel_CanceledError = (CanceledError);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/settle.js




                /**
                 * Resolve or reject a Promise based on response status.
                 *
                 * @param {Function} resolve A function that resolves the promise.
                 * @param {Function} reject A function that rejects the promise.
                 * @param {object} response The response.
                 *
                 * @returns {object} The response.
                 */
                function settle(resolve, reject, response) {
                    const validateStatus = response.config.validateStatus;
                    if (!response.status || !validateStatus || validateStatus(response.status)) {
                        resolve(response);
                    } else {
                        reject(new core_AxiosError(
                            'Request failed with status code ' + response.status, [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
                            response.config,
                            response.request,
                            response
                        ));
                    }
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/parseProtocol.js


                function parseProtocol(url) {
                    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
                    return match && match[1] || '';
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/speedometer.js


                /**
                 * Calculate data maxRate
                 * @param {Number} [samplesCount= 10]
                 * @param {Number} [min= 1000]
                 * @returns {Function}
                 */
                function speedometer(samplesCount, min) {
                    samplesCount = samplesCount || 10;
                    const bytes = new Array(samplesCount);
                    const timestamps = new Array(samplesCount);
                    let head = 0;
                    let tail = 0;
                    let firstSampleTS;

                    min = min !== undefined ? min : 1000;

                    return function push(chunkLength) {
                        const now = Date.now();

                        const startedAt = timestamps[tail];

                        if (!firstSampleTS) {
                            firstSampleTS = now;
                        }

                        bytes[head] = chunkLength;
                        timestamps[head] = now;

                        let i = tail;
                        let bytesCount = 0;

                        while (i !== head) {
                            bytesCount += bytes[i++];
                            i = i % samplesCount;
                        }

                        head = (head + 1) % samplesCount;

                        if (head === tail) {
                            tail = (tail + 1) % samplesCount;
                        }

                        if (now - firstSampleTS < min) {
                            return;
                        }

                        const passed = startedAt && now - startedAt;

                        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
                    };
                }

                /* harmony default export */
                const helpers_speedometer = (speedometer);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/throttle.js
                /**
                 * Throttle decorator
                 * @param {Function} fn
                 * @param {Number} freq
                 * @return {Function}
                 */
                function throttle(fn, freq) {
                    let timestamp = 0;
                    let threshold = 1000 / freq;
                    let lastArgs;
                    let timer;

                    const invoke = (args, now = Date.now()) => {
                        timestamp = now;
                        lastArgs = null;
                        if (timer) {
                            clearTimeout(timer);
                            timer = null;
                        }
                        fn.apply(null, args);
                    }

                    const throttled = (...args) => {
                        const now = Date.now();
                        const passed = now - timestamp;
                        if (passed >= threshold) {
                            invoke(args, now);
                        } else {
                            lastArgs = args;
                            if (!timer) {
                                timer = setTimeout(() => {
                                    timer = null;
                                    invoke(lastArgs)
                                }, threshold - passed);
                            }
                        }
                    }

                    const flush = () => lastArgs && invoke(lastArgs);

                    return [throttled, flush];
                }

                /* harmony default export */
                const helpers_throttle = (throttle);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/progressEventReducer.js




                const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
                    let bytesNotified = 0;
                    const _speedometer = helpers_speedometer(50, 250);

                    return helpers_throttle(e => {
                        const loaded = e.loaded;
                        const total = e.lengthComputable ? e.total : undefined;
                        const progressBytes = loaded - bytesNotified;
                        const rate = _speedometer(progressBytes);
                        const inRange = loaded <= total;

                        bytesNotified = loaded;

                        const data = {
                            loaded,
                            total,
                            progress: total ? (loaded / total) : undefined,
                            bytes: progressBytes,
                            rate: rate ? rate : undefined,
                            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
                            event: e,
                            lengthComputable: total != null,
                            [isDownloadStream ? 'download' : 'upload']: true
                        };

                        listener(data);
                    }, freq);
                }

                const progressEventDecorator = (total, throttled) => {
                    const lengthComputable = total != null;

                    return [(loaded) => throttled[0]({
                        lengthComputable,
                        total,
                        loaded
                    }), throttled[1]];
                }

                const asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/isURLSameOrigin.js


                /* harmony default export */
                const isURLSameOrigin = (platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
                    url = new URL(url, platform.origin);

                    return (
                        origin.protocol === url.protocol &&
                        origin.host === url.host &&
                        (isMSIE || origin.port === url.port)
                    );
                })(
                    new URL(platform.origin),
                    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
                ) : () => true);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/cookies.js



                /* harmony default export */
                const cookies = (platform.hasStandardBrowserEnv ?

                    // Standard browser envs support document.cookie
                    {
                        write(name, value, expires, path, domain, secure) {
                            const cookie = [name + '=' + encodeURIComponent(value)];

                            utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

                            utils.isString(path) && cookie.push('path=' + path);

                            utils.isString(domain) && cookie.push('domain=' + domain);

                            secure === true && cookie.push('secure');

                            document.cookie = cookie.join('; ');
                        },

                        read(name) {
                            const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
                            return (match ? decodeURIComponent(match[3]) : null);
                        },

                        remove(name) {
                            this.write(name, '', Date.now() - 86400000);
                        }
                    }

                    :

                    // Non-standard browser env (web workers, react-native) lack needed support.
                    {
                        write() {},
                        read() {
                            return null;
                        },
                        remove() {}
                    });


                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/isAbsoluteURL.js


                /**
                 * Determines whether the specified URL is absolute
                 *
                 * @param {string} url The URL to test
                 *
                 * @returns {boolean} True if the specified URL is absolute, otherwise false
                 */
                function isAbsoluteURL(url) {
                    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
                    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
                    // by any combination of letters, digits, plus, period, or hyphen.
                    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/combineURLs.js


                /**
                 * Creates a new URL by combining the specified URLs
                 *
                 * @param {string} baseURL The base URL
                 * @param {string} relativeURL The relative URL
                 *
                 * @returns {string} The combined URL
                 */
                function combineURLs(baseURL, relativeURL) {
                    return relativeURL ?
                        baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') :
                        baseURL;
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/buildFullPath.js





                /**
                 * Creates a new URL by combining the baseURL with the requestedURL,
                 * only when the requestedURL is not already an absolute URL.
                 * If the requestURL is absolute, this function returns the requestedURL untouched.
                 *
                 * @param {string} baseURL The base URL
                 * @param {string} requestedURL Absolute or relative URL to combine
                 *
                 * @returns {string} The combined full path
                 */
                function buildFullPath(baseURL, requestedURL) {
                    if (baseURL && !isAbsoluteURL(requestedURL)) {
                        return combineURLs(baseURL, requestedURL);
                    }
                    return requestedURL;
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/mergeConfig.js





                const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing
                } : thing;

                /**
                 * Config-specific merge-function which creates a new config-object
                 * by merging two configuration objects together.
                 *
                 * @param {Object} config1
                 * @param {Object} config2
                 *
                 * @returns {Object} New object resulting from merging config2 to config1
                 */
                function mergeConfig(config1, config2) {
                    // eslint-disable-next-line no-param-reassign
                    config2 = config2 || {};
                    const config = {};

                    function getMergedValue(target, source, prop, caseless) {
                        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
                            return utils.merge.call({
                                caseless
                            }, target, source);
                        } else if (utils.isPlainObject(source)) {
                            return utils.merge({}, source);
                        } else if (utils.isArray(source)) {
                            return source.slice();
                        }
                        return source;
                    }

                    // eslint-disable-next-line consistent-return
                    function mergeDeepProperties(a, b, prop, caseless) {
                        if (!utils.isUndefined(b)) {
                            return getMergedValue(a, b, prop, caseless);
                        } else if (!utils.isUndefined(a)) {
                            return getMergedValue(undefined, a, prop, caseless);
                        }
                    }

                    // eslint-disable-next-line consistent-return
                    function valueFromConfig2(a, b) {
                        if (!utils.isUndefined(b)) {
                            return getMergedValue(undefined, b);
                        }
                    }

                    // eslint-disable-next-line consistent-return
                    function defaultToConfig2(a, b) {
                        if (!utils.isUndefined(b)) {
                            return getMergedValue(undefined, b);
                        } else if (!utils.isUndefined(a)) {
                            return getMergedValue(undefined, a);
                        }
                    }

                    // eslint-disable-next-line consistent-return
                    function mergeDirectKeys(a, b, prop) {
                        if (prop in config2) {
                            return getMergedValue(a, b);
                        } else if (prop in config1) {
                            return getMergedValue(undefined, a);
                        }
                    }

                    const mergeMap = {
                        url: valueFromConfig2,
                        method: valueFromConfig2,
                        data: valueFromConfig2,
                        baseURL: defaultToConfig2,
                        transformRequest: defaultToConfig2,
                        transformResponse: defaultToConfig2,
                        paramsSerializer: defaultToConfig2,
                        timeout: defaultToConfig2,
                        timeoutMessage: defaultToConfig2,
                        withCredentials: defaultToConfig2,
                        withXSRFToken: defaultToConfig2,
                        adapter: defaultToConfig2,
                        responseType: defaultToConfig2,
                        xsrfCookieName: defaultToConfig2,
                        xsrfHeaderName: defaultToConfig2,
                        onUploadProgress: defaultToConfig2,
                        onDownloadProgress: defaultToConfig2,
                        decompress: defaultToConfig2,
                        maxContentLength: defaultToConfig2,
                        maxBodyLength: defaultToConfig2,
                        beforeRedirect: defaultToConfig2,
                        transport: defaultToConfig2,
                        httpAgent: defaultToConfig2,
                        httpsAgent: defaultToConfig2,
                        cancelToken: defaultToConfig2,
                        socketPath: defaultToConfig2,
                        responseEncoding: defaultToConfig2,
                        validateStatus: mergeDirectKeys,
                        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
                    };

                    utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
                        const merge = mergeMap[prop] || mergeDeepProperties;
                        const configValue = merge(config1[prop], config2[prop], prop);
                        (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
                    });

                    return config;
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/resolveConfig.js









                /* harmony default export */
                const resolveConfig = ((config) => {
                    const newConfig = mergeConfig({}, config);

                    let {
                        data,
                        withXSRFToken,
                        xsrfHeaderName,
                        xsrfCookieName,
                        headers,
                        auth
                    } = newConfig;

                    newConfig.headers = headers = core_AxiosHeaders.from(headers);

                    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

                    // HTTP basic authentication
                    if (auth) {
                        headers.set('Authorization', 'Basic ' +
                            btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
                        );
                    }

                    let contentType;

                    if (utils.isFormData(data)) {
                        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
                            headers.setContentType(undefined); // Let the browser set it
                        } else if ((contentType = headers.getContentType()) !== false) {
                            // fix semicolon duplication issue for ReactNative FormData implementation
                            const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
                            headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
                        }
                    }

                    // Add xsrf header
                    // This is only done if running in a standard browser environment.
                    // Specifically not if we're in a web worker, or react-native.

                    if (platform.hasStandardBrowserEnv) {
                        withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

                        if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
                            // Add xsrf header
                            const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

                            if (xsrfValue) {
                                headers.set(xsrfHeaderName, xsrfValue);
                            }
                        }
                    }

                    return newConfig;
                });


                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/xhr.js











                const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

                /* harmony default export */
                const xhr = (isXHRAdapterSupported && function(config) {
                    return new Promise(function dispatchXhrRequest(resolve, reject) {
                        const _config = resolveConfig(config);
                        let requestData = _config.data;
                        const requestHeaders = core_AxiosHeaders.from(_config.headers).normalize();
                        let {
                            responseType,
                            onUploadProgress,
                            onDownloadProgress
                        } = _config;
                        let onCanceled;
                        let uploadThrottled, downloadThrottled;
                        let flushUpload, flushDownload;

                        function done() {
                            flushUpload && flushUpload(); // flush events
                            flushDownload && flushDownload(); // flush events

                            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

                            _config.signal && _config.signal.removeEventListener('abort', onCanceled);
                        }

                        let request = new XMLHttpRequest();

                        request.open(_config.method.toUpperCase(), _config.url, true);

                        // Set the request timeout in MS
                        request.timeout = _config.timeout;

                        function onloadend() {
                            if (!request) {
                                return;
                            }
                            // Prepare the response
                            const responseHeaders = core_AxiosHeaders.from(
                                'getAllResponseHeaders' in request && request.getAllResponseHeaders()
                            );
                            const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
                                request.responseText : request.response;
                            const response = {
                                data: responseData,
                                status: request.status,
                                statusText: request.statusText,
                                headers: responseHeaders,
                                config,
                                request
                            };

                            settle(function _resolve(value) {
                                resolve(value);
                                done();
                            }, function _reject(err) {
                                reject(err);
                                done();
                            }, response);

                            // Clean up request
                            request = null;
                        }

                        if ('onloadend' in request) {
                            // Use onloadend if available
                            request.onloadend = onloadend;
                        } else {
                            // Listen for ready state to emulate onloadend
                            request.onreadystatechange = function handleLoad() {
                                if (!request || request.readyState !== 4) {
                                    return;
                                }

                                // The request errored out and we didn't get a response, this will be
                                // handled by onerror instead
                                // With one exception: request that using file: protocol, most browsers
                                // will return status as 0 even though it's a successful request
                                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                                    return;
                                }
                                // readystate handler is calling before onerror or ontimeout handlers,
                                // so we should call onloadend on the next 'tick'
                                setTimeout(onloadend);
                            };
                        }

                        // Handle browser request cancellation (as opposed to a manual cancellation)
                        request.onabort = function handleAbort() {
                            if (!request) {
                                return;
                            }

                            reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

                            // Clean up request
                            request = null;
                        };

                        // Handle low level network errors
                        request.onerror = function handleError() {
                            // Real errors are hidden from us by the browser
                            // onerror should only fire if it's a network error
                            reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

                            // Clean up request
                            request = null;
                        };

                        // Handle timeout
                        request.ontimeout = function handleTimeout() {
                            let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
                            const transitional = _config.transitional || defaults_transitional;
                            if (_config.timeoutErrorMessage) {
                                timeoutErrorMessage = _config.timeoutErrorMessage;
                            }
                            reject(new core_AxiosError(
                                timeoutErrorMessage,
                                transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
                                config,
                                request));

                            // Clean up request
                            request = null;
                        };

                        // Remove Content-Type if data is undefined
                        requestData === undefined && requestHeaders.setContentType(null);

                        // Add headers to the request
                        if ('setRequestHeader' in request) {
                            utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
                                request.setRequestHeader(key, val);
                            });
                        }

                        // Add withCredentials to request if needed
                        if (!utils.isUndefined(_config.withCredentials)) {
                            request.withCredentials = !!_config.withCredentials;
                        }

                        // Add responseType to request if needed
                        if (responseType && responseType !== 'json') {
                            request.responseType = _config.responseType;
                        }

                        // Handle progress if needed
                        if (onDownloadProgress) {
                            ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
                            request.addEventListener('progress', downloadThrottled);
                        }

                        // Not all browsers support upload events
                        if (onUploadProgress && request.upload) {
                            ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

                            request.upload.addEventListener('progress', uploadThrottled);

                            request.upload.addEventListener('loadend', flushUpload);
                        }

                        if (_config.cancelToken || _config.signal) {
                            // Handle cancellation
                            // eslint-disable-next-line func-names
                            onCanceled = cancel => {
                                if (!request) {
                                    return;
                                }
                                reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
                                request.abort();
                                request = null;
                            };

                            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
                            if (_config.signal) {
                                _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
                            }
                        }

                        const protocol = parseProtocol(_config.url);

                        if (protocol && platform.protocols.indexOf(protocol) === -1) {
                            reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
                            return;
                        }


                        // Send the request
                        request.send(requestData || null);
                    });
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/composeSignals.js




                const composeSignals = (signals, timeout) => {
                    const {
                        length
                    } = (signals = signals ? signals.filter(Boolean) : []);

                    if (timeout || length) {
                        let controller = new AbortController();

                        let aborted;

                        const onabort = function(reason) {
                            if (!aborted) {
                                aborted = true;
                                unsubscribe();
                                const err = reason instanceof Error ? reason : this.reason;
                                controller.abort(err instanceof core_AxiosError ? err : new cancel_CanceledError(err instanceof Error ? err.message : err));
                            }
                        }

                        let timer = timeout && setTimeout(() => {
                            timer = null;
                            onabort(new core_AxiosError(`timeout ${timeout} of ms exceeded`, core_AxiosError.ETIMEDOUT))
                        }, timeout)

                        const unsubscribe = () => {
                            if (signals) {
                                timer && clearTimeout(timer);
                                timer = null;
                                signals.forEach(signal => {
                                    signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
                                });
                                signals = null;
                            }
                        }

                        signals.forEach((signal) => signal.addEventListener('abort', onabort));

                        const {
                            signal
                        } = controller;

                        signal.unsubscribe = () => utils.asap(unsubscribe);

                        return signal;
                    }
                }

                /* harmony default export */
                const helpers_composeSignals = (composeSignals);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/trackStream.js

                const streamChunk = function*(chunk, chunkSize) {
                    let len = chunk.byteLength;

                    if (!chunkSize || len < chunkSize) {
                        yield chunk;
                        return;
                    }

                    let pos = 0;
                    let end;

                    while (pos < len) {
                        end = pos + chunkSize;
                        yield chunk.slice(pos, end);
                        pos = end;
                    }
                }

                const readBytes = async function*(iterable, chunkSize) {
                    for await (const chunk of readStream(iterable)) {
                        yield* streamChunk(chunk, chunkSize);
                    }
                }

                const readStream = async function*(stream) {
                    if (stream[Symbol.asyncIterator]) {
                        yield* stream;
                        return;
                    }

                    const reader = stream.getReader();
                    try {
                        for (;;) {
                            const {
                                done,
                                value
                            } = await reader.read();
                            if (done) {
                                break;
                            }
                            yield value;
                        }
                    } finally {
                        await reader.cancel();
                    }
                }

                const trackStream = (stream, chunkSize, onProgress, onFinish) => {
                    const iterator = readBytes(stream, chunkSize);

                    let bytes = 0;
                    let done;
                    let _onFinish = (e) => {
                        if (!done) {
                            done = true;
                            onFinish && onFinish(e);
                        }
                    }

                    return new ReadableStream({
                        async pull(controller) {
                            try {
                                const {
                                    done,
                                    value
                                } = await iterator.next();

                                if (done) {
                                    _onFinish();
                                    controller.close();
                                    return;
                                }

                                let len = value.byteLength;
                                if (onProgress) {
                                    let loadedBytes = bytes += len;
                                    onProgress(loadedBytes);
                                }
                                controller.enqueue(new Uint8Array(value));
                            } catch (err) {
                                _onFinish(err);
                                throw err;
                            }
                        },
                        cancel(reason) {
                            _onFinish(reason);
                            return iterator.return();
                        }
                    }, {
                        highWaterMark: 2
                    })
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/fetch.js










                const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
                const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

                // used only inside the fetch adapter
                const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
                    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
                    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
                );

                const test = (fn, ...args) => {
                    try {
                        return !!fn(...args);
                    } catch (e) {
                        return false
                    }
                }

                const supportsRequestStream = isReadableStreamSupported && test(() => {
                    let duplexAccessed = false;

                    const hasContentType = new Request(platform.origin, {
                        body: new ReadableStream(),
                        method: 'POST',
                        get duplex() {
                            duplexAccessed = true;
                            return 'half';
                        },
                    }).headers.has('Content-Type');

                    return duplexAccessed && !hasContentType;
                });

                const DEFAULT_CHUNK_SIZE = 64 * 1024;

                const supportsResponseStream = isReadableStreamSupported &&
                    test(() => utils.isReadableStream(new Response('').body));


                const resolvers = {
                    stream: supportsResponseStream && ((res) => res.body)
                };

                isFetchSupported && (((res) => {
                    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
                        !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :
                            (_, config) => {
                                throw new core_AxiosError(`Response type '${type}' is not supported`, core_AxiosError.ERR_NOT_SUPPORT, config);
                            })
                    });
                })(new Response));

                const getBodyLength = async (body) => {
                    if (body == null) {
                        return 0;
                    }

                    if (utils.isBlob(body)) {
                        return body.size;
                    }

                    if (utils.isSpecCompliantForm(body)) {
                        const _request = new Request(platform.origin, {
                            method: 'POST',
                            body,
                        });
                        return (await _request.arrayBuffer()).byteLength;
                    }

                    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {
                        return body.byteLength;
                    }

                    if (utils.isURLSearchParams(body)) {
                        body = body + '';
                    }

                    if (utils.isString(body)) {
                        return (await encodeText(body)).byteLength;
                    }
                }

                const resolveBodyLength = async (headers, body) => {
                    const length = utils.toFiniteNumber(headers.getContentLength());

                    return length == null ? getBodyLength(body) : length;
                }

                /* harmony default export */
                const adapters_fetch = (isFetchSupported && (async (config) => {
                    let {
                        url,
                        method,
                        data,
                        signal,
                        cancelToken,
                        timeout,
                        onDownloadProgress,
                        onUploadProgress,
                        responseType,
                        headers,
                        withCredentials = 'same-origin',
                        fetchOptions
                    } = resolveConfig(config);

                    responseType = responseType ? (responseType + '').toLowerCase() : 'text';

                    let composedSignal = helpers_composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

                    let request;

                    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
                        composedSignal.unsubscribe();
                    });

                    let requestContentLength;

                    try {
                        if (
                            onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
                            (requestContentLength = await resolveBodyLength(headers, data)) !== 0
                        ) {
                            let _request = new Request(url, {
                                method: 'POST',
                                body: data,
                                duplex: "half"
                            });

                            let contentTypeHeader;

                            if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
                                headers.setContentType(contentTypeHeader)
                            }

                            if (_request.body) {
                                const [onProgress, flush] = progressEventDecorator(
                                    requestContentLength,
                                    progressEventReducer(asyncDecorator(onUploadProgress))
                                );

                                data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
                            }
                        }

                        if (!utils.isString(withCredentials)) {
                            withCredentials = withCredentials ? 'include' : 'omit';
                        }

                        // Cloudflare Workers throws when credentials are defined
                        // see https://github.com/cloudflare/workerd/issues/902
                        const isCredentialsSupported = "credentials" in Request.prototype;
                        request = new Request(url, {
                            ...fetchOptions,
                            signal: composedSignal,
                            method: method.toUpperCase(),
                            headers: headers.normalize().toJSON(),
                            body: data,
                            duplex: "half",
                            credentials: isCredentialsSupported ? withCredentials : undefined
                        });

                        let response = await fetch(request);

                        const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

                        if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
                            const options = {};

                            ['status', 'statusText', 'headers'].forEach(prop => {
                                options[prop] = response[prop];
                            });

                            const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));

                            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
                                responseContentLength,
                                progressEventReducer(asyncDecorator(onDownloadProgress), true)
                            ) || [];

                            response = new Response(
                                trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                                    flush && flush();
                                    unsubscribe && unsubscribe();
                                }),
                                options
                            );
                        }

                        responseType = responseType || 'text';

                        let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);

                        !isStreamResponse && unsubscribe && unsubscribe();

                        return await new Promise((resolve, reject) => {
                            settle(resolve, reject, {
                                data: responseData,
                                headers: core_AxiosHeaders.from(response.headers),
                                status: response.status,
                                statusText: response.statusText,
                                config,
                                request
                            })
                        })
                    } catch (err) {
                        unsubscribe && unsubscribe();

                        if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
                            throw Object.assign(
                                new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request), {
                                    cause: err.cause || err
                                }
                            )
                        }

                        throw core_AxiosError.from(err, err && err.code, config, request);
                    }
                }));



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/adapters.js






                const knownAdapters = {
                    http: helpers_null,
                    xhr: xhr,
                    fetch: adapters_fetch
                }

                utils.forEach(knownAdapters, (fn, value) => {
                    if (fn) {
                        try {
                            Object.defineProperty(fn, 'name', {
                                value
                            });
                        } catch (e) {
                            // eslint-disable-next-line no-empty
                        }
                        Object.defineProperty(fn, 'adapterName', {
                            value
                        });
                    }
                });

                const renderReason = (reason) => `- ${reason}`;

                const isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;

                /* harmony default export */
                const adapters = ({
                    getAdapter: (adapters) => {
                        adapters = utils.isArray(adapters) ? adapters : [adapters];

                        const {
                            length
                        } = adapters;
                        let nameOrAdapter;
                        let adapter;

                        const rejectedReasons = {};

                        for (let i = 0; i < length; i++) {
                            nameOrAdapter = adapters[i];
                            let id;

                            adapter = nameOrAdapter;

                            if (!isResolvedHandle(nameOrAdapter)) {
                                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

                                if (adapter === undefined) {
                                    throw new core_AxiosError(`Unknown adapter '${id}'`);
                                }
                            }

                            if (adapter) {
                                break;
                            }

                            rejectedReasons[id || '#' + i] = adapter;
                        }

                        if (!adapter) {

                            const reasons = Object.entries(rejectedReasons)
                                .map(([id, state]) => `adapter ${id} ` +
                                    (state === false ? 'is not supported by the environment' : 'is not available in the build')
                                );

                            let s = length ?
                                (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
                                'as no adapter specified';

                            throw new core_AxiosError(
                                `There is no suitable adapter to dispatch the request ` + s,
                                'ERR_NOT_SUPPORT'
                            );
                        }

                        return adapter;
                    },
                    adapters: knownAdapters
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/dispatchRequest.js









                /**
                 * Throws a `CanceledError` if cancellation has been requested.
                 *
                 * @param {Object} config The config that is to be used for the request
                 *
                 * @returns {void}
                 */
                function throwIfCancellationRequested(config) {
                    if (config.cancelToken) {
                        config.cancelToken.throwIfRequested();
                    }

                    if (config.signal && config.signal.aborted) {
                        throw new cancel_CanceledError(null, config);
                    }
                }

                /**
                 * Dispatch a request to the server using the configured adapter.
                 *
                 * @param {object} config The config that is to be used for the request
                 *
                 * @returns {Promise} The Promise to be fulfilled
                 */
                function dispatchRequest(config) {
                    throwIfCancellationRequested(config);

                    config.headers = core_AxiosHeaders.from(config.headers);

                    // Transform request data
                    config.data = transformData.call(
                        config,
                        config.transformRequest
                    );

                    if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
                        config.headers.setContentType('application/x-www-form-urlencoded', false);
                    }

                    const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

                    return adapter(config).then(function onAdapterResolution(response) {
                        throwIfCancellationRequested(config);

                        // Transform response data
                        response.data = transformData.call(
                            config,
                            config.transformResponse,
                            response
                        );

                        response.headers = core_AxiosHeaders.from(response.headers);

                        return response;
                    }, function onAdapterRejection(reason) {
                        if (!isCancel(reason)) {
                            throwIfCancellationRequested(config);

                            // Transform response data
                            if (reason && reason.response) {
                                reason.response.data = transformData.call(
                                    config,
                                    config.transformResponse,
                                    reason.response
                                );
                                reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
                            }
                        }

                        return Promise.reject(reason);
                    });
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/env/data.js
                const VERSION = "1.7.9";; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/validator.js





                const validators = {};

                // eslint-disable-next-line func-names
                ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
                    validators[type] = function validator(thing) {
                        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
                    };
                });

                const deprecatedWarnings = {};

                /**
                 * Transitional option validator
                 *
                 * @param {function|boolean?} validator - set to false if the transitional option has been removed
                 * @param {string?} version - deprecated version / removed since version
                 * @param {string?} message - some message with additional info
                 *
                 * @returns {function}
                 */
                validators.transitional = function transitional(validator, version, message) {
                    function formatMessage(opt, desc) {
                        return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
                    }

                    // eslint-disable-next-line func-names
                    return (value, opt, opts) => {
                        if (validator === false) {
                            throw new core_AxiosError(
                                formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
                                core_AxiosError.ERR_DEPRECATED
                            );
                        }

                        if (version && !deprecatedWarnings[opt]) {
                            deprecatedWarnings[opt] = true;
                            // eslint-disable-next-line no-console
                            console.warn(
                                formatMessage(
                                    opt,
                                    ' has been deprecated since v' + version + ' and will be removed in the near future'
                                )
                            );
                        }

                        return validator ? validator(value, opt, opts) : true;
                    };
                };

                validators.spelling = function spelling(correctSpelling) {
                    return (value, opt) => {
                        // eslint-disable-next-line no-console
                        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
                        return true;
                    }
                };

                /**
                 * Assert object's properties type
                 *
                 * @param {object} options
                 * @param {object} schema
                 * @param {boolean?} allowUnknown
                 *
                 * @returns {object}
                 */

                function assertOptions(options, schema, allowUnknown) {
                    if (typeof options !== 'object') {
                        throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
                    }
                    const keys = Object.keys(options);
                    let i = keys.length;
                    while (i-- > 0) {
                        const opt = keys[i];
                        const validator = schema[opt];
                        if (validator) {
                            const value = options[opt];
                            const result = value === undefined || validator(value, opt, options);
                            if (result !== true) {
                                throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
                            }
                            continue;
                        }
                        if (allowUnknown !== true) {
                            throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
                        }
                    }
                }

                /* harmony default export */
                const validator = ({
                    assertOptions,
                    validators
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/Axios.js











                const Axios_validators = validator.validators;

                /**
                 * Create a new instance of Axios
                 *
                 * @param {Object} instanceConfig The default config for the instance
                 *
                 * @return {Axios} A new instance of Axios
                 */
                class Axios {
                    constructor(instanceConfig) {
                        this.defaults = instanceConfig;
                        this.interceptors = {
                            request: new core_InterceptorManager(),
                            response: new core_InterceptorManager()
                        };
                    }

                    /**
                     * Dispatch a request
                     *
                     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
                     * @param {?Object} config
                     *
                     * @returns {Promise} The Promise to be fulfilled
                     */
                    async request(configOrUrl, config) {
                        try {
                            return await this._request(configOrUrl, config);
                        } catch (err) {
                            if (err instanceof Error) {
                                let dummy = {};

                                Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

                                // slice off the Error: ... line
                                const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
                                try {
                                    if (!err.stack) {
                                        err.stack = stack;
                                        // match without the 2 top stack lines
                                    } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
                                        err.stack += '\n' + stack
                                    }
                                } catch (e) {
                                    // ignore the case where "stack" is an un-writable property
                                }
                            }

                            throw err;
                        }
                    }

                    _request(configOrUrl, config) {
                        /*eslint no-param-reassign:0*/
                        // Allow for axios('example/url'[, config]) a la fetch API
                        if (typeof configOrUrl === 'string') {
                            config = config || {};
                            config.url = configOrUrl;
                        } else {
                            config = configOrUrl || {};
                        }

                        config = mergeConfig(this.defaults, config);

                        const {
                            transitional,
                            paramsSerializer,
                            headers
                        } = config;

                        if (transitional !== undefined) {
                            validator.assertOptions(transitional, {
                                silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
                                forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
                                clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
                            }, false);
                        }

                        if (paramsSerializer != null) {
                            if (utils.isFunction(paramsSerializer)) {
                                config.paramsSerializer = {
                                    serialize: paramsSerializer
                                }
                            } else {
                                validator.assertOptions(paramsSerializer, {
                                    encode: Axios_validators.function,
                                    serialize: Axios_validators.function
                                }, true);
                            }
                        }

                        validator.assertOptions(config, {
                            baseUrl: Axios_validators.spelling('baseURL'),
                            withXsrfToken: Axios_validators.spelling('withXSRFToken')
                        }, true);

                        // Set config.method
                        config.method = (config.method || this.defaults.method || 'get').toLowerCase();

                        // Flatten headers
                        let contextHeaders = headers && utils.merge(
                            headers.common,
                            headers[config.method]
                        );

                        headers && utils.forEach(
                            ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
                            (method) => {
                                delete headers[method];
                            }
                        );

                        config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

                        // filter out skipped interceptors
                        const requestInterceptorChain = [];
                        let synchronousRequestInterceptors = true;
                        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                            if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
                                return;
                            }

                            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

                            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
                        });

                        const responseInterceptorChain = [];
                        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
                        });

                        let promise;
                        let i = 0;
                        let len;

                        if (!synchronousRequestInterceptors) {
                            const chain = [dispatchRequest.bind(this), undefined];
                            chain.unshift.apply(chain, requestInterceptorChain);
                            chain.push.apply(chain, responseInterceptorChain);
                            len = chain.length;

                            promise = Promise.resolve(config);

                            while (i < len) {
                                promise = promise.then(chain[i++], chain[i++]);
                            }

                            return promise;
                        }

                        len = requestInterceptorChain.length;

                        let newConfig = config;

                        i = 0;

                        while (i < len) {
                            const onFulfilled = requestInterceptorChain[i++];
                            const onRejected = requestInterceptorChain[i++];
                            try {
                                newConfig = onFulfilled(newConfig);
                            } catch (error) {
                                onRejected.call(this, error);
                                break;
                            }
                        }

                        try {
                            promise = dispatchRequest.call(this, newConfig);
                        } catch (error) {
                            return Promise.reject(error);
                        }

                        i = 0;
                        len = responseInterceptorChain.length;

                        while (i < len) {
                            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
                        }

                        return promise;
                    }

                    getUri(config) {
                        config = mergeConfig(this.defaults, config);
                        const fullPath = buildFullPath(config.baseURL, config.url);
                        return buildURL(fullPath, config.params, config.paramsSerializer);
                    }
                }

                // Provide aliases for supported request methods
                utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
                    /*eslint func-names:0*/
                    Axios.prototype[method] = function(url, config) {
                        return this.request(mergeConfig(config || {}, {
                            method,
                            url,
                            data: (config || {}).data
                        }));
                    };
                });

                utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
                    /*eslint func-names:0*/

                    function generateHTTPMethod(isForm) {
                        return function httpMethod(url, data, config) {
                            return this.request(mergeConfig(config || {}, {
                                method,
                                headers: isForm ? {
                                    'Content-Type': 'multipart/form-data'
                                } : {},
                                url,
                                data
                            }));
                        };
                    }

                    Axios.prototype[method] = generateHTTPMethod();

                    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
                });

                /* harmony default export */
                const core_Axios = (Axios);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/cancel/CancelToken.js




                /**
                 * A `CancelToken` is an object that can be used to request cancellation of an operation.
                 *
                 * @param {Function} executor The executor function.
                 *
                 * @returns {CancelToken}
                 */
                class CancelToken {
                    constructor(executor) {
                        if (typeof executor !== 'function') {
                            throw new TypeError('executor must be a function.');
                        }

                        let resolvePromise;

                        this.promise = new Promise(function promiseExecutor(resolve) {
                            resolvePromise = resolve;
                        });

                        const token = this;

                        // eslint-disable-next-line func-names
                        this.promise.then(cancel => {
                            if (!token._listeners) return;

                            let i = token._listeners.length;

                            while (i-- > 0) {
                                token._listeners[i](cancel);
                            }
                            token._listeners = null;
                        });

                        // eslint-disable-next-line func-names
                        this.promise.then = onfulfilled => {
                            let _resolve;
                            // eslint-disable-next-line func-names
                            const promise = new Promise(resolve => {
                                token.subscribe(resolve);
                                _resolve = resolve;
                            }).then(onfulfilled);

                            promise.cancel = function reject() {
                                token.unsubscribe(_resolve);
                            };

                            return promise;
                        };

                        executor(function cancel(message, config, request) {
                            if (token.reason) {
                                // Cancellation has already been requested
                                return;
                            }

                            token.reason = new cancel_CanceledError(message, config, request);
                            resolvePromise(token.reason);
                        });
                    }

                    /**
                     * Throws a `CanceledError` if cancellation has been requested.
                     */
                    throwIfRequested() {
                        if (this.reason) {
                            throw this.reason;
                        }
                    }

                    /**
                     * Subscribe to the cancel signal
                     */

                    subscribe(listener) {
                        if (this.reason) {
                            listener(this.reason);
                            return;
                        }

                        if (this._listeners) {
                            this._listeners.push(listener);
                        } else {
                            this._listeners = [listener];
                        }
                    }

                    /**
                     * Unsubscribe from the cancel signal
                     */

                    unsubscribe(listener) {
                        if (!this._listeners) {
                            return;
                        }
                        const index = this._listeners.indexOf(listener);
                        if (index !== -1) {
                            this._listeners.splice(index, 1);
                        }
                    }

                    toAbortSignal() {
                        const controller = new AbortController();

                        const abort = (err) => {
                            controller.abort(err);
                        };

                        this.subscribe(abort);

                        controller.signal.unsubscribe = () => this.unsubscribe(abort);

                        return controller.signal;
                    }

                    /**
                     * Returns an object that contains a new `CancelToken` and a function that, when called,
                     * cancels the `CancelToken`.
                     */
                    static source() {
                        let cancel;
                        const token = new CancelToken(function executor(c) {
                            cancel = c;
                        });
                        return {
                            token,
                            cancel
                        };
                    }
                }

                /* harmony default export */
                const cancel_CancelToken = (CancelToken);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/spread.js


                /**
                 * Syntactic sugar for invoking a function and expanding an array for arguments.
                 *
                 * Common use case would be to use `Function.prototype.apply`.
                 *
                 *  ```js
                 *  function f(x, y, z) {}
                 *  var args = [1, 2, 3];
                 *  f.apply(null, args);
                 *  ```
                 *
                 * With `spread` this example can be re-written.
                 *
                 *  ```js
                 *  spread(function(x, y, z) {})([1, 2, 3]);
                 *  ```
                 *
                 * @param {Function} callback
                 *
                 * @returns {Function}
                 */
                function spread(callback) {
                    return function wrap(arr) {
                        return callback.apply(null, arr);
                    };
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/isAxiosError.js




                /**
                 * Determines whether the payload is an error thrown by Axios
                 *
                 * @param {*} payload The value to test
                 *
                 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
                 */
                function isAxiosError(payload) {
                    return utils.isObject(payload) && (payload.isAxiosError === true);
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/HttpStatusCode.js
                const HttpStatusCode = {
                    Continue: 100,
                    SwitchingProtocols: 101,
                    Processing: 102,
                    EarlyHints: 103,
                    Ok: 200,
                    Created: 201,
                    Accepted: 202,
                    NonAuthoritativeInformation: 203,
                    NoContent: 204,
                    ResetContent: 205,
                    PartialContent: 206,
                    MultiStatus: 207,
                    AlreadyReported: 208,
                    ImUsed: 226,
                    MultipleChoices: 300,
                    MovedPermanently: 301,
                    Found: 302,
                    SeeOther: 303,
                    NotModified: 304,
                    UseProxy: 305,
                    Unused: 306,
                    TemporaryRedirect: 307,
                    PermanentRedirect: 308,
                    BadRequest: 400,
                    Unauthorized: 401,
                    PaymentRequired: 402,
                    Forbidden: 403,
                    NotFound: 404,
                    MethodNotAllowed: 405,
                    NotAcceptable: 406,
                    ProxyAuthenticationRequired: 407,
                    RequestTimeout: 408,
                    Conflict: 409,
                    Gone: 410,
                    LengthRequired: 411,
                    PreconditionFailed: 412,
                    PayloadTooLarge: 413,
                    UriTooLong: 414,
                    UnsupportedMediaType: 415,
                    RangeNotSatisfiable: 416,
                    ExpectationFailed: 417,
                    ImATeapot: 418,
                    MisdirectedRequest: 421,
                    UnprocessableEntity: 422,
                    Locked: 423,
                    FailedDependency: 424,
                    TooEarly: 425,
                    UpgradeRequired: 426,
                    PreconditionRequired: 428,
                    TooManyRequests: 429,
                    RequestHeaderFieldsTooLarge: 431,
                    UnavailableForLegalReasons: 451,
                    InternalServerError: 500,
                    NotImplemented: 501,
                    BadGateway: 502,
                    ServiceUnavailable: 503,
                    GatewayTimeout: 504,
                    HttpVersionNotSupported: 505,
                    VariantAlsoNegotiates: 506,
                    InsufficientStorage: 507,
                    LoopDetected: 508,
                    NotExtended: 510,
                    NetworkAuthenticationRequired: 511,
                };

                Object.entries(HttpStatusCode).forEach(([key, value]) => {
                    HttpStatusCode[value] = key;
                });

                /* harmony default export */
                const helpers_HttpStatusCode = (HttpStatusCode);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/axios.js




















                /**
                 * Create an instance of Axios
                 *
                 * @param {Object} defaultConfig The default config for the instance
                 *
                 * @returns {Axios} A new instance of Axios
                 */
                function createInstance(defaultConfig) {
                    const context = new core_Axios(defaultConfig);
                    const instance = bind(core_Axios.prototype.request, context);

                    // Copy axios.prototype to instance
                    utils.extend(instance, core_Axios.prototype, context, {
                        allOwnKeys: true
                    });

                    // Copy context to instance
                    utils.extend(instance, context, null, {
                        allOwnKeys: true
                    });

                    // Factory for creating new instances
                    instance.create = function create(instanceConfig) {
                        return createInstance(mergeConfig(defaultConfig, instanceConfig));
                    };

                    return instance;
                }

                // Create the default instance to be exported
                const axios = createInstance(lib_defaults);

                // Expose Axios class to allow class inheritance
                axios.Axios = core_Axios;

                // Expose Cancel & CancelToken
                axios.CanceledError = cancel_CanceledError;
                axios.CancelToken = cancel_CancelToken;
                axios.isCancel = isCancel;
                axios.VERSION = VERSION;
                axios.toFormData = helpers_toFormData;

                // Expose AxiosError class
                axios.AxiosError = core_AxiosError;

                // alias for CanceledError for backward compatibility
                axios.Cancel = axios.CanceledError;

                // Expose all/spread
                axios.all = function all(promises) {
                    return Promise.all(promises);
                };

                axios.spread = spread;

                // Expose isAxiosError
                axios.isAxiosError = isAxiosError;

                // Expose mergeConfig
                axios.mergeConfig = mergeConfig;

                axios.AxiosHeaders = core_AxiosHeaders;

                axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

                axios.getAdapter = adapters.getAdapter;

                axios.HttpStatusCode = helpers_HttpStatusCode;

                axios.default = axios;

                // this module should only have a default export
                /* harmony default export */
                const lib_axios = (axios);

                // EXTERNAL MODULE: ./src/constants/index.ts + 1 modules
                var constants = __webpack_require__("CW2u");; // CONCATENATED MODULE: ./src/apis/ajax.ts


                var ajax = lib_axios.create({
                    baseURL: constants /* API_HOST */ .H
                });
                ajax.interceptors.response.use(function(res) {
                    return res;
                }, function(error) {
                    throw error;
                });
                /* harmony default export */
                const apis_ajax = (ajax);

                ; // CONCATENATED MODULE: ./src/apis/index.ts



                var fetchNetworkList$ = function() {
                    var _ref = (0, _async_to_generator /* default */ .Z)(external_regeneratorRuntime_default().mark(function _callee() {
                        var data;
                        return external_regeneratorRuntime_default().wrap(function _callee$(_ctx) {
                            while (1) switch (_ctx.prev = _ctx.next) {
                                case 0:
                                    _ctx.next = 2;
                                    return apis_ajax.get("bapi/defi/v1/public/wallet-direct/buw/networks").then(function(res) {
                                        return res.data;
                                    });
                                case 2:
                                    data = _ctx.sent.data;
                                    return _ctx.abrupt("return", data.filter(function(item) {
                                        return item.activeStatus === "ACTIVE" || item.seedPhraseActiveStatus === "ACTIVE";
                                    }));
                                case 4:
                                case "end":
                                    return _ctx.stop();
                            }
                        }, _callee);
                    }));
                    return function fetchNetworkList$() {
                        return _ref.apply(this, arguments);
                    };
                }();
                var fetchDappList$ = function() {
                    var _ref = (0, _async_to_generator /* default */ .Z)(external_regeneratorRuntime_default().mark(function _callee() {
                        var data;
                        return external_regeneratorRuntime_default().wrap(function _callee$(_ctx) {
                            while (1) switch (_ctx.prev = _ctx.next) {
                                case 0:
                                    _ctx.next = 2;
                                    return apis_ajax.get("/bapi/defi/v1/public/wallet-direct/buw/dapp/info/list?page=1&rows=100").then(function(res) {
                                        return res.data;
                                    });
                                case 2:
                                    data = _ctx.sent.data;
                                    return _ctx.abrupt("return", data);
                                case 4:
                                case "end":
                                    return _ctx.stop();
                            }
                        }, _callee);
                    }));
                    return function fetchDappList$() {
                        return _ref.apply(this, arguments);
                    };
                }();
                var fetchEarnList$ = function() {
                    var _ref = (0, _async_to_generator /* default */ .Z)(external_regeneratorRuntime_default().mark(function _callee() {
                        var data;
                        return external_regeneratorRuntime_default().wrap(function _callee$(_ctx) {
                            while (1) switch (_ctx.prev = _ctx.next) {
                                case 0:
                                    _ctx.next = 2;
                                    return apis_ajax.get("/bapi/defi/v1/public/wallet-direct/buw/earn/list").then(function(res) {
                                        return res.data;
                                    });
                                case 2:
                                    data = _ctx.sent.data;
                                    return _ctx.abrupt("return", data);
                                case 4:
                                case "end":
                                    return _ctx.stop();
                            }
                        }, _callee);
                    }));
                    return function fetchEarnList$() {
                        return _ref.apply(this, arguments);
                    };
                }();


                /***/
            }),

        /***/
        "uBHB":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "z": () => ( /* binding */ Button)
                    /* harmony export */
                });
                /* harmony import */
                var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("ys0/");
                /* harmony import */
                var _swc_helpers_src_object_spread_props_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("L2LL");
                /* harmony import */
                var _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("Cmqe");
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("w7fa");
                /* harmony import */
                var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);





                var Button = function(_param) {
                    var children = _param.children,
                        onClick = _param.onClick,
                        disabled = _param.disabled,
                        className = _param.className,
                        props = (0, _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_2__ /* ["default"] */ .Z)(_param, [
                            "children",
                            "onClick",
                            "disabled",
                            "className"
                        ]);
                    var handleClick = function(e) {
                        if (disabled) return;
                        if (onClick) onClick(e);
                    };
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", (0, _swc_helpers_src_object_spread_props_mjs__WEBPACK_IMPORTED_MODULE_3__ /* ["default"] */ .Z)((0, _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_4__ /* ["default"] */ .Z)({
                        onClick: handleClick,
                        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()("\n        subtitle-2-1 lg:subtitle-3 flex h-12 w-full items-center justify-center rounded-[8px] md:w-[180px] lg:w-[180px]\n      ".concat(disabled ? "line t-disabled cursor-not-allowed" : "cursor-pointer bg-yellow1 text-black1", "\n    "), className)
                    }, props), {
                        children: children
                    }));
                };


                /***/
            }),

        /***/
        "rz+5":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "X": () => ( /* binding */ MPCModal)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DTvD");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CgVz");
                /* harmony import */
                var _Modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("8Qrv");




                var MPCModal = function(param) {
                    var visible = param.visible,
                        onClose = param.onClose;
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__ /* .useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Modal__WEBPACK_IMPORTED_MODULE_3__ /* .Modal */ .u, {
                        visible: visible,
                        onClose: onClose,
                        title: t("multi-party-computation", {
                            defaultValue: "Multi-Party Computation (MPC)"
                        }),
                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                            className: "body-3 t-secondary mt-6",
                            children: [
                                /*#__PURE__*/
                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                    children: t("mpc-modal-text-1", {
                                        defaultValue: "Binance Web3 Wallet uses advanced multi-party computation (MPC) technology. This means you can enjoy a self-custody wallet experience without the need for a seed phrase. MPC allows the creation of a secure key management system without a single point of failure. For a standard wallet this would be losing your seed phrase."
                                    })
                                }),
                                /*#__PURE__*/
                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                    className: "my-4",
                                    children: t("mpc-modal-text-2", {
                                        defaultValue: "Instead, Binance Web3 Wallet is secured by three key-shares and a recovery password solely known to the user. These key-shares are generated when you create the wallet and stored in different locations for added security:"
                                    })
                                }),
                                /*#__PURE__*/
                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("ul", {
                                    className: "mb-4 list-disc pl-[14px]",
                                    children: [
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", {
                                            children: t("mpc-modal-text-3-1", {
                                                defaultValue: "Share 1: Secured by Binance;"
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", {
                                            children: t("mpc-modal-text-3-2", {
                                                defaultValue: "Share 2: Stored on your device;"
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", {
                                            children: t("mpc-modal-text-3-3", {
                                                defaultValue: "Share 3: Encrypted by the recovery password you entered, and backed up to your personal cloud storage (iCloud or Google Drive)."
                                            })
                                        })
                                    ]
                                }),
                                /*#__PURE__*/
                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                    children: t("mpc-modal-text-4", {
                                        defaultValue: "To access your wallet, you must have at least two key-shares."
                                    })
                                })
                            ]
                        })
                    });
                };


                /***/
            }),

        /***/
        "8Qrv":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "u": () => ( /* binding */ Modal)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DTvD");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
                /* harmony import */
                var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("w7fa");
                /* harmony import */
                var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);
                /* harmony import */
                var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("CW2u");




                var Modal = function(param) {
                    var visible = param.visible,
                        onClose = param.onClose,
                        children = param.children,
                        contentCls = param.contentCls,
                        title = param.title,
                        titleCls = param.titleCls;
                    var ref = (0, react__WEBPACK_IMPORTED_MODULE_1__.useState)(true),
                        modalHide = ref[0],
                        setModalHide = ref[1];
                    var ref1 = (0, react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
                        modalshow = ref1[0],
                        setModalShow = ref1[1];
                    var handleClose = function() {
                        onClose && onClose();
                    };
                    (0, react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {
                        if (visible) {
                            setModalHide(false);
                            setTimeout(function() {
                                setModalShow(true);
                                document.body.style.overflow = "hidden";
                            }, 20);
                        } else {
                            setModalShow(false);
                            setTimeout(function() {
                                document.body.style.overflow = "auto";
                                setModalHide(true);
                            }, 220);
                        }
                    }, [
                        visible
                    ]);
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                        className: classnames__WEBPACK_IMPORTED_MODULE_2___default()("modal-base fixed bottom-0 left-0 right-0 top-0 z-50 flex items-center justify-center", "".concat(modalshow ? "modal-show" : "modal-fade"), "".concat(modalHide ? "hidden" : "")),
                        children: [
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                className: "absolute h-full w-full bg-black opacity-40"
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                className: classnames__WEBPACK_IMPORTED_MODULE_2___default()("bg-1 modal-content relative z-10 h-full w-full px-6 py-5 md:h-auto md:rounded-[8px] md:w-[473px] lg:p-10 sm:pt-8", contentCls),
                                children: [
                                    /*#__PURE__*/
                                    (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                        className: "flex items-center justify-between lg:items-baseline",
                                        children: [
                                            /*#__PURE__*/
                                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", {
                                                className: classnames__WEBPACK_IMPORTED_MODULE_2___default()("subtitle-1", titleCls),
                                                children: title
                                            }),
                                            /*#__PURE__*/
                                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
                                                src: "".concat(_constants__WEBPACK_IMPORTED_MODULE_3__ /* .IMG_URL */ .bV, "/close-f.svg"),
                                                className: "absolute right-6 top-6 h-6 w-6 cursor-pointer",
                                                onClick: handleClose
                                            })
                                        ]
                                    }),
                                    children
                                ]
                            })
                        ]
                    });
                };


                /***/
            }),

        /***/
        "ZGwD":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "B": () => ( /* binding */ NetworkModal)
                    /* harmony export */
                });
                /* harmony import */
                var _swc_helpers_src_sliced_to_array_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("/++K");
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DTvD");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CgVz");
                /* harmony import */
                var _constants_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("n2Te");
                /* harmony import */
                var _Modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("8Qrv");






                var showShowMore = function(id) {
                    return id === 8 || id === 5;
                };
                var NetworkModal = function(param) {
                    var visible = param.visible,
                        onClose = param.onClose,
                        _data = (0, _swc_helpers_src_sliced_to_array_mjs__WEBPACK_IMPORTED_MODULE_5__ /* ["default"] */ .Z)(param.data, 2),
                        networks = _data[0],
                        dapps = _data[1];
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__ /* .useTranslation */ .$G)();
                    var t2 = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__ /* .useTranslation */ .$G)("");
                    var ref = (0, react__WEBPACK_IMPORTED_MODULE_1__.useState)(0),
                        selectedTab = ref[0],
                        setSelectedTab = ref[1];
                    var showMore = function(id) {
                        var // Show all
                            ref, // Hide view more
                            ref1;
                        (ref = document.querySelector(".dapp-desc-".concat(id))) === null || ref === void 0 ? void 0 : ref.classList.remove("three-line-ellipsis");
                        (ref1 = document.querySelector(".dapp-view-more-".concat(id))) === null || ref1 === void 0 ? void 0 : ref1.classList.add("hidden");
                    };
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Modal__WEBPACK_IMPORTED_MODULE_4__ /* .Modal */ .u, {
                        contentCls: "w-[475px] max-h-full md:max-h-[560px] flex flex-col overflow-hidden",
                        visible: visible,
                        onClose: onClose,
                        title: t("support-networks-and-dapps", {
                            defaultValue: "Support networks and dApps"
                        }),
                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                            className: "mb-[-40px] flex flex-col overflow-hidden",
                            children: [
                                /*#__PURE__*/
                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                    className: "bg-3 subtitle-4 my-6 grid flex-shrink-0 grid-cols-2 gap-x-[2px] overflow-hidden rounded p-[2px]",
                                    children: [
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "flex h-[30px] cursor-pointer items-center justify-center rounded-[3px] ".concat(selectedTab === 0 ? "bg-1" : "bg-3 t-secondary"),
                                            onClick: function() {
                                                return setSelectedTab(0);
                                            },
                                            children: t("networks", {
                                                defaultValue: "Networks"
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "flex h-[30px] cursor-pointer items-center justify-center rounded-[3px] ".concat(selectedTab === 1 ? "bg-1 t-secondary" : "bg-3"),
                                            onClick: function() {
                                                return setSelectedTab(1);
                                            },
                                            children: t("dapps", {
                                                defaultValue: "dApps"
                                            })
                                        })
                                    ]
                                }),
                                /*#__PURE__*/
                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                    className: "modal-content-scroll flex overflow-hidden pb-6",
                                    children: [
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "scrollbar-hide grid w-full flex-shrink-0 grid-cols-2 overflow-y-scroll ".concat(selectedTab === 0 ? "" : "hidden"),
                                            children: networks.map(function(param) {
                                                var networkId = param.networkId,
                                                    name = param.name;
                                                return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                                    className: "flex items-center gap-x-[16px] py-2",
                                                    children: [
                                                        /*#__PURE__*/
                                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
                                                            className: "h-[40px] w-[40px] rounded-full",
                                                            src: "".concat(_constants_config__WEBPACK_IMPORTED_MODULE_3__ /* .STATIC_HOST */ .Xs, "/static/buw/icons/").concat(networkId.toLowerCase().replace("_", "-"), ".svg")
                                                        }),
                                                        /*#__PURE__*/
                                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", {
                                                            className: "subtitle-4",
                                                            children: name
                                                        })
                                                    ]
                                                });
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "scrollbar-hide w-full flex-shrink-0 overflow-y-scroll ".concat(selectedTab === 1 ? "" : "hidden"),
                                            children: dapps.map(function(param) {
                                                var name = param.name,
                                                    logo = param.logo,
                                                    desc = param.desc,
                                                    descKey = param.descKey,
                                                    id = param.id;
                                                return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                                    className: "flex gap-x-[16px] py-[16px]",
                                                    children: [
                                                        /*#__PURE__*/
                                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
                                                            className: "mr-[16px] h-[40px] w-[40px] flex-shrink-0 rounded-full",
                                                            src: logo
                                                        }),
                                                        /*#__PURE__*/
                                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                                            className: "flex flex-col",
                                                            children: [
                                                                /*#__PURE__*/
                                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", {
                                                                    className: "subtitle-4 t-primary",
                                                                    children: name
                                                                }),
                                                                /*#__PURE__*/
                                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                                    className: "dapp-desc-".concat(id, " caption-2 t-secondary three-line-ellipsis"),
                                                                    children: t2(descKey, {
                                                                        defaultValue: desc
                                                                    })
                                                                }),
                                                                showShowMore(id) && /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                                    onClick: function() {
                                                                        return showMore(id);
                                                                    },
                                                                    className: "caption-1 t-brand cursor-pointer dapp-view-more-".concat(id),
                                                                    children: t2("wmp-view-more")
                                                                })
                                                            ]
                                                        })
                                                    ]
                                                });
                                            })
                                        })
                                    ]
                                })
                            ]
                        })
                    });
                };


                /***/
            }),

        /***/
        "xYZv":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "T": () => ( /* binding */ QRcodeModal)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread.mjs
                var _object_spread = __webpack_require__("ys0/");
                // EXTERNAL MODULE: ./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
                var jsx_runtime = __webpack_require__("oUqw");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");
                // EXTERNAL MODULE: ./node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js
                var browser = __webpack_require__("ozD+");
                // EXTERNAL MODULE: ./src/constants/index.ts + 1 modules
                var constants = __webpack_require__("CW2u");
                // EXTERNAL MODULE: ./src/hooks/index.ts + 4 modules
                var hooks = __webpack_require__("CgVz");
                // EXTERNAL MODULE: ./src/components/Modal.tsx
                var Modal = __webpack_require__("8Qrv");
                // EXTERNAL MODULE: ./src/hooks/useLng.ts
                var useLng = __webpack_require__("Vo9m");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread_props.mjs
                var _object_spread_props = __webpack_require__("L2LL");; // CONCATENATED MODULE: ./src/icons/Apple.tsx



                var Apple = function(props) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("svg", (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                        width: "24",
                        height: "24",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg"
                    }, props), {
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                            d: "M21.7732 18.7033C21.407 19.5418 20.9734 20.3136 20.4711 21.0232C19.7864 21.9906 19.2258 22.6602 18.7938 23.032C18.1241 23.6424 17.4065 23.955 16.6381 23.9728C16.0865 23.9728 15.4212 23.8172 14.6468 23.5017C13.8699 23.1876 13.1559 23.032 12.5031 23.032C11.8184 23.032 11.0841 23.1876 10.2986 23.5017C9.512 23.8172 8.87829 23.9816 8.39378 23.9979C7.65692 24.0291 6.92246 23.7076 6.18934 23.032C5.72142 22.6276 5.13615 21.9343 4.43502 20.9521C3.68277 19.9033 3.06431 18.687 2.5798 17.3004C2.0609 15.8026 1.80078 14.3523 1.80078 12.9482C1.80078 11.3398 2.1515 9.95259 2.85397 8.79011C3.40605 7.85636 4.14052 7.11979 5.05976 6.57906C5.979 6.03834 6.97224 5.76279 8.04187 5.74516C8.62714 5.74516 9.39465 5.92456 10.3484 6.27715C11.2995 6.63091 11.9102 6.81032 12.1779 6.81032C12.3781 6.81032 13.0565 6.60054 14.2066 6.18233C15.2941 5.79449 16.212 5.63391 16.964 5.69716C19.0016 5.86012 20.5324 6.6561 21.5505 8.09013C19.7281 9.18432 18.8267 10.7169 18.8446 12.6829C18.8611 14.2142 19.4217 15.4886 20.5235 16.5004C21.0228 16.97 21.5804 17.333 22.2008 17.5907C22.0662 17.9774 21.9242 18.3477 21.7732 18.7033ZM17.1 0.480137C17.1 1.68041 16.6575 2.8011 15.7755 3.8384C14.7111 5.07155 13.4237 5.78412 12.0275 5.67168C12.0098 5.52769 11.9994 5.37614 11.9994 5.21688C11.9994 4.06462 12.5056 2.83147 13.4045 1.82321C13.8533 1.3127 14.4241 0.888228 15.1162 0.549615C15.8069 0.216055 16.4602 0.031589 17.0746 0C17.0926 0.160458 17.1 0.320926 17.1 0.480121V0.480137Z",
                            fill: "currentColor"
                        })
                    }));
                };

                ; // CONCATENATED MODULE: ./src/icons/Google.tsx



                var GPlay = function(props) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("svg", (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                        width: "24",
                        height: "24",
                        viewBox: "0 0 24 24",
                        fill: "currentColor",
                        xmlns: "http://www.w3.org/2000/svg"
                    }, props), {
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("path", {
                                d: "M12.0313 11.4375L2.09375 22.0313C2.375 23.1563 3.40625 24 4.71875 24C5.1875 24 5.65625 23.9063 6.125 23.625L17.375 17.1563L12.0313 11.4375Z",
                                fill: "#EA4335"
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("path", {
                                d: "M22.1563 9.65625L17.2812 6.84375L11.8438 11.7188L17.2812 17.1563L22.0625 14.3438C22.9063 13.875 23.4688 13.0313 23.4688 12C23.5625 10.9688 23 10.125 22.1563 9.65625Z",
                                fill: "#FBBC04"
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("path", {
                                d: "M2.09375 1.96875C2 2.15625 2 2.4375 2 2.625V21.375C2 21.6563 2 21.8438 2.09375 22.0313L12.4063 11.7188L2.09375 1.96875Z",
                                fill: "#4285F4"
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("path", {
                                d: "M12.125 12L17.2813 6.84375L6.03125 0.375C5.65625 0.0937496 5.1875 0 4.625 0C3.40625 0 2.28125 0.843749 2 1.96875L12.125 12Z",
                                fill: "#34A853"
                            })
                        ]
                    }));
                };

                ; // CONCATENATED MODULE: ./src/components/QRcodeModal.tsx










                var QRcodeModal = function(param) {
                    var visible = param.visible,
                        onClose = param.onClose;
                    var qrcode = (0, external_React_.useRef)(null);
                    var t = (0, hooks /* useTranslation */ .$G)();
                    var lng = (0, useLng /* useLng */ .t)();
                    (0, external_React_.useEffect)(function() {
                        browser.toDataURL((0, constants /* getQrocdeLink */ .jl)(lng), {
                            errorCorrectionLevel: "H",
                            type: "image/jpeg",
                            quality: 1,
                            margin: 1
                        }, function(_, url) {
                            var img = qrcode.current;
                            if (img) img.src = url;
                        });
                    }, []);
                    var downloadList = [{
                            title: t("ios-download", {
                                defaultValue: "Download for iOS"
                            }),
                            desc: t("ios-download-desc", {
                                defaultValue: "Get the Binance app from the App Store"
                            }),
                            img: /*#__PURE__*/ (0, jsx_runtime.jsx)(Apple, {}),
                            link: constants /* DOWNLOAD_URLS.appleStore */ .FU.appleStore
                        },
                        {
                            title: t("android-download", {
                                defaultValue: "Download for Android"
                            }),
                            desc: t("android-download-desc", {
                                defaultValue: "Get the Binance app from Google Play"
                            }),
                            img: /*#__PURE__*/ (0, jsx_runtime.jsx)(GPlay, {}),
                            link: constants /* DOWNLOAD_URLS.googlePlay */ .FU.googlePlay
                        },
                    ];
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(Modal /* Modal */ .u, {
                        contentCls: "md:!w-[400px]",
                        titleCls: "md:w-[203px]",
                        visible: visible,
                        onClose: onClose,
                        title: t("qrcode-title", {
                            defaultValue: "Get Web3 Wallet with the Binance app"
                        }),
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                className: "flex justify-center py-6 lg:pb-[30px] lg:pt-[34px]",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)("img", {
                                    className: "h-[200px] w-[200px]",
                                    ref: qrcode,
                                    alt: "qrcode"
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                className: "grid gap-y-2",
                                children: downloadList.map(function(item, index) {
                                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(DownloadItem, (0, _object_spread /* default */ .Z)({}, item), index);
                                })
                            })
                        ]
                    });
                };

                function DownloadItem(param) {
                    var img = param.img,
                        title = param.title,
                        desc = param.desc,
                        link = param.link;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("a", {
                        href: link,
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                            className: "hover:bg-selected light-line-border rounded-lg border px-5 py-4 hover:cursor-pointer",
                            children: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                className: "flex items-center",
                                children: [
                                    img,
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        className: "ml-4",
                                        children: [
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "subtitle-4",
                                                children: title
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "caption-2 t-secondary",
                                                children: desc
                                            })
                                        ]
                                    })
                                ]
                            })
                        })
                    });
                }


                /***/
            }),

        /***/
        "AdcS":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "p": () => ( /* binding */ Seo)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DTvD");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
                /* harmony import */
                var _shuvi_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("tcj6");
                /* harmony import */
                var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CW2u");




                var Seo = function(param) {
                    var metaData = param.metaData;
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_shuvi_runtime__WEBPACK_IMPORTED_MODULE_3__ /* ["default"] */ .Z, {
                        children: [
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("title", {
                                children: metaData.title
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                name: "keywords",
                                content: metaData === null || metaData === void 0 ? void 0 : metaData.keywords
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                name: "description",
                                content: metaData.description
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "og:type",
                                content: "website"
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "og:title",
                                content: metaData.title
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "og:site_name",
                                content: _constants__WEBPACK_IMPORTED_MODULE_2__ /* .BRAND */ .cg
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "og:image",
                                content: _constants__WEBPACK_IMPORTED_MODULE_2__ /* .OG_IMAGE */ .Ez
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "twitter:title",
                                content: metaData.title
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "twitter:site",
                                content: _constants__WEBPACK_IMPORTED_MODULE_2__ /* .BRAND */ .cg
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "twitter:image",
                                content: _constants__WEBPACK_IMPORTED_MODULE_2__ /* .OG_IMAGE */ .Ez
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "twitter:image:src",
                                content: _constants__WEBPACK_IMPORTED_MODULE_2__ /* .OG_IMAGE */ .Ez
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                property: "twitter:card",
                                content: "summary_large_image"
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                name: "apple-mobile-web-app-status-bar-style",
                                content: "black"
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                name: "apple-mobile-web-app-capable",
                                content: "yes"
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                name: "format-detection",
                                content: "telephone=no"
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("meta", {
                                name: "format-detection",
                                content: "email=no"
                            })
                        ]
                    });
                };


                /***/
            }),

        /***/
        "ZMxh":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "n": () => ( /* binding */ Video)
                    /* harmony export */
                });
                /* harmony import */
                var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ys0/");
                /* harmony import */
                var _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Cmqe");
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");



                function Video(_param) {
                    var style = _param.style,
                        props = (0, _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_1__ /* ["default"] */ .Z)(_param, [
                            "style"
                        ]);
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("video", (0, _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_2__ /* ["default"] */ .Z)({
                        style: (0, _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_2__ /* ["default"] */ .Z)({
                            background: "transparent",
                            aspectRatio: "auto",
                            // outline: props.outline ?? 'white auto 1px',
                            clipPath: "inset(1px)"
                        }, style),
                        autoPlay: true,
                        loop: true,
                        muted: true,
                        playsInline: true
                    }, props));
                }


                /***/
            }),

        /***/
        "CW2u":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "H": () => ( /* reexport */ config /* API_HOST */ .H),
                    "cg": () => ( /* reexport */ config /* BRAND */ .cg),
                    "FU": () => ( /* reexport */ DOWNLOAD_URLS),
                    "bV": () => ( /* reexport */ config /* IMG_URL */ .bV),
                    "Ez": () => ( /* reexport */ config /* OG_IMAGE */ .Ez),
                    "yB": () => ( /* reexport */ config /* SENSORS_SERVER_HOST */ .yB),
                    "Xs": () => ( /* reexport */ config /* STATIC_HOST */ .Xs),
                    "ZW": () => ( /* reexport */ bncStartLink),
                    "UP": () => ( /* reexport */ getEarnLink),
                    "jl": () => ( /* reexport */ getQrocdeLink),
                    "GG": () => ( /* reexport */ startLink)
                });

                // UNUSED EXPORTS: ACADEMY_HOST, ACCOUNTS_HOST_PUBLIC, ACCOUNTS_HOST_PUBLIC_TEMPLATE, ALL_I18N_NS, API_HOST_PRIVATE, API_HOST_TEMPLATE, APP_ID, BUW_HOME_NS, COMMIT_HEAD, ENV, GA_TRACKING_ID, I18N_BASE_PRIVATE, I18N_BASE_PUBLIC, I18N_TRACK, I18N_TRACK_APPID, I18N_TRACK_HOST, INBOX_STREAM_HOST_TEMPLATE, IS_LOGGED, IS_NEZHA, JULIA_IMAGE, LEADING_ZEROS, LOGIN_URL, MARKET_STREAM_HOST, MARKET_STREAM_HOST_TEMPLATE, NEW_2FA_NS, NUMBER_ONLY_REGREX, PAY_HOST, PAY_HOST_TEMPLATE, SENTRY_DSN, SITE_HOST, SITE_HOST_TEMPLATE, STATIC_HOST_PRIVATE, STATIC_HOST_SHARE, SYSTEM_INFO, WS_HTTP_SDK_RESTFUL_RATE, i18nBasePath, isDarkMode, isDev, isHttp, isServer

                // EXTERNAL MODULE: ./src/constants/config.ts + 1 modules
                var config = __webpack_require__("n2Te");; // CONCATENATED MODULE: ./src/constants/links.ts
                var startLink = function() {
                    var lng = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "en";
                    return "https://binance.onelink.me/y874/zgb5ie5m?af_force_deeplink=true";
                };
                var bncStartLink = function() {
                    var lng = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "en";
                    return "https://binance.onelink.me/y874/zgb5ie5m?af_force_deeplink=true";
                };
                var getQrocdeLink = function() {
                    var lng = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "en";
                    return ( // `https://app.binance.com/${lng}/mp/qr/dplke2a8e0ccfc5df54ec726c87f76ef8289?utm_source=mini_program&utm_medium=mini_program_xoqXxUSMRccLCrZNRebmzj`
                        "https://binance.onelink.me/y874/zgb5ie5m?af_force_deeplink=true");
                };
                var getEarnLink = function() {
                    var lng = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "en";
                    return "https://binance.onelink.me/y874/t60di506?af_force_deeplink=true";
                };
                // `bnc://app.binance.com/${lng}/mp/qr/dplk90f91a5e69ccb27a1bd5f530e355e409?utm_source=mini_program&utm_medium=mini_program_xoqXxUSMRccLCrZNRebmzj`
                var DOWNLOAD_URLS = {
                    googlePlay: "https://app.appsflyer.com/com.binance.dev?pid=https%3A%2F%2Fwww.binance.com%2Fen&c=https%3A%2F%2Fwww.binance.com%2Fen",
                    appleStore: "https://app.appsflyer.com/id1436799971?pid=https%3A%2F%2Fwww.binance.com%2Fen&c=https%3A%2F%2Fwww.binance.com%2Fen"
                } // export const getEarnLink = (locale) => {
                //   const base = 'bnc://app.binance.com/mp/app'
                //   const appId = 'xoqXxUSMRccLCrZNRebmzj'
                //   const startPagePath = window.btoa('/pages/earn/home/index')
                //   const deeplink = `${base}?appId=${appId}&startPagePath=${startPagePath}`
                //   const dp = window.btoa(deeplink)
                //   return `https://app.binance.com/${locale}/download?_dp=${dp}`
                // }
                ;

                ; // CONCATENATED MODULE: ./src/constants/index.ts





                /***/
            }),

        /***/
        "CgVz":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "Rk": () => ( /* reexport */ useIsInViewport),
                    "bU": () => ( /* reexport */ useLocale /* useLocale */ .b),
                    "Fg": () => ( /* reexport */ useTheme_useTheme),
                    "$G": () => ( /* reexport */ useTranslation)
                });

                // UNUSED EXPORTS: THEME, useIsMobile, useLng, useRegion

                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");
                // EXTERNAL MODULE: ./.shuvi/app/runtime/bn/i18n.ts + 3 modules
                var i18n = __webpack_require__("QNan");; // CONCATENATED MODULE: ./src/hooks/useTranslation.ts

                // import { useParams } from "@shuvi/runtime";

                var i18nKeyListWithoutMpweb = [
                    "wallet",
                    "why-defi-wallet",
                    "ans-desc1",
                    "ans-desc3",
                    "faq-question1",
                    "faq-question2",
                    "faq-question3",
                    "faq-question4",
                ];
                var useTranslation = function(prefix) {
                    var t = (0, i18n /* useI18n */ .QT)([
                        "MPC-wallet-web",
                        "new2fa"
                    ]).t;
                    var preSpace = prefix !== null && prefix !== void 0 ? prefix : "mpweb";
                    // fucking code
                    return (0, external_React_.useCallback)(function(key) {
                        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        var ref;
                        var i18nKey = i18nKeyListWithoutMpweb.includes(key) ? key : [
                            preSpace,
                            key
                        ].filter(function(v) {
                            return v;
                        }).join("-");
                        return ((ref = t(i18nKey, options)) === null || ref === void 0 ? void 0 : ref.trim()) || options.defaultValue || "";
                    }, [
                        t,
                        preSpace
                    ]);
                };

                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+utils@2.13.192_@types+react@18.0.28_react@18.2.0/node_modules/@binance/utils/dist/esm/storage.js
                var storage = __webpack_require__("anf9");
                // EXTERNAL MODULE: ./node_modules/.pnpm/react-redux@7.2.1_react-dom@16.14.0_react@18.2.0_redux@4.1.0/node_modules/react-redux/es/index.js + 18 modules
                var es = __webpack_require__("HnbI");; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+hooks@2.19.155_@types+react@18.0.28_react-dom@16.14.0_react-redux@7.2.1_react@18.2.0/node_modules/@binance/hooks/dist/esm/rematch/useCookie.js





                var makeCookies = function(state) {
                    return state.cookies || {};
                };
                var useSelectorCookies = function() {
                    return useSelector(makeCookies, shallowEqual);
                };
                var useMakeCookies = function() {
                    var ref = (0, external_React_.useRef)(null);
                    var dispatch = (0, es /* useDispatch */ .I0)();
                    ref.current = (0, es /* useSelector */ .v9)(makeCookies);
                    return {
                        cookies: ref.current,
                        saveCookie: (0, external_React_.useCallback)(function(key, next) {
                            var nextValue = typeof next === "function" ? next(ref.current[key]) : next;
                            dispatch.cookies.save({
                                key: key,
                                value: nextValue
                            });
                        }, [])
                    };
                };
                var DARK = "dark";
                var LIGHT = "light";
                var themeKey = "theme";
                // Since the TV itself doesn't export any way to determine if the user has modified its styles,
                // it's a workaround for resolving https://jira.toolsfdg.net/browse/FA-5375
                var shouldResetTradingViewKey = "shouldResetTradingView";
                var getTheme = function(isLight) {
                    return isLight ? LIGHT : DARK;
                };
                var useTheme = function() {
                    var ref = useMakeCookies(),
                        cookies = ref.cookies,
                        saveCookie = ref.saveCookie;
                    var getThemeCounter = (0, external_React_.useCallback)(function() {
                        return storage /* storage.getItem */ .tO.getItem(shouldResetTradingViewKey, 0) || 0;
                    }, []);
                    var incThemeCounter = (0, external_React_.useCallback)(function() {
                        var lastTVThemeCounter = getThemeCounter();
                        storage /* storage.setItem */ .tO.setItem(shouldResetTradingViewKey, lastTVThemeCounter + 1);
                    }, [
                        getThemeCounter
                    ]);
                    return {
                        isLight: cookies[themeKey] !== DARK,
                        shouldResetTradingViewKey: shouldResetTradingViewKey,
                        getThemeCounter: getThemeCounter,
                        incThemeCounter: incThemeCounter,
                        toggleTheme: (0, external_React_.useCallback)(function() {
                            saveCookie(themeKey, function(preTheme) {
                                return getTheme(preTheme !== LIGHT);
                            });
                            incThemeCounter();
                        }, [
                            incThemeCounter
                        ])
                    };
                };
                var preferCurrency = "userPreferredCurrency";
                var useCachePreferFiat = function() {
                    var ref = useMakeCookies(),
                        cookies = ref.cookies,
                        saveCookie = ref.saveCookie;
                    return {
                        cachePreferFiat: cookies[preferCurrency],
                        setCacheFiat: useCallback(function(value) {
                            saveCookie(preferCurrency, value);
                        }, [])
                    };
                };
                var useSelectorPreferCurrency = function() {
                    return useCachePreferFiat().cachePreferFiat;
                };
                // for header buyCrypto && fiat trade
                var FIAT_PREFER_CURRENCY = "fiat-prefer-currency";
                var useFiatPreferCurrency = function() {
                    var ref = useMakeCookies(),
                        cookies = ref.cookies,
                        saveCookie = ref.saveCookie;
                    return {
                        getCurrency: cookies[FIAT_PREFER_CURRENCY],
                        setCurrency: useCallback(function(value) {
                            saveCookie(FIAT_PREFER_CURRENCY, value);
                        }, [])
                    };
                };
                var useBasisTimeZone = function() {
                    // This is for move old cookie value to localstorage, can delete "useCookie" after all user update (maybe 2025)
                    var oldbasisTimeZone = "changeBasisTimeZone";
                    var newBasisTimeZoneKey = "finance-common-changeBasisTimeZone";
                    var newBasisTimeZoneEvent = "finance-common-changeBasisTimeZone-change";
                    var ref2 = useCookie(oldbasisTimeZone),
                        basisTimeOldValue = ref2.cookieValue;
                    var ref1 = _sliced_to_array(useLocalStorage(newBasisTimeZoneKey, basisTimeOldValue || ""), 2),
                        newBasisTimeZone = ref1[0],
                        setNewBasisTimeZone = ref1[1];
                    var handleStorageChange = function() {
                        if (getItem(newBasisTimeZoneKey) !== newBasisTimeZone) {
                            try {
                                var ref;
                                setNewBasisTimeZone(JSON.parse(window === null || window === void 0 ? void 0 : (ref = window.localStorage) === null || ref === void 0 ? void 0 : ref[newBasisTimeZoneKey]) || "");
                            } catch (error) {
                                setNewBasisTimeZone("");
                            }
                        }
                    };
                    var triggerEvent = function() {
                        var event = new CustomEvent(newBasisTimeZoneEvent, {});
                        window.dispatchEvent(event);
                    };
                    useEffect(function() {
                        window.addEventListener(newBasisTimeZoneEvent, handleStorageChange);
                        return function() {
                            window.removeEventListener(newBasisTimeZoneEvent, handleStorageChange);
                        };
                    }, [
                        handleStorageChange
                    ]);
                    return {
                        basisTimeZone: newBasisTimeZone || "",
                        setBasisTimeZone: useCallback(function(value) {
                            setNewBasisTimeZone(value);
                            triggerEvent();
                        }, [
                            triggerEvent
                        ])
                    };
                };

                ; // CONCATENATED MODULE: ./src/hooks/useTheme.ts


                var THEME;
                (function(THEME) {
                    THEME["LIGHT"] = "light";
                    THEME["DARK"] = "dark";
                })(THEME || (THEME = {}));
                var useTheme_useTheme = function() {
                    // const [theme, changeTheme] = useState(THEME.LIGHT);
                    var ref = useTheme(),
                        toggleTheme = ref.toggleTheme,
                        isLight = ref.isLight;
                    var theme = isLight ? THEME.LIGHT : THEME.DARK;
                    (0, external_React_.useEffect)(function() {
                        var html = document.documentElement;
                        if (theme === THEME.DARK) {
                            html.classList.add("dark");
                        } else {
                            html.classList.remove("dark");
                        }
                    }, [
                        theme
                    ]);
                    // const toggleTheme = useCallback(() => {
                    //   changeTheme(theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT);
                    // }, [theme]);
                    return [
                        theme,
                        toggleTheme
                    ];
                };

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_sliced_to_array.mjs + 2 modules
                var src_sliced_to_array = __webpack_require__("/++K");; // CONCATENATED MODULE: ./src/hooks/useIsInViewport.ts


                var useIsInViewport = function(ref) {
                    var _$ref = (0, external_React_.useState)(false),
                        isInViewport = _$ref[0],
                        setIsInViewport = _$ref[1];
                    var observer = (0, external_React_.useMemo)(function() {
                        if (false) {}
                        return new IntersectionObserver(function(param) {
                            var _param = (0, src_sliced_to_array /* default */ .Z)(param, 1),
                                entry = _param[0];
                            return setIsInViewport(entry.isIntersecting);
                        });
                    }, []);
                    (0, external_React_.useEffect)(function() {
                        if (observer) {
                            observer.observe(ref.current);
                            return function() {
                                observer.disconnect();
                            };
                        }
                    }, [
                        ref,
                        observer
                    ]);
                    return isInViewport;
                };

                // EXTERNAL MODULE: ./src/hooks/useLocale.ts
                var useLocale = __webpack_require__("+ltY");
                // EXTERNAL MODULE: ./src/hooks/useLng.ts
                var useLng = __webpack_require__("Vo9m");; // CONCATENATED MODULE: ./src/hooks/index.ts








                /***/
            }),

        /***/
        "Vo9m":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "t": () => ( /* binding */ useLng)
                    /* harmony export */
                });
                /* unused harmony export useRegion */
                /* harmony import */
                var _shuvi_runtime_bn_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("QNan");
                /* harmony import */
                var _useLocale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("+ltY");


                var useLng = function() {
                    var code = (0, _useLocale__WEBPACK_IMPORTED_MODULE_1__ /* .useLocale */ .b)();
                    return (0, _shuvi_runtime_bn_i18n__WEBPACK_IMPORTED_MODULE_0__ /* .getLangFromCode */ .yV)(code);
                };
                // 兼容老路由， 默认 /cn 代表着 region cn, /tw tw
                var regionMap = {
                    cn: "cn",
                    tw: "tw",
                    au: "au",
                    br: "br",
                    es: "la"
                };
                var useRegion = function() {
                    var code = useLocale();
                    return regionMap[code] || getRegionFromCode(code);
                };


                /***/
            }),

        /***/
        "+ltY":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "b": () => ( /* binding */ useLocale)
                    /* harmony export */
                });
                /* harmony import */
                var _shuvi_runtime_bn_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("QNan");

                var useLocale = function() {
                    var locale = (0, _shuvi_runtime_bn_i18n__WEBPACK_IMPORTED_MODULE_0__ /* .useI18n */ .QT)().locale;
                    return locale || "en";
                };


                /***/
            }),

        /***/
        "OKG+":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "Dt": () => ( /* binding */ isAndroid),
                    "nD": () => ( /* binding */ useUA)
                });

                // UNUSED EXPORTS: isIOS, isIPad, isIPhone, isMobile, isTablet

                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");; // CONCATENATED MODULE: ./node_modules/.pnpm/react-use@17.6.0_react-dom@16.14.0_react@18.2.0/node_modules/react-use/esm/misc/util.js
                var noop = function() {};

                function on(obj) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (obj && obj.addEventListener) {
                        obj.addEventListener.apply(obj, args);
                    }
                }

                function off(obj) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (obj && obj.removeEventListener) {
                        obj.removeEventListener.apply(obj, args);
                    }
                }
                var isBrowser = "object" !== 'undefined';
                var isNavigator = typeof navigator !== 'undefined';

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/react-use@17.6.0_react-dom@16.14.0_react@18.2.0/node_modules/react-use/esm/factory/createBreakpoint.js


                var createBreakpoint = function(breakpoints) {
                    if (breakpoints === void 0) {
                        breakpoints = {
                            laptopL: 1440,
                            laptop: 1024,
                            tablet: 768
                        };
                    }
                    return function() {
                        var _a = (0, external_React_.useState)(isBrowser ? window.innerWidth : 0),
                            screen = _a[0],
                            setScreen = _a[1];
                        (0, external_React_.useEffect)(function() {
                            var setSideScreen = function() {
                                setScreen(window.innerWidth);
                            };
                            setSideScreen();
                            on(window, 'resize', setSideScreen);
                            return function() {
                                off(window, 'resize', setSideScreen);
                            };
                        });
                        var sortedBreakpoints = (0, external_React_.useMemo)(function() {
                            return Object.entries(breakpoints).sort(function(a, b) {
                                return (a[1] >= b[1] ? 1 : -1);
                            });
                        }, [breakpoints]);
                        var result = sortedBreakpoints.reduce(function(acc, _a) {
                            var name = _a[0],
                                width = _a[1];
                            if (screen >= width) {
                                return name;
                            } else {
                                return acc;
                            }
                        }, sortedBreakpoints[0][0]);
                        return result;
                    };
                };
                /* harmony default export */
                const factory_createBreakpoint = (createBreakpoint);

                ; // CONCATENATED MODULE: ./src/hooks/useUA.ts


                /**
                 * 判断是否为 ios 设备
                 * @param  {string}  [ua]   userAgent 字符串
                 * @return {Boolean}
                 */
                function isIOS(ua) {
                    ua = ua || navigator.userAgent;
                    return /ip(hone|od)|ipad/i.test(ua);
                }
                /**
                 * 判断是否为手机设备
                 * @param  {string}  [ua]   userAgent 字符串
                 * @return {Boolean}
                 */
                function isMobile(ua) {
                    ua = ua || navigator.userAgent;
                    return !!ua.match( // eslint-disable-next-line max-len
                        /ip(hone|od)|android.+mobile|windows (ce|phone)|blackberry|bb10|symbian|webos|firefox.+fennec|opera m(ob|in)i|polaris|iemobile|lgtelecom|nokia|sonyericsson|dolfin|uzard|natebrowser|ktf;|skt;/i);
                }
                /**
                 * 判断是否为iphone
                 * @param  {string}  [ua]   userAgent 字符串
                 * @return {Boolean}
                 */
                function isIPhone(ua) {
                    ua = ua || navigator.userAgent;
                    return !!ua.match(/iphone/i);
                }
                /**
                 * 判断是否为iPad
                 * @param  {string}  [ua]   userAgent 字符串
                 * @return {Boolean}
                 */
                function isIPad(ua) {
                    ua = ua || navigator.userAgent;
                    return !!ua.match(/ipad/i);
                }
                /**
                 * 判断是否为 android 设备, iOS jdapp内的webview有'android'字样
                 * @param  {string}  [ua]   userAgent 字符串
                 * @return {Boolean}
                 */
                function isAndroid(ua) {
                    ua = ua || navigator.userAgent;
                    return /android/i.test(ua) && !isIOS(ua);
                }
                /**
                 * 判断是否为平板设备
                 * @param  {string}  [ua]   userAgent 字符串
                 * @return {Boolean}
                 */
                function isTablet(ua) {
                    ua = ua || navigator.userAgent;
                    return /ipad/i.test(ua) || /android/i.test(ua) && !/mobi|mini|fennec/i.test(ua);
                }
                var useBreakpoint = factory_createBreakpoint({
                    mobile: 0,
                    tablet: 768,
                    desktop: 1024
                });
                var useUA = function() {
                    var ref = (0, external_React_.useState)({
                            isIOS: false
                        }),
                        device = ref[0],
                        setDevice = ref[1];
                    var breakpoint = useBreakpoint();
                    (0, external_React_.useEffect)(function() {
                        var isIOSDevice = isIOS();
                        setDevice({
                            isIOS: isIOSDevice
                        });
                    }, []);
                    return {
                        isTablet: breakpoint === "tablet",
                        isMobile: breakpoint === "mobile",
                        isDesktop: breakpoint === "desktop",
                        isIOS: device.isIOS
                    };
                };


                /***/
            }),

        /***/
        "F8bZ":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "e": () => ( /* binding */ Business)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var _components_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("uBHB");
                /* harmony import */
                var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CW2u");
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("CgVz");




                var Business = function() {
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_3__ /* .useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
                        children: [
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                className: "hidden py-[120px] lg:block",
                                children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                    className: "mx-[auto] w-[1200px] rounded-[16px] border border-solid border-[#EAECEF] px-[120px] py-[80px]",
                                    children: [
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "headline-2 t-primary mb-2 text-center",
                                            children: t("engage-users", {
                                                defaultValue: "Engage with Millions of Users"
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "mx-auto mb-[48px] w-[640px] text-center",
                                            children: t("engage-users-desc", {
                                                defaultValue: "Deepen your understanding of your users with our robust Wallet SDK. Connect, engage, and grow with Binance's vast and active user base."
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                            className: "text-center",
                                            children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", {
                                                href: "https://developers.binance.com/docs/binance-w3w/introduction",
                                                children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_1__ /* .Button */ .z, {
                                                    className: "!inline-block",
                                                    children: t("get-sdk", {
                                                        defaultValue: "Get Wallet SDK"
                                                    })
                                                })
                                            })
                                        })
                                    ]
                                })
                            }),
                            /*#__PURE__*/
                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                className: "dark-bg-2 hidden pt-[70px] lg:block",
                                children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                    className: "mx-auto flex w-[990px] flex-row items-start justify-between",
                                    children: [
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                            children: [
                                                /*#__PURE__*/
                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                    className: "headline-4 dark-t-primary mb-[16px]",
                                                    children: t("drive-campaigns", {
                                                        defaultValue: "Drive Impactful Campaigns"
                                                    })
                                                }),
                                                /*#__PURE__*/
                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                    className: "body-2 dark-t-primary mb-[48px]",
                                                    children: t("drive-campaigns-desc-new", {
                                                        defaultValue: "Harness the power of Binance Web3 Wallet to host impactful campaigns for your project. Boost your project's visibility and rely on our advanced technology for seamless execution."
                                                    })
                                                }),
                                                /*#__PURE__*/
                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                    children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", {
                                                        href: "https://docs.google.com/forms/d/e/1FAIpQLSetqiGXHzCYMQbQucosmVXDkkgM-BEPTAV--eCRo8xJ7ob3rA/viewform",
                                                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_1__ /* .Button */ .z, {
                                                            children: t("contact-us", {
                                                                defaultValue: "Contact Us"
                                                            })
                                                        })
                                                    })
                                                })
                                            ]
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
                                            className: "lg:h-[294px] lg:w-[282px]",
                                            src: "".concat(_constants__WEBPACK_IMPORTED_MODULE_2__ /* .IMG_URL */ .bV, "/business-mail.png")
                                        })
                                    ]
                                })
                            })
                        ]
                    });
                };


                /***/
            }),

        /***/
        "G+it":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "l$": () => ( /* binding */ qrcodeVisibleAtom),
                    /* harmony export */
                    "m3": () => ( /* binding */ CTAButton)
                    /* harmony export */
                });
                /* unused harmony export createPostDetailDeepLink */
                /* harmony import */
                var _swc_helpers_src_sliced_to_array_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("/++K");
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var _components_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("uBHB");
                /* harmony import */
                var _utils_initSensors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ZztR");
                /* harmony import */
                var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("CW2u");
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("CgVz");
                /* harmony import */
                var _hooks_useLng__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("Vo9m");
                /* harmony import */
                var _hooks_useUA__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("OKG+");
                /* harmony import */
                var jotai__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("8GlW");
                /* harmony import */
                var jotai__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("3Tbc");









                var qrcodeVisibleAtom = (0, jotai__WEBPACK_IMPORTED_MODULE_7__ /* .atom */ .cn)(false);
                var createPostDetailDeepLink = function(param) {
                    var id = param.id,
                        contentType = param.contentType,
                        locale = param.locale;
                    var base = "bnc://app.binance.com/mp/app";
                    var appId = "znf9fpiMh6ufdU3vDtAvi4";
                    var startPagePath = "L3BhZ2VzL2Rhc2hib2FyZC1uZXcvaW5kZXg=";
                    var dp = window.btoa("".concat(base, "?appId=").concat(appId, "&startPagePath=").concat(startPagePath));
                    return "https://app.binance.com/".concat(locale, "/download?_dp=").concat(dp);
                };

                function CTAButton() {
                    var ref = (0, _swc_helpers_src_sliced_to_array_mjs__WEBPACK_IMPORTED_MODULE_8__ /* ["default"] */ .Z)((0, jotai__WEBPACK_IMPORTED_MODULE_9__ /* .useAtom */ .KO)(qrcodeVisibleAtom), 2),
                        _ = ref[0],
                        setVisible = ref[1];
                    var isDesktop = (0, _hooks_useUA__WEBPACK_IMPORTED_MODULE_6__ /* .useUA */ .nD)().isDesktop;
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_4__ /* .useTranslation */ .$G)();
                    var lng = (0, _hooks_useLng__WEBPACK_IMPORTED_MODULE_5__ /* .useLng */ .t)();
                    var getHref = function(isAndroid) {
                        if (isAndroid) {
                            return (0, _constants__WEBPACK_IMPORTED_MODULE_3__ /* .bncStartLink */ .ZW)(lng);
                        }
                        return (0, _constants__WEBPACK_IMPORTED_MODULE_3__ /* .startLink */ .GG)(lng);
                    };
                    var onClick = function() {
                        // @ts-ignore-next-line: Upgrade pika 0.2.6 -> 0.3.57
                        _utils_initSensors__WEBPACK_IMPORTED_MODULE_2__ /* .track.click */ .j.click("buw_homepage_click_start");
                        if (isDesktop) {
                            setVisible(true);
                        } else {
                            window.open(getHref((0, _hooks_useUA__WEBPACK_IMPORTED_MODULE_6__ /* .isAndroid */ .Dt)()));
                        }
                    };
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_1__ /* .Button */ .z, {
                        className: "!w-[180px]",
                        onClick: onClick,
                        children: t("get-started", {
                            defaultValue: "Get Started"
                        })
                    });
                }


                /***/
            }),

        /***/
        "2swF":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "e": () => ( /* binding */ Disclaimer)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("CgVz");
                /* harmony import */
                var _Section__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4oCX");



                function Disclaimer() {
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_1__ /* .useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Section__WEBPACK_IMPORTED_MODULE_2__ /* .Section */ .$, {
                        className: "caption-2 t-third mt-[48px] md:mt-[64px]",
                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                            className: "disclaimer mb-[24px]",
                            dangerouslySetInnerHTML: {
                                __html: t("disclaimer", {
                                    defaultValue: 'Disclaimer: Digital asset prices can be volatile. The value of your investment may go down or up and you may not get back the amount invested. You are solely responsible for your investment decisions and Binance is not liable for any losses you may incur. APR is an estimate of rewards you will earn in cryptocurrency over the selected timeframe. It does not display the actual or predicted returns/yield in any fiat currency. APR is adjusted daily and the estimated rewards may differ from the actual rewards generated. Not financial advice. For more information, see our <a href="https://www.binance.com/en/terms" target="_blank">Terms of Use</a> and <a href="https://www.binance.com/en/risk-warning" target="_blank">Risk Warning.</a><br /><br />\n              Binance Web3 Wallet is an optional product. It is your responsibility to determine if this product is suitable for you. Binance is not responsible for your access or use of third-party applications (including functionality embedded within the Binance Web3 Wallet) and shall have no liability whatsoever in connection with your use of such third-party applications, including, without limitation, any transactions you dispute. Please carefully review the <a href="https://www.binance.com/en/defiwallet/term-of-use" target="_blank">Binance Web3 Wallet Terms of Use</a> and always do your own research.\n              '
                                })
                            }
                        })
                    });
                }


                /***/
            }),

        /***/
        "mRbc":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "O": () => ( /* binding */ FadeInComp)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DTvD");
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CgVz");
                /* harmony import */
                var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("w7fa");
                /* harmony import */
                var classnames__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_3__);




                var FadeInComp = function(param) {
                    var children = param.children;
                    var ref = (0, react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
                        showContent = ref[0],
                        setShowContent = ref[1];
                    var content = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_1__.createRef)();
                    var isInViewport = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__ /* .useIsInViewport */ .Rk)(content);
                    (0, react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {
                        if (isInViewport) {
                            setTimeout(function() {
                                setShowContent(true);
                            }, 300);
                        }
                    }, [
                        isInViewport
                    ]);
                    var cls = classnames__WEBPACK_IMPORTED_MODULE_3___default()("transition-opacity duration-[1000ms]", "".concat(showContent ? "!opacity-100" : "!opacity-0"));
                    return ( // @ts-ignore
                        /*#__PURE__*/
                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                            className: cls,
                            ref: content,
                            children: children
                        }));
                };


                /***/
            }),

        /***/
        "iCkf":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "B": () => ( /* binding */ Faq)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread.mjs
                var _object_spread = __webpack_require__("ys0/");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_without_properties.mjs + 1 modules
                var _object_without_properties = __webpack_require__("Cmqe");
                // EXTERNAL MODULE: ./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
                var jsx_runtime = __webpack_require__("oUqw");
                // EXTERNAL MODULE: ./src/hooks/index.ts + 4 modules
                var hooks = __webpack_require__("CgVz");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/Section.tsx
                var Section = __webpack_require__("4oCX");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread_props.mjs
                var _object_spread_props = __webpack_require__("L2LL");; // CONCATENATED MODULE: ./src/routes/defiwallet/components/Minus.tsx



                var Minus = function(props) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("svg", (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                        xmlns: "http://www.w3.org/2000/svg",
                        viewBox: "0 0 24 24",
                        fill: "none"
                    }, props), {
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                            d: "M3 10.5v3h18v-3H3z",
                            fill: "currentColor"
                        })
                    }));
                };

                // EXTERNAL MODULE: ./src/routes/defiwallet/components/FadeInComp.tsx
                var FadeInComp = __webpack_require__("mRbc");; // CONCATENATED MODULE: ./src/icons/ChevronDown.tsx

                var ChevronDown = function() {
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("svg", {
                        width: "25",
                        height: "25",
                        viewBox: "0 0 25 25",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                            fillRule: "evenodd",
                            clipRule: "evenodd",
                            d: "M12.4993 12.8042L8.61035 8.91522L6.84258 10.683L12.4994 16.3398L14.2672 14.5721L14.2671 14.572L18.1562 10.6828L16.3885 8.91503L12.4993 12.8042Z",
                            fill: "#C99400"
                        })
                    });
                };

                ; // CONCATENATED MODULE: ./src/icons/PlusF.tsx



                function PlusF(props) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("svg", (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                        width: "16",
                        height: "16",
                        viewBox: "0 0 16 16",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg"
                    }, props), {
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)("path", {
                            d: "M14 9V7H9L9 2H7V7H2V9H7V14H9L9 9H14Z",
                            fill: "currentColor"
                        })
                    }));
                }

                // EXTERNAL MODULE: ./src/hooks/useLng.ts
                var useLng = __webpack_require__("Vo9m");; // CONCATENATED MODULE: ./src/routes/defiwallet/components/Faq.tsx











                function Faq() {
                    var mpt = (0, hooks /* useTranslation */ .$G)("wmp");
                    var t2 = (0, hooks /* useTranslation */ .$G)("");
                    var lng = (0, useLng /* useLng */ .t)();
                    var ref = (0, external_React_.useState)(),
                        activity = ref[0],
                        setActivity = ref[1];
                    var ref1 = (0, external_React_.useState)(false),
                        showMore = ref1[0],
                        setShowMore = ref1[1];
                    var faqList = [{
                            title: mpt("faq-1019-1", {
                                defaultValue: "What is Binance Web3 Wallet?"
                            }),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                children: [
                                    mpt("faq-1019-1-sen1", {
                                        defaultValue: "Binance Web3 Wallet is a self-custody crypto wallet within the Binance app, designed to empower users in the realm of decentralized finance (DeFi). Serving as a digital gateway to blockchain-based applications (dApps), it offers users a secure and streamlined method to manage their cryptocurrencies, execute token swaps across multiple chains, earn yields, and interact with a variety of blockchain platforms."
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)(Link, {
                                        className: "ml-[2px]",
                                        href: "https://www.binance.com/support/faq/048ee79532494c03918dc4004214ad11",
                                        children: mpt("learn-more", {
                                            defaultValue: "Learn More"
                                        })
                                    })
                                ]
                            })
                        },
                        {
                            title: mpt("faq-1019-2", {
                                defaultValue: "What are the benefits of using Binance Web3 Wallet?"
                            }),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        children: mpt("faq-1019-2-sen1", {
                                            defaultValue: "Binance Web3 Wallet is the easiest way to get involved with Web3. It offers users a secure and streamlined method to manage their cryptocurrencies, execute token swaps across multiple chains, earn yields, and interact with a variety of blockchain platforms. "
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("ul", {
                                        children: [
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsxs)("li", {
                                                children: [
                                                    /*#__PURE__*/
                                                    (0, jsx_runtime.jsxs)(Bold, {
                                                        children: [
                                                            mpt("faq-1019-2-sen2", {
                                                                defaultValue: "Simple"
                                                            }),
                                                            ": \xa0"
                                                        ]
                                                    }),
                                                    /*#__PURE__*/
                                                    (0, jsx_runtime.jsx)("span", {
                                                        children: mpt("faq-1019-2-sen3", {
                                                            defaultValue: "Create a wallet in seconds using your Binance app without having to worry about seed phrases or private keys."
                                                        })
                                                    })
                                                ]
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsxs)("li", {
                                                children: [
                                                    /*#__PURE__*/
                                                    (0, jsx_runtime.jsxs)(Bold, {
                                                        children: [
                                                            mpt("faq-1019-2-sen4", {
                                                                defaultValue: "Convenient"
                                                            }),
                                                            ": \xa0"
                                                        ]
                                                    }),
                                                    /*#__PURE__*/
                                                    (0, jsx_runtime.jsx)("span", {
                                                        children: mpt("faq-1019-2-sen5", {
                                                            defaultValue: "With integration to Binance Bridge and other providers, Web3 wallet fosters easy cross-blockchain token swaps at better prices. You can explore dApps and generate yield effortlessly with a single click."
                                                        })
                                                    })
                                                ]
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsxs)("li", {
                                                children: [
                                                    /*#__PURE__*/
                                                    (0, jsx_runtime.jsxs)(Bold, {
                                                        children: [
                                                            mpt("faq-1019-2-sen6", {
                                                                defaultValue: "Secure"
                                                            }),
                                                            ": \xa0"
                                                        ]
                                                    }),
                                                    /*#__PURE__*/
                                                    (0, jsx_runtime.jsx)("span", {
                                                        children: mpt("faq-1019-2-sen7", {
                                                            defaultValue: "MPC (multi-party computation) technology governs every transaction and mitigates single points of failure to ensure that your assets are SAFU."
                                                        })
                                                    })
                                                ]
                                            })
                                        ]
                                    })
                                ]
                            })
                        },
                        {
                            title: mpt("faq-1019-3", {
                                defaultValue: "How do I use my Binance Web3 Wallet to send and receive tokens?"
                            }),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)(Bold, {
                                        className: "mb-1 block",
                                        children: mpt("faq-1019-3-sen1", {
                                            defaultValue: "To send tokens"
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        children: [
                                            "1.",
                                            " ",
                                            mpt("faq-1019-3-sen2", {
                                                defaultValue: "Tap [Transfer Now] on the Web3 Wallet homepage."
                                            })
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        children: [
                                            "2.",
                                            " ",
                                            mpt("faq-1019-3-sen3", {
                                                defaultValue: "Paste the recipient’s address and tap [Continue]."
                                            })
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "mt-1",
                                        children: mpt("faq-1019-3-sen4", {
                                            defaultValue: "Please note that if you select the wrong network or send assets to the wrong address, your funds might be lost and cannot be recovered."
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)(Bold, {
                                        className: "mb-1 mt-2 block",
                                        children: mpt("faq-1019-3-sen5")
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        children: [
                                            "1. ",
                                            mpt("faq-1019-3-sen6")
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        className: "mb-2",
                                        children: [
                                            "2. ",
                                            mpt("faq-1019-3-sen7")
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)(Link, {
                                        href: "https://www.binance.com/support/faq/02f7eb872eca4a1ea44c775767170d13",
                                        children: mpt("learn-more")
                                    })
                                ]
                            })
                        },
                        {
                            title: mpt("faq-1019-4"),
                            content: mpt("faq-1019-4-sen1")
                        },
                        {
                            title: mpt("faq-1019-5"),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("span", {
                                        children: mpt("faq-1019-5-sen1")
                                    }),
                                    " ",
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)(Link, {
                                        href: "https://www.binance.com/support/faq/4efebcb9a937417ca31baa2f7754c50f",
                                        children: mpt("learn-more")
                                    })
                                ]
                            })
                        },
                        {
                            title: mpt("faq-1019-6"),
                            content: mpt("faq-1019-6-sen1")
                        },
                        {
                            title: mpt("faq-1019-7"),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("span", {
                                        children: mpt("faq-1019-7-sen1")
                                    }),
                                    " ",
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)(Link, {
                                        href: "https://www.binance.com/support/faq/4efebcb9a937417ca31baa2f7754c50f",
                                        children: mpt("learn-more")
                                    })
                                ]
                            })
                        },
                        {
                            title: mpt("faq-1019-8"),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                                children: mpt("faq-1019-8-sen1")
                            })
                        },
                        {
                            title: mpt("faq-1019-9"),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                                children: mpt("faq-1019-9-sen1")
                            })
                        },
                        {
                            title: mpt("faq-1019-10"),
                            content: /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "mb-1",
                                        children: mpt("faq-1019-10-sen1")
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        children: mpt("faq-1019-10-sen2")
                                    })
                                ]
                            })
                        },
                    ];
                    var onClick = function(index) {
                        if (activity === index) {
                            setActivity(-1);
                        } else {
                            setActivity(index);
                        }
                    };
                    var onShowMoreClick = function() {
                        setShowMore(true);
                    };
                    var showFaqList = showMore ? faqList : faqList.slice(0, 5);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(Section /* Section */ .$, {
                        children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(FadeInComp /* FadeInComp */ .O, {
                            children: [
                                /*#__PURE__*/
                                (0, jsx_runtime.jsx)("div", {
                                    children: showFaqList.map(function(item, index) {
                                        return /*#__PURE__*/ (0, jsx_runtime.jsx)(FaqItem, (0, _object_spread /* default */ .Z)({
                                            index: index,
                                            activity: activity === index,
                                            onClick: onClick
                                        }, item), index);
                                    })
                                }),
                                /*#__PURE__*/
                                (0, jsx_runtime.jsxs)("div", {
                                    onClick: onShowMoreClick,
                                    className: "mt-[16px] flex cursor-pointer items-center justify-center ".concat(showMore ? "hidden" : ""),
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("div", {
                                            className: "subtitle-3 t-brand mr-[2px]",
                                            children: t2("wmp-view-more")
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(ChevronDown, {})
                                    ]
                                })
                            ]
                        })
                    });
                }

                function Link(props) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("a", (0, _object_spread /* default */ .Z)({
                        style: {
                            color: "rgb(240, 185, 11)"
                        }
                    }, props));
                }

                function FaqItem(param) {
                    var index = param.index,
                        title = param.title,
                        content = param.content,
                        activity = param.activity,
                        onClick = param.onClick;
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsxs)("div", {
                                onClick: function() {
                                    return onClick(index);
                                },
                                className: "hover:bg-selected faqItem mb-4 flex justify-between rounded py-2 hover:cursor-pointer md:p-4",
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        className: "flex items-center",
                                        children: [
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "bg-disable mr-2 flex h-[32px] w-[32px] shrink-0 items-center justify-center rounded-lg md:mr-4",
                                                children: index + 1
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "md:subtitle-1 subtitle-2-1",
                                                children: title
                                            })
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "bg-disable faqIcon ml-2 flex h-6 w-6 shrink-0 items-center justify-center rounded-full md:h-8 md:w-8",
                                        children: activity ? /*#__PURE__*/ (0, jsx_runtime.jsx)(Minus, {
                                            className: "w-4"
                                        }) : /*#__PURE__*/ (0, jsx_runtime.jsx)(PlusF, {
                                            className: "w-4"
                                        })
                                    })
                                ]
                            }),
                            activity ? /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                                className: "t-secondary mb-6 pl-[38px] pr-6 text-xs md:pl-[64px] md:pr-6 md:text-base lg:pl-[60px] lg:pr-[50px]",
                                children: content
                            }) : null
                        ]
                    });
                }

                function Bold(_param) {
                    var className = _param.className,
                        props = (0, _object_without_properties /* default */ .Z)(_param, [
                            "className"
                        ]);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("span", (0, _object_spread /* default */ .Z)({
                        className: "font-semibold ".concat(className !== null && className !== void 0 ? className : "")
                    }, props));
                }


                /***/
            }),

        /***/
        "4oCX":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "$": () => ( /* binding */ Section)
                    /* harmony export */
                });
                /* harmony import */
                var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ys0/");
                /* harmony import */
                var _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Cmqe");
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");



                function Section(_param) {
                    var className = _param.className,
                        props = (0, _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_1__ /* ["default"] */ .Z)(_param, [
                            "className"
                        ]);
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("section", (0, _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_2__ /* ["default"] */ .Z)({
                        className: "mx-auto w-full px-6 md:px-12 lg:max-w-[1200px] lg:px-0 ".concat(className !== null && className !== void 0 ? className : "")
                    }, props));
                }


                /***/
            }),

        /***/
        "cIYf":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "S": () => ( /* binding */ Section1)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
                var jsx_runtime = __webpack_require__("oUqw");
                // EXTERNAL MODULE: ./src/constants/index.ts + 1 modules
                var constants = __webpack_require__("CW2u");
                // EXTERNAL MODULE: ./src/hooks/index.ts + 4 modules
                var hooks = __webpack_require__("CgVz");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/Section.tsx
                var Section = __webpack_require__("4oCX");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");; // CONCATENATED MODULE: ./src/routes/defiwallet/components/WordsLoop.tsx



                var WordsLoop = function() {
                    var t = (0, hooks /* useTranslation */ .$G)();
                    (0, external_React_.useEffect)(function() {
                        var changeWord = function changeWord() {
                            var cw = words[currentWord];
                            var nw = currentWord == words.length - 1 ? words[0] : words[currentWord + 1];
                            animateLetterOut(cw);
                            nw.className = "wordsLoop letter behind";
                            animateLetterIn(nw);
                            currentWord = currentWord == words.length - 1 ? 0 : currentWord + 1;
                        };
                        var animateLetterOut = function animateLetterOut(cw) {
                            setTimeout(function() {
                                cw.className = "wordsLoop letter out";
                            });
                        };
                        var animateLetterIn = function animateLetterIn(nw) {
                            setTimeout(function() {
                                nw.className = "wordsLoop letter in";
                            }, 340);
                        };
                        var words = document.getElementsByClassName("wordsLoop");
                        var currentWord = 0;
                        // @ts-ignore-next-line: Upgrade pika 0.2.6 -> 0.3.57
                        words[currentWord].style.opacity = 1;
                        changeWord();
                        setInterval(changeWord, 2000);
                    }, []);
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                        className: "headline-4 md:headline-1 relative h-[40px] w-full md:h-[72px]",
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("h1", {
                                className: "lg:justify-left absolute left-0 flex w-full justify-center lg:justify-start",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)("span", {
                                    className: "wordsLoop opacity-0",
                                    children: [
                                        t("simple", {
                                            defaultValue: "Simple"
                                        }),
                                        "."
                                    ]
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("h1", {
                                className: "lg:justify-left absolute left-0 flex w-full justify-center lg:justify-start",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)("span", {
                                    className: "wordsLoop opacity-0",
                                    children: [
                                        t("secure", {
                                            defaultValue: "Secure"
                                        }),
                                        "."
                                    ]
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("h1", {
                                className: "absolute left-0 flex w-full justify-center lg:justify-start",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)("span", {
                                    className: "wordsLoop opacity-0",
                                    children: [
                                        t("rewarding", {
                                            defaultValue: "Rewarding"
                                        }),
                                        "."
                                    ]
                                })
                            })
                        ]
                    });
                };

                // EXTERNAL MODULE: ./src/components/Video.tsx
                var Video = __webpack_require__("ZMxh");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/CTAButton.tsx
                var CTAButton = __webpack_require__("G+it");; // CONCATENATED MODULE: ./src/routes/defiwallet/components/Section1.tsx







                function Section1() {
                    var t = (0, hooks /* useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                        className: "relative z-20",
                        children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(Section /* Section */ .$, {
                            className: " flex flex-col items-center pb-6 pt-12 md:min-h-[calc(100vh-64px)] md:pb-15 lg:flex-row lg:pb-0 lg:pl-0 lg:pt-0",
                            children: [
                                /*#__PURE__*/
                                (0, jsx_runtime.jsxs)("div", {
                                    className: " mb-[68px] flex w-full flex-col items-center text-center lg:mb-0 lg:block lg:max-w-[786px] lg:!text-left lg:rtl:!text-right ",
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("div", {
                                            className: "relative flex",
                                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)("span", {
                                                className: " lg:headline-5 md:headline-5 subtitle-1 gradient mb-[12px] ",
                                                children: t("defi-wallet", {
                                                    defaultValue: "Binance Web3 Wallet"
                                                })
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(WordsLoop, {}),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("h1", {
                                            className: "md:headline-1 headline-4 mb-[40px] flex flex-wrap lg:max-w-[486px]",
                                            children: t("your-gateway-to-web3", {
                                                defaultValue: "Your world of Web3."
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(CTAButton /* CTAButton */ .m3, {})
                                    ]
                                }),
                                /*#__PURE__*/
                                (0, jsx_runtime.jsxs)("div", {
                                    id: "mobile",
                                    className: "flex w-full justify-center relative",
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("img", {
                                            src: "".concat(constants /* IMG_URL */ .bV, "/phone-wrap.png"),
                                            className: "h-[649px] w-[320px]"
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("div", {
                                            className: "rounded-[38px] overflow-hidden absolute top-[14px] ml-[2px]",
                                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Video /* Video */ .n, {
                                                className: "mx-auto w-[285px]",
                                                src: "".concat(constants /* IMG_URL */ .bV, "/hero-mobile-v3.mp4")
                                            })
                                        })
                                    ]
                                })
                            ]
                        })
                    });
                }


                /***/
            }),

        /***/
        "JN65":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "v": () => ( /* binding */ Section2)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("CW2u");
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CgVz");
                /* harmony import */
                var _Section__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("4oCX");
                /* harmony import */
                var _components_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("uBHB");





                function Section2(param) {
                    var onClick = param.onClick;
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__ /* .useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                        className: "relative z-20 flex w-full items-center  justify-center pb-20 lg:pb-[140px]",
                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Section__WEBPACK_IMPORTED_MODULE_3__ /* .Section */ .$, {
                            children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                className: "mx-auto flex w-full flex-col items-center md:w-[594px] lg:w-auto",
                                children: [
                                    /*#__PURE__*/
                                    (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h4", {
                                        id: "explore-title",
                                        className: "headline-4 md:headline-2 lg:headline-1 dark-t-primary mb-[16px] text-center ",
                                        children: t("explore-world", {
                                            defaultValue: "Explore the world of Web3 with ease"
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                        className: "lg:body-1 body-2 dark-t-secondary dark-t-secondary text-center lg:max-w-[600px]",
                                        children: t("trade-favorite-tokens", {
                                            defaultValue: "Trade your favorite tokens. Access multiple blockchains. Explore some of the best dApps. All without leaving your wallet."
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                        className: "subtitle-3 t-primary-hover mb-[16px] mt-4 flex cursor-pointer items-center lg:max-w-[600px]",
                                        onClick: onClick,
                                        children: [
                                            /*#__PURE__*/
                                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                children: t("view-networks-and-dapps", {
                                                    defaultValue: "View networks and dApps"
                                                })
                                            }),
                                            /*#__PURE__*/
                                            (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
                                                src: "".concat(_constants__WEBPACK_IMPORTED_MODULE_1__ /* .IMG_URL */ .bV, "/chevron-right-f.svg"),
                                                className: "h-6 w-6 translate-y-[1px]"
                                            })
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", {
                                        className: "hidden lg:block",
                                        href: "https://developers.binance.com/en/landingpage/dapps",
                                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_4__ /* .Button */ .z, {
                                            className: "h-[32px] w-auto px-[15px] lg:w-auto",
                                            children: t("list-your-dapp", {
                                                defaultValue: "List Your DApp"
                                            })
                                        })
                                    })
                                ]
                            })
                        })
                    });
                }


                /***/
            }),

        /***/
        "5j/h":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "v": () => ( /* binding */ Section3)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread.mjs
                var _object_spread = __webpack_require__("ys0/");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_without_properties.mjs + 1 modules
                var _object_without_properties = __webpack_require__("Cmqe");
                // EXTERNAL MODULE: ./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
                var jsx_runtime = __webpack_require__("oUqw");
                // EXTERNAL MODULE: ./src/hooks/index.ts + 4 modules
                var hooks = __webpack_require__("CgVz");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/FadeInComp.tsx
                var FadeInComp = __webpack_require__("mRbc");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/Section.tsx
                var Section = __webpack_require__("4oCX");
                // EXTERNAL MODULE: ./src/components/Video.tsx
                var Video = __webpack_require__("ZMxh");
                // EXTERNAL MODULE: ./src/constants/index.ts + 1 modules
                var constants = __webpack_require__("CW2u");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");; // CONCATENATED MODULE: ./src/components/JumpStack/style.scss
                // extracted by mini-css-extract-plugin

                // EXTERNAL MODULE: ./node_modules/.pnpm/use-sync-external-store@1.4.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js
                var shim = __webpack_require__("bmXu");; // CONCATENATED MODULE: ./node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/lite/index.mjs
                var has = Object.prototype.hasOwnProperty;

                function dequal(foo, bar) {
                    var ctor, len;
                    if (foo === bar) return true;

                    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
                        if (ctor === Date) return foo.getTime() === bar.getTime();
                        if (ctor === RegExp) return foo.toString() === bar.toString();

                        if (ctor === Array) {
                            if ((len = foo.length) === bar.length) {
                                while (len-- && dequal(foo[len], bar[len]));
                            }
                            return len === -1;
                        }

                        if (!ctor || typeof foo === 'object') {
                            len = 0;
                            for (ctor in foo) {
                                if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
                                if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
                            }
                            return Object.keys(bar).length === len;
                        }
                    }

                    return foo !== foo && bar !== bar;
                }

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swr@2.3.0_react@18.2.0/node_modules/swr/dist/_internal/config-context-client-x_C9_NWC.mjs
                'use client';



                // Global state used to deduplicate requests and store listeners
                const config_context_client_x_C9_NWC_SWRGlobalState = new WeakMap();

                // Shared state between server components and client components
                const noop = () => {};
                // Using noop() as the undefined value as undefined can be replaced
                // by something else. Prettier ignore and extra parentheses are necessary here
                // to ensure that tsc doesn't remove the __NOINLINE__ comment.
                // prettier-ignore
                const UNDEFINED = /*#__NOINLINE__*/ noop();
                const OBJECT = Object;
                const isUndefined = (v) => v === UNDEFINED;
                const isFunction = (v) => typeof v == 'function';
                const mergeObjects = (a, b) => ({
                    ...a,
                    ...b
                });
                const isPromiseLike = (x) => isFunction(x.then);

                const EMPTY_CACHE = {};
                const INITIAL_CACHE = {};
                const STR_UNDEFINED = 'undefined';
                // NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.
                const isWindowDefined = "object" != STR_UNDEFINED;
                const isDocumentDefined = typeof document != STR_UNDEFINED;
                const hasRequestAnimationFrame = () => isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;
                const createCacheHelper = (cache, key) => {
                    const state = config_context_client_x_C9_NWC_SWRGlobalState.get(cache);
                    return [
                        // Getter
                        () => !isUndefined(key) && cache.get(key) || EMPTY_CACHE,
                        // Setter
                        (info) => {
                            if (!isUndefined(key)) {
                                const prev = cache.get(key);
                                // Before writing to the store, we keep the value in the initial cache
                                // if it's not there yet.
                                if (!(key in INITIAL_CACHE)) {
                                    INITIAL_CACHE[key] = prev;
                                }
                                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);
                            }
                        },
                        // Subscriber
                        state[6],
                        // Get server cache snapshot
                        () => {
                            if (!isUndefined(key)) {
                                // If the cache was updated on the client, we return the stored initial value.
                                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];
                            }
                            // If we haven't done any client-side updates, we return the current value.
                            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;
                        }
                    ];
                } // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }
                ;

                /**
                 * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,
                 * it's not reliable to detect if the browser is currently online or offline
                 * based on `navigator.onLine`.
                 * As a workaround, we always assume it's online on the first load, and change
                 * the status upon `online` or `offline` events.
                 */
                let online = true;
                const isOnline = () => online;
                // For node and React Native, `add/removeEventListener` doesn't exist on window.
                const [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
                    window.addEventListener.bind(window),
                    window.removeEventListener.bind(window)
                ] : [
                    noop,
                    noop
                ];
                const isVisible = () => {
                    const visibilityState = isDocumentDefined && document.visibilityState;
                    return isUndefined(visibilityState) || visibilityState !== 'hidden';
                };
                const initFocus = (callback) => {
                    // focus revalidate
                    if (isDocumentDefined) {
                        document.addEventListener('visibilitychange', callback);
                    }
                    onWindowEvent('focus', callback);
                    return () => {
                        if (isDocumentDefined) {
                            document.removeEventListener('visibilitychange', callback);
                        }
                        offWindowEvent('focus', callback);
                    };
                };
                const initReconnect = (callback) => {
                    // revalidate on reconnected
                    const onOnline = () => {
                        online = true;
                        callback();
                    };
                    // nothing to revalidate, just update the status
                    const onOffline = () => {
                        online = false;
                    };
                    onWindowEvent('online', onOnline);
                    onWindowEvent('offline', onOffline);
                    return () => {
                        offWindowEvent('online', onOnline);
                        offWindowEvent('offline', onOffline);
                    };
                };
                const preset = {
                    isOnline,
                    isVisible
                };
                const defaultConfigOptions = {
                    initFocus,
                    initReconnect
                };

                const IS_REACT_LEGACY = !external_React_.useId;
                const IS_SERVER = !isWindowDefined || 'Deno' in globalThis;
                // Polyfill requestAnimationFrame
                const rAF = (f) => hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);
                // React currently throws a warning when using useLayoutEffect on the server.
                // To get around it, we can conditionally useEffect on the server (no-op) and
                // useLayoutEffect in the browser.
                const useIsomorphicLayoutEffect = IS_SERVER ? external_React_.useEffect : external_React_.useLayoutEffect;
                // This assignment is to extend the Navigator type to use effectiveType.
                const navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;
                // Adjust the config based on slow connection status (<= 70Kbps).
                const slowConnection = !IS_SERVER && navigatorConnection && ([
                    'slow-2g',
                    '2g'
                ].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);

                // use WeakMap to store the object->key mapping
                // so the objects can be garbage collected.
                // WeakMap uses a hashtable under the hood, so the lookup
                // complexity is almost O(1).
                const table = new WeakMap();
                const isObjectType = (value, type) => OBJECT.prototype.toString.call(value) === `[object ${type}]`;
                // counter of the key
                let counter = 0;
                // A stable hash implementation that supports:
                // - Fast and ensures unique hash properties
                // - Handles unserializable values
                // - Handles object key ordering
                // - Generates short results
                //
                // This is not a serialization function, and the result is not guaranteed to be
                // parsable.
                const stableHash = (arg) => {
                    const type = typeof arg;
                    const isDate = isObjectType(arg, 'Date');
                    const isRegex = isObjectType(arg, 'RegExp');
                    const isPlainObject = isObjectType(arg, 'Object');
                    let result;
                    let index;
                    if (OBJECT(arg) === arg && !isDate && !isRegex) {
                        // Object/function, not null/date/regexp. Use WeakMap to store the id first.
                        // If it's already hashed, directly return the result.
                        result = table.get(arg);
                        if (result) return result;
                        // Store the hash first for circular reference detection before entering the
                        // recursive `stableHash` calls.
                        // For other objects like set and map, we use this id directly as the hash.
                        result = ++counter + '~';
                        table.set(arg, result);
                        if (Array.isArray(arg)) {
                            // Array.
                            result = '@';
                            for (index = 0; index < arg.length; index++) {
                                result += stableHash(arg[index]) + ',';
                            }
                            table.set(arg, result);
                        }
                        if (isPlainObject) {
                            // Object, sort keys.
                            result = '#';
                            const keys = OBJECT.keys(arg).sort();
                            while (!isUndefined(index = keys.pop())) {
                                if (!isUndefined(arg[index])) {
                                    result += index + ':' + stableHash(arg[index]) + ',';
                                }
                            }
                            table.set(arg, result);
                        }
                    } else {
                        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;
                    }
                    return result;
                };

                const config_context_client_x_C9_NWC_serialize = (key) => {
                    if (isFunction(key)) {
                        try {
                            key = key();
                        } catch (err) {
                            // dependencies not ready
                            key = '';
                        }
                    }
                    // Use the original key as the argument of fetcher. This can be a string or an
                    // array of values.
                    const args = key;
                    // If key is not falsy, or not an empty array, hash it.
                    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';
                    return [
                        key,
                        args
                    ];
                };

                // Global timestamp.
                let __timestamp = 0;
                const getTimestamp = () => ++__timestamp;

                const FOCUS_EVENT = 0;
                const RECONNECT_EVENT = 1;
                const MUTATE_EVENT = 2;
                const ERROR_REVALIDATE_EVENT = 3;

                var events = {
                    __proto__: null,
                    ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,
                    FOCUS_EVENT: FOCUS_EVENT,
                    MUTATE_EVENT: MUTATE_EVENT,
                    RECONNECT_EVENT: RECONNECT_EVENT
                };

                async function internalMutate(...args) {
                    const [cache, _key, _data, _opts] = args;
                    // When passing as a boolean, it's explicitly used to disable/enable
                    // revalidation.
                    const options = mergeObjects({
                        populateCache: true,
                        throwOnError: true
                    }, typeof _opts === 'boolean' ? {
                        revalidate: _opts
                    } : _opts || {});
                    let populateCache = options.populateCache;
                    const rollbackOnErrorOption = options.rollbackOnError;
                    let optimisticData = options.optimisticData;
                    const rollbackOnError = (error) => {
                        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;
                    };
                    const throwOnError = options.throwOnError;
                    // If the second argument is a key filter, return the mutation results for all
                    // filtered keys.
                    if (isFunction(_key)) {
                        const keyFilter = _key;
                        const matchedKeys = [];
                        const it = cache.keys();
                        for (const key of it) {
                            if ( // Skip the special useSWRInfinite and useSWRSubscription keys.
                                !/^\$(inf|sub)\$/.test(key) && keyFilter(cache.get(key)._k)) {
                                matchedKeys.push(key);
                            }
                        }
                        return Promise.all(matchedKeys.map(mutateByKey));
                    }
                    return mutateByKey(_key);
                    async function mutateByKey(_k) {
                        // Serialize key
                        const [key] = config_context_client_x_C9_NWC_serialize(_k);
                        if (!key) return;
                        const [get, set] = createCacheHelper(cache, key);
                        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = config_context_client_x_C9_NWC_SWRGlobalState.get(cache);
                        const startRevalidate = () => {
                            const revalidators = EVENT_REVALIDATORS[key];
                            const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;
                            if (revalidate) {
                                // Invalidate the key by deleting the concurrent request markers so new
                                // requests will not be deduped.
                                delete FETCH[key];
                                delete PRELOAD[key];
                                if (revalidators && revalidators[0]) {
                                    return revalidators[0](MUTATE_EVENT).then(() => get().data);
                                }
                            }
                            return get().data;
                        };
                        // If there is no new data provided, revalidate the key with current state.
                        if (args.length < 3) {
                            // Revalidate and broadcast state.
                            return startRevalidate();
                        }
                        let data = _data;
                        let error;
                        // Update global timestamps.
                        const beforeMutationTs = getTimestamp();
                        MUTATION[key] = [
                            beforeMutationTs,
                            0
                        ];
                        const hasOptimisticData = !isUndefined(optimisticData);
                        const state = get();
                        // `displayedData` is the current value on screen. It could be the optimistic value
                        // that is going to be overridden by a `committedData`, or get reverted back.
                        // `committedData` is the validated value that comes from a fetch or mutation.
                        const displayedData = state.data;
                        const currentData = state._c;
                        const committedData = isUndefined(currentData) ? displayedData : currentData;
                        // Do optimistic data update.
                        if (hasOptimisticData) {
                            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;
                            // When we set optimistic data, backup the current committedData data in `_c`.
                            set({
                                data: optimisticData,
                                _c: committedData
                            });
                        }
                        if (isFunction(data)) {
                            // `data` is a function, call it passing current cache value.
                            try {
                                data = data(committedData);
                            } catch (err) {
                                // If it throws an error synchronously, we shouldn't update the cache.
                                error = err;
                            }
                        }
                        // `data` is a promise/thenable, resolve the final data first.
                        if (data && isPromiseLike(data)) {
                            // This means that the mutation is async, we need to check timestamps to
                            // avoid race conditions.
                            data = await data.catch((err) => {
                                error = err;
                            });
                            // Check if other mutations have occurred since we've started this mutation.
                            // If there's a race we don't update cache or broadcast the change,
                            // just return the data.
                            if (beforeMutationTs !== MUTATION[key][0]) {
                                if (error) throw error;
                                return data;
                            } else if (error && hasOptimisticData && rollbackOnError(error)) {
                                // Rollback. Always populate the cache in this case but without
                                // transforming the data.
                                populateCache = true;
                                // Reset data to be the latest committed data, and clear the `_c` value.
                                set({
                                    data: committedData,
                                    _c: UNDEFINED
                                });
                            }
                        }
                        // If we should write back the cache after request.
                        if (populateCache) {
                            if (!error) {
                                // Transform the result into data.
                                if (isFunction(populateCache)) {
                                    const populateCachedData = populateCache(data, committedData);
                                    set({
                                        data: populateCachedData,
                                        error: UNDEFINED,
                                        _c: UNDEFINED
                                    });
                                } else {
                                    // Only update cached data and reset the error if there's no error. Data can be `undefined` here.
                                    set({
                                        data,
                                        error: UNDEFINED,
                                        _c: UNDEFINED
                                    });
                                }
                            }
                        }
                        // Reset the timestamp to mark the mutation has ended.
                        MUTATION[key][1] = getTimestamp();
                        // Update existing SWR Hooks' internal states:
                        Promise.resolve(startRevalidate()).then(() => {
                            // The mutation and revalidation are ended, we can clear it since the data is
                            // not an optimistic value anymore.
                            set({
                                _c: UNDEFINED
                            });
                        });
                        // Throw error or return data
                        if (error) {
                            if (throwOnError) throw error;
                            return;
                        }
                        return data;
                    }
                }

                const revalidateAllKeys = (revalidators, type) => {
                    for (const key in revalidators) {
                        if (revalidators[key][0]) revalidators[key][0](type);
                    }
                };
                const initCache = (provider, options) => {
                    // The global state for a specific provider will be used to deduplicate
                    // requests and store listeners. As well as a mutate function that is bound to
                    // the cache.
                    // The provider's global state might be already initialized. Let's try to get the
                    // global state associated with the provider first.
                    if (!config_context_client_x_C9_NWC_SWRGlobalState.has(provider)) {
                        const opts = mergeObjects(defaultConfigOptions, options);
                        // If there's no global state bound to the provider, create a new one with the
                        // new mutate function.
                        const EVENT_REVALIDATORS = {};
                        const mutate = internalMutate.bind(UNDEFINED, provider);
                        let unmount = noop;
                        const subscriptions = {};
                        const subscribe = (key, callback) => {
                            const subs = subscriptions[key] || [];
                            subscriptions[key] = subs;
                            subs.push(callback);
                            return () => subs.splice(subs.indexOf(callback), 1);
                        };
                        const setter = (key, value, prev) => {
                            provider.set(key, value);
                            const subs = subscriptions[key];
                            if (subs) {
                                for (const fn of subs) {
                                    fn(value, prev);
                                }
                            }
                        };
                        const initProvider = () => {
                            if (!config_context_client_x_C9_NWC_SWRGlobalState.has(provider)) {
                                // Update the state if it's new, or if the provider has been extended.
                                config_context_client_x_C9_NWC_SWRGlobalState.set(provider, [
                                    EVENT_REVALIDATORS,
                                    {},
                                    {},
                                    {},
                                    mutate,
                                    setter,
                                    subscribe
                                ]);
                                if (!IS_SERVER) {
                                    // When listening to the native events for auto revalidations,
                                    // we intentionally put a delay (setTimeout) here to make sure they are
                                    // fired after immediate JavaScript executions, which can be
                                    // React's state updates.
                                    // This avoids some unnecessary revalidations such as
                                    // https://github.com/vercel/swr/issues/1680.
                                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
                                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
                                    unmount = () => {
                                        releaseFocus && releaseFocus();
                                        releaseReconnect && releaseReconnect();
                                        // When un-mounting, we need to remove the cache provider from the state
                                        // storage too because it's a side-effect. Otherwise, when re-mounting we
                                        // will not re-register those event listeners.
                                        config_context_client_x_C9_NWC_SWRGlobalState.delete(provider);
                                    };
                                }
                            }
                        };
                        initProvider();
                        // This is a new provider, we need to initialize it and setup DOM events
                        // listeners for `focus` and `reconnect` actions.
                        // We might want to inject an extra layer on top of `provider` in the future,
                        // such as key serialization, auto GC, etc.
                        // For now, it's just a `Map` interface without any modifications.
                        return [
                            provider,
                            mutate,
                            initProvider,
                            unmount
                        ];
                    }
                    return [
                        provider,
                        config_context_client_x_C9_NWC_SWRGlobalState.get(provider)[4]
                    ];
                };

                // error retry
                const onErrorRetry = (_, __, config, revalidate, opts) => {
                    const maxRetryCount = config.errorRetryCount;
                    const currentRetryCount = opts.retryCount;
                    // Exponential backoff
                    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
                    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
                        return;
                    }
                    setTimeout(revalidate, timeout, opts);
                };
                const compare = dequal;
                // Default cache provider
                const [config_context_client_x_C9_NWC_cache, mutate] = initCache(new Map());
                // Default config
                const defaultConfig = mergeObjects({
                        // events
                        onLoadingSlow: noop,
                        onSuccess: noop,
                        onError: noop,
                        onErrorRetry,
                        onDiscarded: noop,
                        // switches
                        revalidateOnFocus: true,
                        revalidateOnReconnect: true,
                        revalidateIfStale: true,
                        shouldRetryOnError: true,
                        // timeouts
                        errorRetryInterval: slowConnection ? 10000 : 5000,
                        focusThrottleInterval: 5 * 1000,
                        dedupingInterval: 2 * 1000,
                        loadingTimeout: slowConnection ? 5000 : 3000,
                        // providers
                        compare,
                        isPaused: () => false,
                        cache: config_context_client_x_C9_NWC_cache,
                        mutate,
                        fallback: {}
                    }, // use web preset by default
                    preset);

                const mergeConfigs = (a, b) => {
                    // Need to create a new object to avoid mutating the original here.
                    const v = mergeObjects(a, b);
                    // If two configs are provided, merge their `use` and `fallback` options.
                    if (b) {
                        const {
                            use: u1,
                            fallback: f1
                        } = a;
                        const {
                            use: u2,
                            fallback: f2
                        } = b;
                        if (u1 && u2) {
                            v.use = u1.concat(u2);
                        }
                        if (f1 && f2) {
                            v.fallback = mergeObjects(f1, f2);
                        }
                    }
                    return v;
                };

                const SWRConfigContext = (0, external_React_.createContext)({});
                const SWRConfig = (props) => {
                    const {
                        value
                    } = props;
                    const parentConfig = (0, external_React_.useContext)(SWRConfigContext);
                    const isFunctionalConfig = isFunction(value);
                    const config = (0, external_React_.useMemo)(() => isFunctionalConfig ? value(parentConfig) : value, [
                        isFunctionalConfig,
                        parentConfig,
                        value
                    ]);
                    // Extend parent context values and middleware.
                    const extendedConfig = (0, external_React_.useMemo)(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [
                        isFunctionalConfig,
                        parentConfig,
                        config
                    ]);
                    // Should not use the inherited provider.
                    const provider = config && config.provider;
                    // initialize the cache only on first access.
                    const cacheContextRef = (0, external_React_.useRef)(UNDEFINED);
                    if (provider && !cacheContextRef.current) {
                        cacheContextRef.current = initCache(provider(extendedConfig.cache || config_context_client_x_C9_NWC_cache), config);
                    }
                    const cacheContext = cacheContextRef.current;
                    // Override the cache if a new provider is given.
                    if (cacheContext) {
                        extendedConfig.cache = cacheContext[0];
                        extendedConfig.mutate = cacheContext[1];
                    }
                    // Unsubscribe events.
                    useIsomorphicLayoutEffect(() => {
                        if (cacheContext) {
                            cacheContext[2] && cacheContext[2]();
                            return cacheContext[3];
                        }
                    }, []);
                    return (0, external_React_.createElement)(SWRConfigContext.Provider, mergeObjects(props, {
                        value: extendedConfig
                    }));
                };



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swr@2.3.0_react@18.2.0/node_modules/swr/dist/_internal/index.mjs




                const INFINITE_PREFIX = '$inf$';

                // @ts-expect-error
                const enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
                const use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
                const setupDevTools = () => {
                    if (enableDevtools) {
                        // @ts-expect-error
                        window.__SWR_DEVTOOLS_REACT__ = external_React_;
                    }
                };

                const normalize = (args) => {
                    return isFunction(args[1]) ? [
                        args[0],
                        args[1],
                        args[2] || {}
                    ] : [
                        args[0],
                        null,
                        (args[1] === null ? args[2] : args[1]) || {}
                    ];
                };

                const useSWRConfig = () => {
                    return mergeObjects(defaultConfig, (0, external_React_.useContext)(SWRConfigContext));
                };

                const preload = (key_, fetcher) => {
                    const [key, fnArg] = serialize(key_);
                    const [, , , PRELOAD] = SWRGlobalState.get(cache);
                    // Prevent preload to be called multiple times before used.
                    if (PRELOAD[key]) return PRELOAD[key];
                    const req = fetcher(fnArg);
                    PRELOAD[key] = req;
                    return req;
                };
                const middleware = (useSWRNext) => (key_, fetcher_, config) => {
                    // fetcher might be a sync function, so this should not be an async function
                    const fetcher = fetcher_ && ((...args) => {
                        const [key] = config_context_client_x_C9_NWC_serialize(key_);
                        const [, , , PRELOAD] = config_context_client_x_C9_NWC_SWRGlobalState.get(config_context_client_x_C9_NWC_cache);
                        if (key.startsWith(INFINITE_PREFIX)) {
                            // we want the infinite fetcher to be called.
                            // handling of the PRELOAD cache happens there.
                            return fetcher_(...args);
                        }
                        const req = PRELOAD[key];
                        if (isUndefined(req)) return fetcher_(...args);
                        delete PRELOAD[key];
                        return req;
                    });
                    return useSWRNext(key_, fetcher, config);
                };

                const BUILT_IN_MIDDLEWARE = use.concat(middleware);

                // It's tricky to pass generic types as parameters, so we just directly override
                // the types here.
                const withArgs = (hook) => {
                    return function useSWRArgs(...args) {
                        // Get the default and inherited configuration.
                        const fallbackConfig = useSWRConfig();
                        // Normalize arguments.
                        const [key, fn, _config] = normalize(args);
                        // Merge configurations.
                        const config = mergeConfigs(fallbackConfig, _config);
                        // Apply middleware
                        let next = hook;
                        const {
                            use
                        } = config;
                        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);
                        for (let i = middleware.length; i--;) {
                            next = middleware[i](next);
                        }
                        return next(key, fn || config.fetcher || null, config);
                    };
                };

                // Add a callback function to a list of keyed callback functions and return
                // the unsubscribe function.
                const subscribeCallback = (key, callbacks, callback) => {
                    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
                    keyedRevalidators.push(callback);
                    return () => {
                        const index = keyedRevalidators.indexOf(callback);
                        if (index >= 0) {
                            // O(1): faster than splice
                            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];
                            keyedRevalidators.pop();
                        }
                    };
                };

                // Create a custom hook with a middleware
                const withMiddleware = (useSWR, middleware) => {
                    return (...args) => {
                        const [key, fn, config] = normalize(args);
                        const uses = (config.use || []).concat(middleware);
                        return useSWR(key, fn, {
                            ...config,
                            use: uses
                        });
                    };
                };

                setupDevTools();



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swr@2.3.0_react@18.2.0/node_modules/swr/dist/index/index.mjs





                // Shared state between server components and client components
                const index_noop = () => {};
                // Using noop() as the undefined value as undefined can be replaced
                // by something else. Prettier ignore and extra parentheses are necessary here
                // to ensure that tsc doesn't remove the __NOINLINE__ comment.
                // prettier-ignore
                const index_UNDEFINED = /*#__NOINLINE__*/ index_noop();
                const index_OBJECT = Object;
                const index_isUndefined = (v) => v === index_UNDEFINED;
                const index_isFunction = (v) => typeof v == 'function';

                // use WeakMap to store the object->key mapping
                // so the objects can be garbage collected.
                // WeakMap uses a hashtable under the hood, so the lookup
                // complexity is almost O(1).
                const index_table = new WeakMap();
                const index_isObjectType = (value, type) => index_OBJECT.prototype.toString.call(value) === `[object ${type}]`;
                // counter of the key
                let index_counter = 0;
                // A stable hash implementation that supports:
                // - Fast and ensures unique hash properties
                // - Handles unserializable values
                // - Handles object key ordering
                // - Generates short results
                //
                // This is not a serialization function, and the result is not guaranteed to be
                // parsable.
                const index_stableHash = (arg) => {
                    const type = typeof arg;
                    const isDate = index_isObjectType(arg, 'Date');
                    const isRegex = index_isObjectType(arg, 'RegExp');
                    const isPlainObject = index_isObjectType(arg, 'Object');
                    let result;
                    let index;
                    if (index_OBJECT(arg) === arg && !isDate && !isRegex) {
                        // Object/function, not null/date/regexp. Use WeakMap to store the id first.
                        // If it's already hashed, directly return the result.
                        result = index_table.get(arg);
                        if (result) return result;
                        // Store the hash first for circular reference detection before entering the
                        // recursive `stableHash` calls.
                        // For other objects like set and map, we use this id directly as the hash.
                        result = ++index_counter + '~';
                        index_table.set(arg, result);
                        if (Array.isArray(arg)) {
                            // Array.
                            result = '@';
                            for (index = 0; index < arg.length; index++) {
                                result += index_stableHash(arg[index]) + ',';
                            }
                            index_table.set(arg, result);
                        }
                        if (isPlainObject) {
                            // Object, sort keys.
                            result = '#';
                            const keys = index_OBJECT.keys(arg).sort();
                            while (!index_isUndefined(index = keys.pop())) {
                                if (!index_isUndefined(arg[index])) {
                                    result += index + ':' + index_stableHash(arg[index]) + ',';
                                }
                            }
                            index_table.set(arg, result);
                        }
                    } else {
                        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;
                    }
                    return result;
                };

                const index_serialize = (key) => {
                    if (index_isFunction(key)) {
                        try {
                            key = key();
                        } catch (err) {
                            // dependencies not ready
                            key = '';
                        }
                    }
                    // Use the original key as the argument of fetcher. This can be a string or an
                    // array of values.
                    const args = key;
                    // If key is not falsy, or not an empty array, hash it.
                    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? index_stableHash(key) : '';
                    return [
                        key,
                        args
                    ];
                };

                const unstable_serialize = (key) => index_serialize(key)[0];

                /// <reference types="react/experimental" />
                const index_use = external_React_.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
                    // and emitting an error.
                    // We assume that this is only for the `use(thenable)` case, not `use(context)`.
                    // https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
                    ((thenable) => {
                        switch (thenable.status) {
                            case 'pending':
                                throw thenable;
                            case 'fulfilled':
                                return thenable.value;
                            case 'rejected':
                                throw thenable.reason;
                            default:
                                thenable.status = 'pending';
                                thenable.then((v) => {
                                    thenable.status = 'fulfilled';
                                    thenable.value = v;
                                }, (e) => {
                                    thenable.status = 'rejected';
                                    thenable.reason = e;
                                });
                                throw thenable;
                        }
                    });
                const WITH_DEDUPE = {
                    dedupe: true
                };
                const useSWRHandler = (_key, fetcher, config) => {
                    const {
                        cache,
                        compare,
                        suspense,
                        fallbackData,
                        revalidateOnMount,
                        revalidateIfStale,
                        refreshInterval,
                        refreshWhenHidden,
                        refreshWhenOffline,
                        keepPreviousData
                    } = config;
                    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = config_context_client_x_C9_NWC_SWRGlobalState.get(cache);
                    // `key` is the identifier of the SWR internal state,
                    // `fnArg` is the argument/arguments parsed from the key, which will be passed
                    // to the fetcher.
                    // All of them are derived from `_key`.
                    const [key, fnArg] = config_context_client_x_C9_NWC_serialize(_key);
                    // If it's the initial render of this hook.
                    const initialMountedRef = (0, external_React_.useRef)(false);
                    // If the hook is unmounted already. This will be used to prevent some effects
                    // to be called after unmounting.
                    const unmountedRef = (0, external_React_.useRef)(false);
                    // Refs to keep the key and config.
                    const keyRef = (0, external_React_.useRef)(key);
                    const fetcherRef = (0, external_React_.useRef)(fetcher);
                    const configRef = (0, external_React_.useRef)(config);
                    const getConfig = () => configRef.current;
                    const isActive = () => getConfig().isVisible() && getConfig().isOnline();
                    const [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache, key);
                    const stateDependencies = (0, external_React_.useRef)({}).current;
                    // Resolve the fallback data from either the inline option, or the global provider.
                    // If it's a promise, we simply let React suspend and resolve it for us.
                    const fallback = isUndefined(fallbackData) ? isUndefined(config.fallback) ? UNDEFINED : config.fallback[key] : fallbackData;
                    const isEqual = (prev, current) => {
                        for (const _ in stateDependencies) {
                            const t = _;
                            if (t === 'data') {
                                if (!compare(prev[t], current[t])) {
                                    if (!isUndefined(prev[t])) {
                                        return false;
                                    }
                                    if (!compare(returnedData, current[t])) {
                                        return false;
                                    }
                                }
                            } else {
                                if (current[t] !== prev[t]) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    };
                    const getSnapshot = (0, external_React_.useMemo)(() => {
                        const shouldStartRequest = (() => {
                            if (!key) return false;
                            if (!fetcher) return false;
                            // If `revalidateOnMount` is set, we take the value directly.
                            if (!isUndefined(revalidateOnMount)) return revalidateOnMount;
                            // If it's paused, we skip revalidation.
                            if (getConfig().isPaused()) return false;
                            if (suspense) return false;
                            return revalidateIfStale !== false;
                        })();
                        // Get the cache and merge it with expected states.
                        const getSelectedCache = (state) => {
                            // We only select the needed fields from the state.
                            const snapshot = mergeObjects(state);
                            delete snapshot._k;
                            if (!shouldStartRequest) {
                                return snapshot;
                            }
                            return {
                                isValidating: true,
                                isLoading: true,
                                ...snapshot
                            };
                        };
                        const cachedData = getCache();
                        const initialData = getInitialCache();
                        const clientSnapshot = getSelectedCache(cachedData);
                        const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);
                        // To make sure that we are returning the same object reference to avoid
                        // unnecessary re-renders, we keep the previous snapshot and use deep
                        // comparison to check if we need to return a new one.
                        let memorizedSnapshot = clientSnapshot;
                        return [
                            () => {
                                const newSnapshot = getSelectedCache(getCache());
                                const compareResult = isEqual(newSnapshot, memorizedSnapshot);
                                if (compareResult) {
                                    // Mentally, we should always return the `memorizedSnapshot` here
                                    // as there's no change between the new and old snapshots.
                                    // However, since the `isEqual` function only compares selected fields,
                                    // the values of the unselected fields might be changed. That's
                                    // simply because we didn't track them.
                                    // To support the case in https://github.com/vercel/swr/pull/2576,
                                    // we need to update these fields in the `memorizedSnapshot` too
                                    // with direct mutations to ensure the snapshot is always up-to-date
                                    // even for the unselected fields, but only trigger re-renders when
                                    // the selected fields are changed.
                                    memorizedSnapshot.data = newSnapshot.data;
                                    memorizedSnapshot.isLoading = newSnapshot.isLoading;
                                    memorizedSnapshot.isValidating = newSnapshot.isValidating;
                                    memorizedSnapshot.error = newSnapshot.error;
                                    return memorizedSnapshot;
                                } else {
                                    memorizedSnapshot = newSnapshot;
                                    return newSnapshot;
                                }
                            },
                            () => serverSnapshot
                        ];
                        // eslint-disable-next-line react-hooks/exhaustive-deps
                    }, [
                        cache,
                        key
                    ]);
                    // Get the current state that SWR should return.
                    const cached = (0, shim.useSyncExternalStore)((0, external_React_.useCallback)((callback) => subscribeCache(key, (current, prev) => {
                            if (!isEqual(prev, current)) callback();
                        }), // eslint-disable-next-line react-hooks/exhaustive-deps
                        [
                            cache,
                            key
                        ]), getSnapshot[0], getSnapshot[1]);
                    const isInitialMount = !initialMountedRef.current;
                    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
                    const cachedData = cached.data;
                    const data = isUndefined(cachedData) ? fallback && isPromiseLike(fallback) ? index_use(fallback) : fallback : cachedData;
                    const error = cached.error;
                    // Use a ref to store previously returned data. Use the initial data as its initial value.
                    const laggyDataRef = (0, external_React_.useRef)(data);
                    const returnedData = keepPreviousData ? isUndefined(cachedData) ? laggyDataRef.current : cachedData : data;
                    // - Suspense mode and there's stale data for the initial render.
                    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.
                    // - `revalidateIfStale` is enabled but `data` is not defined.
                    const shouldDoInitialRevalidation = (() => {
                        // if a key already has revalidators and also has error, we should not trigger revalidation
                        if (hasRevalidator && !isUndefined(error)) return false;
                        // If `revalidateOnMount` is set, we take the value directly.
                        if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount;
                        // If it's paused, we skip revalidation.
                        if (getConfig().isPaused()) return false;
                        // Under suspense mode, it will always fetch on render if there is no
                        // stale data so no need to revalidate immediately mount it again.
                        // If data exists, only revalidate if `revalidateIfStale` is true.
                        if (suspense) return isUndefined(data) ? false : revalidateIfStale;
                        // If there is no stale data, we need to revalidate when mount;
                        // If `revalidateIfStale` is set to true, we will always revalidate.
                        return isUndefined(data) || revalidateIfStale;
                    })();
                    // Resolve the default validating state:
                    // If it's able to validate, and it should revalidate when mount, this will be true.
                    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);
                    const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
                    const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
                    // The revalidation function is a carefully crafted wrapper of the original
                    // `fetcher`, to correctly handle the many edge cases.
                    const revalidate = (0, external_React_.useCallback)(async (revalidateOpts) => {
                            const currentFetcher = fetcherRef.current;
                            if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
                                return false;
                            }
                            let newData;
                            let startAt;
                            let loading = true;
                            const opts = revalidateOpts || {};
                            // If there is no ongoing concurrent request, or `dedupe` is not set, a
                            // new request should be initiated.
                            const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
                            /*
         For React 17
         Do unmount check for calls:
         If key has changed during the revalidation, or the component has been
         unmounted, old dispatch and old event callbacks should not take any
         effect

        For React 18
        only check if key has changed
        https://github.com/reactwg/react-18/discussions/82
      */
                            const callbackSafeguard = () => {
                                if (IS_REACT_LEGACY) {
                                    return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
                                }
                                return key === keyRef.current;
                            };
                            // The final state object when the request finishes.
                            const finalState = {
                                isValidating: false,
                                isLoading: false
                            };
                            const finishRequestAndUpdateState = () => {
                                setCache(finalState);
                            };
                            const cleanupState = () => {
                                // Check if it's still the same request before deleting it.
                                const requestInfo = FETCH[key];
                                if (requestInfo && requestInfo[1] === startAt) {
                                    delete FETCH[key];
                                }
                            };
                            // Start fetching. Change the `isValidating` state, update the cache.
                            const initialState = {
                                isValidating: true
                            };
                            // It is in the `isLoading` state, if and only if there is no cached data.
                            // This bypasses fallback data and laggy data.
                            if (isUndefined(getCache().data)) {
                                initialState.isLoading = true;
                            }
                            try {
                                if (shouldStartNewRequest) {
                                    setCache(initialState);
                                    // If no cache is being rendered currently (it shows a blank page),
                                    // we trigger the loading slow event.
                                    if (config.loadingTimeout && isUndefined(getCache().data)) {
                                        setTimeout(() => {
                                            if (loading && callbackSafeguard()) {
                                                getConfig().onLoadingSlow(key, config);
                                            }
                                        }, config.loadingTimeout);
                                    }
                                    // Start the request and save the timestamp.
                                    // Key must be truthy if entering here.
                                    FETCH[key] = [
                                        currentFetcher(fnArg),
                                        getTimestamp()
                                    ];
                                }
                                // Wait until the ongoing request is done. Deduplication is also
                                // considered here.
                                ;
                                [newData, startAt] = FETCH[key];
                                newData = await newData;
                                if (shouldStartNewRequest) {
                                    // If the request isn't interrupted, clean it up after the
                                    // deduplication interval.
                                    setTimeout(cleanupState, config.dedupingInterval);
                                }
                                // If there're other ongoing request(s), started after the current one,
                                // we need to ignore the current one to avoid possible race conditions:
                                //   req1------------------>res1        (current one)
                                //        req2---------------->res2
                                // the request that fired later will always be kept.
                                // The timestamp maybe be `undefined` or a number
                                if (!FETCH[key] || FETCH[key][1] !== startAt) {
                                    if (shouldStartNewRequest) {
                                        if (callbackSafeguard()) {
                                            getConfig().onDiscarded(key);
                                        }
                                    }
                                    return false;
                                }
                                // Clear error.
                                finalState.error = UNDEFINED;
                                // If there're other mutations(s), that overlapped with the current revalidation:
                                // case 1:
                                //   req------------------>res
                                //       mutate------>end
                                // case 2:
                                //         req------------>res
                                //   mutate------>end
                                // case 3:
                                //   req------------------>res
                                //       mutate-------...---------->
                                // we have to ignore the revalidation result (res) because it's no longer fresh.
                                // meanwhile, a new revalidation should be triggered when the mutation ends.
                                const mutationInfo = MUTATION[key];
                                if (!isUndefined(mutationInfo) && // case 1
                                    (startAt <= mutationInfo[0] || // case 2
                                        startAt <= mutationInfo[1] || // case 3
                                        mutationInfo[1] === 0)) {
                                    finishRequestAndUpdateState();
                                    if (shouldStartNewRequest) {
                                        if (callbackSafeguard()) {
                                            getConfig().onDiscarded(key);
                                        }
                                    }
                                    return false;
                                }
                                // Deep compare with the latest state to avoid extra re-renders.
                                // For local state, compare and assign.
                                const cacheData = getCache().data;
                                // Since the compare fn could be custom fn
                                // cacheData might be different from newData even when compare fn returns True
                                finalState.data = compare(cacheData, newData) ? cacheData : newData;
                                // Trigger the successful callback if it's the original request.
                                if (shouldStartNewRequest) {
                                    if (callbackSafeguard()) {
                                        getConfig().onSuccess(newData, key, config);
                                    }
                                }
                            } catch (err) {
                                cleanupState();
                                const currentConfig = getConfig();
                                const {
                                    shouldRetryOnError
                                } = currentConfig;
                                // Not paused, we continue handling the error. Otherwise, discard it.
                                if (!currentConfig.isPaused()) {
                                    // Get a new error, don't use deep comparison for errors.
                                    finalState.error = err;
                                    // Error event and retry logic. Only for the actual request, not
                                    // deduped ones.
                                    if (shouldStartNewRequest && callbackSafeguard()) {
                                        currentConfig.onError(err, key, currentConfig);
                                        if (shouldRetryOnError === true || isFunction(shouldRetryOnError) && shouldRetryOnError(err)) {
                                            if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {
                                                // If it's inactive, stop. It will auto-revalidate when
                                                // refocusing or reconnecting.
                                                // When retrying, deduplication is always enabled.
                                                currentConfig.onErrorRetry(err, key, currentConfig, (_opts) => {
                                                    const revalidators = EVENT_REVALIDATORS[key];
                                                    if (revalidators && revalidators[0]) {
                                                        revalidators[0](events.ERROR_REVALIDATE_EVENT, _opts);
                                                    }
                                                }, {
                                                    retryCount: (opts.retryCount || 0) + 1,
                                                    dedupe: true
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                            // Mark loading as stopped.
                            loading = false;
                            // Update the current hook's state.
                            finishRequestAndUpdateState();
                            return true;
                        }, // `setState` is immutable, and `eventsCallback`, `fnArg`, and
                        // `keyValidating` are depending on `key`, so we can exclude them from
                        // the deps array.
                        //
                        // FIXME:
                        // `fn` and `config` might be changed during the lifecycle,
                        // but they might be changed every render like this.
                        // `useSWR('key', () => fetch('/api/'), { suspense: true })`
                        // So we omit the values from the deps array
                        // even though it might cause unexpected behaviors.
                        // eslint-disable-next-line react-hooks/exhaustive-deps
                        [
                            key,
                            cache
                        ]);
                    // Similar to the global mutate but bound to the current cache and key.
                    // `cache` isn't allowed to change during the lifecycle.
                    const boundMutate = (0, external_React_.useCallback)( // Use callback to make sure `keyRef.current` returns latest result every time
                        (...args) => {
                            return internalMutate(cache, keyRef.current, ...args);
                        }, // eslint-disable-next-line react-hooks/exhaustive-deps
                        []);
                    // The logic for updating refs.
                    useIsomorphicLayoutEffect(() => {
                        fetcherRef.current = fetcher;
                        configRef.current = config;
                        // Handle laggy data updates. If there's cached data of the current key,
                        // it'll be the correct reference.
                        if (!isUndefined(cachedData)) {
                            laggyDataRef.current = cachedData;
                        }
                    });
                    // After mounted or key changed.
                    useIsomorphicLayoutEffect(() => {
                        if (!key) return;
                        const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
                        // Expose revalidators to global event listeners. So we can trigger
                        // revalidation from the outside.
                        let nextFocusRevalidatedAt = 0;
                        const onRevalidate = (type, opts = {}) => {
                            if (type == events.FOCUS_EVENT) {
                                const now = Date.now();
                                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {
                                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;
                                    softRevalidate();
                                }
                            } else if (type == events.RECONNECT_EVENT) {
                                if (getConfig().revalidateOnReconnect && isActive()) {
                                    softRevalidate();
                                }
                            } else if (type == events.MUTATE_EVENT) {
                                return revalidate();
                            } else if (type == events.ERROR_REVALIDATE_EVENT) {
                                return revalidate(opts);
                            }
                            return;
                        };
                        const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
                        // Mark the component as mounted and update corresponding refs.
                        unmountedRef.current = false;
                        keyRef.current = key;
                        initialMountedRef.current = true;
                        // Keep the original key in the cache.
                        setCache({
                            _k: fnArg
                        });
                        // Trigger a revalidation
                        if (shouldDoInitialRevalidation) {
                            if (isUndefined(data) || IS_SERVER) {
                                // Revalidate immediately.
                                softRevalidate();
                            } else {
                                // Delay the revalidate if we have data to return so we won't block
                                // rendering.
                                rAF(softRevalidate);
                            }
                        }
                        return () => {
                            // Mark it as unmounted.
                            unmountedRef.current = true;
                            unsubEvents();
                        };
                    }, [
                        key
                    ]);
                    // Polling
                    useIsomorphicLayoutEffect(() => {
                        let timer;

                        function next() {
                            // Use the passed interval
                            // ...or invoke the function with the updated data to get the interval
                            const interval = isFunction(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;
                            // We only start the next interval if `refreshInterval` is not 0, and:
                            // - `force` is true, which is the start of polling
                            // - or `timer` is not 0, which means the effect wasn't canceled
                            if (interval && timer !== -1) {
                                timer = setTimeout(execute, interval);
                            }
                        }

                        function execute() {
                            // Check if it's OK to execute:
                            // Only revalidate when the page is visible, online, and not errored.
                            if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
                                revalidate(WITH_DEDUPE).then(next);
                            } else {
                                // Schedule the next interval to check again.
                                next();
                            }
                        }
                        next();
                        return () => {
                            if (timer) {
                                clearTimeout(timer);
                                timer = -1;
                            }
                        };
                    }, [
                        refreshInterval,
                        refreshWhenHidden,
                        refreshWhenOffline,
                        key
                    ]);
                    // Display debug info in React DevTools.
                    (0, external_React_.useDebugValue)(returnedData);
                    // In Suspense mode, we can't return the empty `data` state.
                    // If there is an `error`, the `error` needs to be thrown to the error boundary.
                    // If there is no `error`, the `revalidation` promise needs to be thrown to
                    // the suspense boundary.
                    if (suspense && isUndefined(data) && key) {
                        // SWR should throw when trying to use Suspense on the server with React 18,
                        // without providing any fallback data. This causes hydration errors. See:
                        // https://github.com/vercel/swr/issues/1832
                        if (!IS_REACT_LEGACY && IS_SERVER) {
                            throw new Error('Fallback data is required when using Suspense in SSR.');
                        }
                        // Always update fetcher and config refs even with the Suspense mode.
                        fetcherRef.current = fetcher;
                        configRef.current = config;
                        unmountedRef.current = false;
                        const req = PRELOAD[key];
                        if (!isUndefined(req)) {
                            const promise = boundMutate(req);
                            index_use(promise);
                        }
                        if (isUndefined(error)) {
                            const promise = revalidate(WITH_DEDUPE);
                            if (!isUndefined(returnedData)) {
                                promise.status = 'fulfilled';
                                promise.value = true;
                            }
                            index_use(promise);
                        } else {
                            throw error;
                        }
                    }
                    return {
                        mutate: boundMutate,
                        get data() {
                            stateDependencies.data = true;
                            return returnedData;
                        },
                        get error() {
                            stateDependencies.error = true;
                            return error;
                        },
                        get isValidating() {
                            stateDependencies.isValidating = true;
                            return isValidating;
                        },
                        get isLoading() {
                            stateDependencies.isLoading = true;
                            return isLoading;
                        }
                    };
                };
                const index_SWRConfig = OBJECT.defineProperty(SWRConfig, 'defaultValue', {
                    value: defaultConfig
                });
                /**
                 * A hook to fetch data.
                 *
                 * @link https://swr.vercel.app
                 * @example
                 * ```jsx
                 * import useSWR from 'swr'
                 * function Profile() {
                 *   const { data, error, isLoading } = useSWR('/api/user', fetcher)
                 *   if (error) return <div>failed to load</div>
                 *   if (isLoading) return <div>loading...</div>
                 *   return <div>hello {data.name}!</div>
                 * }
                 * ```
                 */
                const useSWR = withArgs(useSWRHandler);

                // useSWR



                // EXTERNAL MODULE: ./src/apis/index.ts + 50 modules
                var apis = __webpack_require__("FWOm");; // CONCATENATED MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
                /*
                 *      bignumber.js v9.1.2
                 *      A JavaScript library for arbitrary-precision arithmetic.
                 *      https://github.com/MikeMcl/bignumber.js
                 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
                 *      MIT Licensed.
                 *
                 *      BigNumber.prototype methods     |  BigNumber methods
                 *                                      |
                 *      absoluteValue            abs    |  clone
                 *      comparedTo                      |  config               set
                 *      decimalPlaces            dp     |      DECIMAL_PLACES
                 *      dividedBy                div    |      ROUNDING_MODE
                 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
                 *      exponentiatedBy          pow    |      RANGE
                 *      integerValue                    |      CRYPTO
                 *      isEqualTo                eq     |      MODULO_MODE
                 *      isFinite                        |      POW_PRECISION
                 *      isGreaterThan            gt     |      FORMAT
                 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
                 *      isInteger                       |  isBigNumber
                 *      isLessThan               lt     |  maximum              max
                 *      isLessThanOrEqualTo      lte    |  minimum              min
                 *      isNaN                           |  random
                 *      isNegative                      |  sum
                 *      isPositive                      |
                 *      isZero                          |
                 *      minus                           |
                 *      modulo                   mod    |
                 *      multipliedBy             times  |
                 *      negated                         |
                 *      plus                            |
                 *      precision                sd     |
                 *      shiftedBy                       |
                 *      squareRoot               sqrt   |
                 *      toExponential                   |
                 *      toFixed                         |
                 *      toFormat                        |
                 *      toFraction                      |
                 *      toJSON                          |
                 *      toNumber                        |
                 *      toPrecision                     |
                 *      toString                        |
                 *      valueOf                         |
                 *
                 */


                var
                    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
                    mathceil = Math.ceil,
                    mathfloor = Math.floor,

                    bignumberError = '[BigNumber Error] ',
                    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

                    BASE = 1e14,
                    LOG_BASE = 14,
                    MAX_SAFE_INTEGER = 0x1fffffffffffff, // 2^53 - 1
                    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
                    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
                    SQRT_BASE = 1e7,

                    // EDITABLE
                    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
                    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
                    MAX = 1E9; // 0 to MAX_INT32


                /*
                 * Create and return a BigNumber constructor.
                 */
                function clone(configObject) {
                    var div, convertBase, parseNumeric,
                        P = BigNumber.prototype = {
                            constructor: BigNumber,
                            toString: null,
                            valueOf: null
                        },
                        ONE = new BigNumber(1),


                        //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


                        // The default values below must be integers within the inclusive ranges stated.
                        // The values can also be changed at run-time using BigNumber.set.

                        // The maximum number of decimal places for operations involving division.
                        DECIMAL_PLACES = 20, // 0 to MAX

                        // The rounding mode used when rounding to the above decimal places, and when using
                        // toExponential, toFixed, toFormat and toPrecision, and round (default value).
                        // UP         0 Away from zero.
                        // DOWN       1 Towards zero.
                        // CEIL       2 Towards +Infinity.
                        // FLOOR      3 Towards -Infinity.
                        // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
                        // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
                        // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
                        // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
                        // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
                        ROUNDING_MODE = 4, // 0 to 8

                        // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

                        // The exponent value at and beneath which toString returns exponential notation.
                        // Number type: -7
                        TO_EXP_NEG = -7, // 0 to -MAX

                        // The exponent value at and above which toString returns exponential notation.
                        // Number type: 21
                        TO_EXP_POS = 21, // 0 to MAX

                        // RANGE : [MIN_EXP, MAX_EXP]

                        // The minimum exponent value, beneath which underflow to zero occurs.
                        // Number type: -324  (5e-324)
                        MIN_EXP = -1e7, // -1 to -MAX

                        // The maximum exponent value, above which overflow to Infinity occurs.
                        // Number type:  308  (1.7976931348623157e+308)
                        // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
                        MAX_EXP = 1e7, // 1 to MAX

                        // Whether to use cryptographically-secure random number generation, if available.
                        CRYPTO = false, // true or false

                        // The modulo mode used when calculating the modulus: a mod n.
                        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
                        // The remainder (r) is calculated as: r = a - n * q.
                        //
                        // UP        0 The remainder is positive if the dividend is negative, else is negative.
                        // DOWN      1 The remainder has the same sign as the dividend.
                        //             This modulo mode is commonly known as 'truncated division' and is
                        //             equivalent to (a % n) in JavaScript.
                        // FLOOR     3 The remainder has the same sign as the divisor (Python %).
                        // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
                        // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
                        //             The remainder is always positive.
                        //
                        // The truncated division, floored division, Euclidian division and IEEE 754 remainder
                        // modes are commonly used for the modulus operation.
                        // Although the other rounding modes can also be used, they may not give useful results.
                        MODULO_MODE = 1, // 0 to 9

                        // The maximum number of significant digits of the result of the exponentiatedBy operation.
                        // If POW_PRECISION is 0, there will be unlimited significant digits.
                        POW_PRECISION = 0, // 0 to MAX

                        // The format specification used by the BigNumber.prototype.toFormat method.
                        FORMAT = {
                            prefix: '',
                            groupSize: 3,
                            secondaryGroupSize: 0,
                            groupSeparator: ',',
                            decimalSeparator: '.',
                            fractionGroupSize: 0,
                            fractionGroupSeparator: '\xA0', // non-breaking space
                            suffix: ''
                        },

                        // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
                        // '-', '.', whitespace, or repeated character.
                        // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
                        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
                        alphabetHasNormalDecimalDigits = true;


                    //------------------------------------------------------------------------------------------


                    // CONSTRUCTOR


                    /*
                     * The BigNumber constructor and exported function.
                     * Create and return a new instance of a BigNumber object.
                     *
                     * v {number|string|BigNumber} A numeric value.
                     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
                     */
                    function BigNumber(v, b) {
                        var alphabet, c, caseChanged, e, i, isNum, len, str,
                            x = this;

                        // Enable constructor call without `new`.
                        if (!(x instanceof BigNumber)) return new BigNumber(v, b);

                        if (b == null) {

                            if (v && v._isBigNumber === true) {
                                x.s = v.s;

                                if (!v.c || v.e > MAX_EXP) {
                                    x.c = x.e = null;
                                } else if (v.e < MIN_EXP) {
                                    x.c = [x.e = 0];
                                } else {
                                    x.e = v.e;
                                    x.c = v.c.slice();
                                }

                                return;
                            }

                            if ((isNum = typeof v == 'number') && v * 0 == 0) {

                                // Use `1 / n` to handle minus zero also.
                                x.s = 1 / v < 0 ? (v = -v, -1) : 1;

                                // Fast path for integers, where n < 2147483648 (2**31).
                                if (v === ~~v) {
                                    for (e = 0, i = v; i >= 10; i /= 10, e++);

                                    if (e > MAX_EXP) {
                                        x.c = x.e = null;
                                    } else {
                                        x.e = e;
                                        x.c = [v];
                                    }

                                    return;
                                }

                                str = String(v);
                            } else {

                                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

                                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                            }

                            // Decimal point?
                            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

                            // Exponential form?
                            if ((i = str.search(/e/i)) > 0) {

                                // Determine exponent.
                                if (e < 0) e = i;
                                e += +str.slice(i + 1);
                                str = str.substring(0, i);
                            } else if (e < 0) {

                                // Integer.
                                e = str.length;
                            }

                        } else {

                            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                            intCheck(b, 2, ALPHABET.length, 'Base');

                            // Allow exponential notation to be used with base 10 argument, while
                            // also rounding to DECIMAL_PLACES as with other bases.
                            if (b == 10 && alphabetHasNormalDecimalDigits) {
                                x = new BigNumber(v);
                                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                            }

                            str = String(v);

                            if (isNum = typeof v == 'number') {

                                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

                                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

                                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                                if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                                    throw Error(tooManyDigits + v);
                                }
                            } else {
                                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                            }

                            alphabet = ALPHABET.slice(0, b);
                            e = i = 0;

                            // Check that str is a valid base b number.
                            // Don't use RegExp, so alphabet can contain special characters.
                            for (len = str.length; i < len; i++) {
                                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                                    if (c == '.') {

                                        // If '.' is not the first character and it has not be found before.
                                        if (i > e) {
                                            e = len;
                                            continue;
                                        }
                                    } else if (!caseChanged) {

                                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                                        if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                                            str == str.toLowerCase() && (str = str.toUpperCase())) {
                                            caseChanged = true;
                                            i = -1;
                                            e = 0;
                                            continue;
                                        }
                                    }

                                    return parseNumeric(x, String(v), isNum, b);
                                }
                            }

                            // Prevent later check for length on converted number.
                            isNum = false;
                            str = convertBase(str, b, 10, x.s);

                            // Decimal point?
                            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                            else e = str.length;
                        }

                        // Determine leading zeros.
                        for (i = 0; str.charCodeAt(i) === 48; i++);

                        // Determine trailing zeros.
                        for (len = str.length; str.charCodeAt(--len) === 48;);

                        if (str = str.slice(i, ++len)) {
                            len -= i;

                            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                            if (isNum && BigNumber.DEBUG &&
                                len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                                throw Error(tooManyDigits + (x.s * v));
                            }

                            // Overflow?
                            if ((e = e - i - 1) > MAX_EXP) {

                                // Infinity.
                                x.c = x.e = null;

                                // Underflow?
                            } else if (e < MIN_EXP) {

                                // Zero.
                                x.c = [x.e = 0];
                            } else {
                                x.e = e;
                                x.c = [];

                                // Transform base

                                // e is the base 10 exponent.
                                // i is where to slice str to get the first element of the coefficient array.
                                i = (e + 1) % LOG_BASE;
                                if (e < 0) i += LOG_BASE; // i < 1

                                if (i < len) {
                                    if (i) x.c.push(+str.slice(0, i));

                                    for (len -= LOG_BASE; i < len;) {
                                        x.c.push(+str.slice(i, i += LOG_BASE));
                                    }

                                    i = LOG_BASE - (str = str.slice(i)).length;
                                } else {
                                    i -= len;
                                }

                                for (; i--; str += '0');
                                x.c.push(+str);
                            }
                        } else {

                            // Zero.
                            x.c = [x.e = 0];
                        }
                    }


                    // CONSTRUCTOR PROPERTIES


                    BigNumber.clone = clone;

                    BigNumber.ROUND_UP = 0;
                    BigNumber.ROUND_DOWN = 1;
                    BigNumber.ROUND_CEIL = 2;
                    BigNumber.ROUND_FLOOR = 3;
                    BigNumber.ROUND_HALF_UP = 4;
                    BigNumber.ROUND_HALF_DOWN = 5;
                    BigNumber.ROUND_HALF_EVEN = 6;
                    BigNumber.ROUND_HALF_CEIL = 7;
                    BigNumber.ROUND_HALF_FLOOR = 8;
                    BigNumber.EUCLID = 9;


                    /*
                     * Configure infrequently-changing library-wide settings.
                     *
                     * Accept an object with the following optional properties (if the value of a property is
                     * a number, it must be an integer within the inclusive range stated):
                     *
                     *   DECIMAL_PLACES   {number}           0 to MAX
                     *   ROUNDING_MODE    {number}           0 to 8
                     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
                     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
                     *   CRYPTO           {boolean}          true or false
                     *   MODULO_MODE      {number}           0 to 9
                     *   POW_PRECISION       {number}           0 to MAX
                     *   ALPHABET         {string}           A string of two or more unique characters which does
                     *                                       not contain '.'.
                     *   FORMAT           {object}           An object with some of the following properties:
                     *     prefix                 {string}
                     *     groupSize              {number}
                     *     secondaryGroupSize     {number}
                     *     groupSeparator         {string}
                     *     decimalSeparator       {string}
                     *     fractionGroupSize      {number}
                     *     fractionGroupSeparator {string}
                     *     suffix                 {string}
                     *
                     * (The values assigned to the above FORMAT object properties are not checked for validity.)
                     *
                     * E.g.
                     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
                     *
                     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
                     *
                     * Return an object with the properties current values.
                     */
                    BigNumber.config = BigNumber.set = function(obj) {
                        var p, v;

                        if (obj != null) {

                            if (typeof obj == 'object') {

                                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                                // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                                if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                                    v = obj[p];
                                    intCheck(v, 0, MAX, p);
                                    DECIMAL_PLACES = v;
                                }

                                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                                // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                                if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                                    v = obj[p];
                                    intCheck(v, 0, 8, p);
                                    ROUNDING_MODE = v;
                                }

                                // EXPONENTIAL_AT {number|number[]}
                                // Integer, -MAX to MAX inclusive or
                                // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                                // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                                if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                                    v = obj[p];
                                    if (v && v.pop) {
                                        intCheck(v[0], -MAX, 0, p);
                                        intCheck(v[1], 0, MAX, p);
                                        TO_EXP_NEG = v[0];
                                        TO_EXP_POS = v[1];
                                    } else {
                                        intCheck(v, -MAX, MAX, p);
                                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                                    }
                                }

                                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                                // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                                if (obj.hasOwnProperty(p = 'RANGE')) {
                                    v = obj[p];
                                    if (v && v.pop) {
                                        intCheck(v[0], -MAX, -1, p);
                                        intCheck(v[1], 1, MAX, p);
                                        MIN_EXP = v[0];
                                        MAX_EXP = v[1];
                                    } else {
                                        intCheck(v, -MAX, MAX, p);
                                        if (v) {
                                            MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                                        } else {
                                            throw Error(bignumberError + p + ' cannot be zero: ' + v);
                                        }
                                    }
                                }

                                // CRYPTO {boolean} true or false.
                                // '[BigNumber Error] CRYPTO not true or false: {v}'
                                // '[BigNumber Error] crypto unavailable'
                                if (obj.hasOwnProperty(p = 'CRYPTO')) {
                                    v = obj[p];
                                    if (v === !!v) {
                                        if (v) {
                                            if (typeof crypto != 'undefined' && crypto &&
                                                (crypto.getRandomValues || crypto.randomBytes)) {
                                                CRYPTO = v;
                                            } else {
                                                CRYPTO = !v;
                                                throw Error(bignumberError + 'crypto unavailable');
                                            }
                                        } else {
                                            CRYPTO = v;
                                        }
                                    } else {
                                        throw Error(bignumberError + p + ' not true or false: ' + v);
                                    }
                                }

                                // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                                // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                                if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                                    v = obj[p];
                                    intCheck(v, 0, 9, p);
                                    MODULO_MODE = v;
                                }

                                // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                                // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                                if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                                    v = obj[p];
                                    intCheck(v, 0, MAX, p);
                                    POW_PRECISION = v;
                                }

                                // FORMAT {object}
                                // '[BigNumber Error] FORMAT not an object: {v}'
                                if (obj.hasOwnProperty(p = 'FORMAT')) {
                                    v = obj[p];
                                    if (typeof v == 'object') FORMAT = v;
                                    else throw Error(bignumberError + p + ' not an object: ' + v);
                                }

                                // ALPHABET {string}
                                // '[BigNumber Error] ALPHABET invalid: {v}'
                                if (obj.hasOwnProperty(p = 'ALPHABET')) {
                                    v = obj[p];

                                    // Disallow if less than two characters,
                                    // or if it contains '+', '-', '.', whitespace, or a repeated character.
                                    if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                                        ALPHABET = v;
                                    } else {
                                        throw Error(bignumberError + p + ' invalid: ' + v);
                                    }
                                }

                            } else {

                                // '[BigNumber Error] Object expected: {v}'
                                throw Error(bignumberError + 'Object expected: ' + obj);
                            }
                        }

                        return {
                            DECIMAL_PLACES: DECIMAL_PLACES,
                            ROUNDING_MODE: ROUNDING_MODE,
                            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                            RANGE: [MIN_EXP, MAX_EXP],
                            CRYPTO: CRYPTO,
                            MODULO_MODE: MODULO_MODE,
                            POW_PRECISION: POW_PRECISION,
                            FORMAT: FORMAT,
                            ALPHABET: ALPHABET
                        };
                    };


                    /*
                     * Return true if v is a BigNumber instance, otherwise return false.
                     *
                     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
                     *
                     * v {any}
                     *
                     * '[BigNumber Error] Invalid BigNumber: {v}'
                     */
                    BigNumber.isBigNumber = function(v) {
                        if (!v || v._isBigNumber !== true) return false;
                        if (!BigNumber.DEBUG) return true;

                        var i, n,
                            c = v.c,
                            e = v.e,
                            s = v.s;

                        out: if ({}.toString.call(c) == '[object Array]') {

                            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

                                // If the first element is zero, the BigNumber value must be zero.
                                if (c[0] === 0) {
                                    if (e === 0 && c.length === 1) return true;
                                    break out;
                                }

                                // Calculate number of digits that c[0] should have, based on the exponent.
                                i = (e + 1) % LOG_BASE;
                                if (i < 1) i += LOG_BASE;

                                // Calculate number of digits of c[0].
                                //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                                if (String(c[0]).length == i) {

                                    for (i = 0; i < c.length; i++) {
                                        n = c[i];
                                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                                    }

                                    // Last element cannot be zero, unless it is the only element.
                                    if (n !== 0) return true;
                                }
                            }

                            // Infinity/NaN
                        } else
                        if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                            return true;
                        }

                        throw Error(bignumberError + 'Invalid BigNumber: ' + v);
                    };


                    /*
                     * Return a new BigNumber whose value is the maximum of the arguments.
                     *
                     * arguments {number|string|BigNumber}
                     */
                    BigNumber.maximum = BigNumber.max = function() {
                        return maxOrMin(arguments, -1);
                    };


                    /*
                     * Return a new BigNumber whose value is the minimum of the arguments.
                     *
                     * arguments {number|string|BigNumber}
                     */
                    BigNumber.minimum = BigNumber.min = function() {
                        return maxOrMin(arguments, 1);
                    };


                    /*
                     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
                     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
                     * zeros are produced).
                     *
                     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
                     * '[BigNumber Error] crypto unavailable'
                     */
                    BigNumber.random = (function() {
                        var pow2_53 = 0x20000000000000;

                        // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
                        // Check if Math.random() produces more than 32 bits of randomness.
                        // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
                        // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
                        var random53bitInt = (Math.random() * pow2_53) & 0x1fffff ?
                            function() {
                                return mathfloor(Math.random() * pow2_53);
                            } :
                            function() {
                                return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                                    (Math.random() * 0x800000 | 0);
                            };

                        return function(dp) {
                            var a, b, e, k, v,
                                i = 0,
                                c = [],
                                rand = new BigNumber(ONE);

                            if (dp == null) dp = DECIMAL_PLACES;
                            else intCheck(dp, 0, MAX);

                            k = mathceil(dp / LOG_BASE);

                            if (CRYPTO) {

                                // Browsers supporting crypto.getRandomValues.
                                if (crypto.getRandomValues) {

                                    a = crypto.getRandomValues(new Uint32Array(k *= 2));

                                    for (; i < k;) {

                                        // 53 bits:
                                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                                        //                                     11111 11111111 11111111
                                        // 0x20000 is 2^21.
                                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                                        // Rejection sampling:
                                        // 0 <= v < 9007199254740992
                                        // Probability that v >= 9e15, is
                                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                                        if (v >= 9e15) {
                                            b = crypto.getRandomValues(new Uint32Array(2));
                                            a[i] = b[0];
                                            a[i + 1] = b[1];
                                        } else {

                                            // 0 <= v <= 8999999999999999
                                            // 0 <= (v % 1e14) <= 99999999999999
                                            c.push(v % 1e14);
                                            i += 2;
                                        }
                                    }
                                    i = k / 2;

                                    // Node.js supporting crypto.randomBytes.
                                } else if (crypto.randomBytes) {

                                    // buffer
                                    a = crypto.randomBytes(k *= 7);

                                    for (; i < k;) {

                                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                                        // 0x100000000 is 2^32, 0x1000000 is 2^24
                                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                                        // 0 <= v < 9007199254740992
                                        v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                                            (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                                            (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

                                        if (v >= 9e15) {
                                            crypto.randomBytes(7).copy(a, i);
                                        } else {

                                            // 0 <= (v % 1e14) <= 99999999999999
                                            c.push(v % 1e14);
                                            i += 7;
                                        }
                                    }
                                    i = k / 7;
                                } else {
                                    CRYPTO = false;
                                    throw Error(bignumberError + 'crypto unavailable');
                                }
                            }

                            // Use Math.random.
                            if (!CRYPTO) {

                                for (; i < k;) {
                                    v = random53bitInt();
                                    if (v < 9e15) c[i++] = v % 1e14;
                                }
                            }

                            k = c[--i];
                            dp %= LOG_BASE;

                            // Convert trailing digits to zeros according to dp.
                            if (k && dp) {
                                v = POWS_TEN[LOG_BASE - dp];
                                c[i] = mathfloor(k / v) * v;
                            }

                            // Remove trailing elements which are zero.
                            for (; c[i] === 0; c.pop(), i--);

                            // Zero?
                            if (i < 0) {
                                c = [e = 0];
                            } else {

                                // Remove leading elements which are zero and adjust exponent accordingly.
                                for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                                // Count the digits of the first element of c to determine leading zeros, and...
                                for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

                                // adjust the exponent accordingly.
                                if (i < LOG_BASE) e -= LOG_BASE - i;
                            }

                            rand.e = e;
                            rand.c = c;
                            return rand;
                        };
                    })();


                    /*
                     * Return a BigNumber whose value is the sum of the arguments.
                     *
                     * arguments {number|string|BigNumber}
                     */
                    BigNumber.sum = function() {
                        var i = 1,
                            args = arguments,
                            sum = new BigNumber(args[0]);
                        for (; i < args.length;) sum = sum.plus(args[i++]);
                        return sum;
                    };


                    // PRIVATE FUNCTIONS


                    // Called by BigNumber and BigNumber.prototype.toString.
                    convertBase = (function() {
                        var decimal = '0123456789';

                        /*
                         * Convert string of baseIn to an array of numbers of baseOut.
                         * Eg. toBaseOut('255', 10, 16) returns [15, 15].
                         * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
                         */
                        function toBaseOut(str, baseIn, baseOut, alphabet) {
                            var j,
                                arr = [0],
                                arrL,
                                i = 0,
                                len = str.length;

                            for (; i < len;) {
                                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

                                arr[0] += alphabet.indexOf(str.charAt(i++));

                                for (j = 0; j < arr.length; j++) {

                                    if (arr[j] > baseOut - 1) {
                                        if (arr[j + 1] == null) arr[j + 1] = 0;
                                        arr[j + 1] += arr[j] / baseOut | 0;
                                        arr[j] %= baseOut;
                                    }
                                }
                            }

                            return arr.reverse();
                        }

                        // Convert a numeric string of baseIn to a numeric string of baseOut.
                        // If the caller is toString, we are converting from base 10 to baseOut.
                        // If the caller is BigNumber, we are converting from baseIn to base 10.
                        return function(str, baseIn, baseOut, sign, callerIsToString) {
                            var alphabet, d, e, k, r, x, xc, y,
                                i = str.indexOf('.'),
                                dp = DECIMAL_PLACES,
                                rm = ROUNDING_MODE;

                            // Non-integer.
                            if (i >= 0) {
                                k = POW_PRECISION;

                                // Unlimited precision.
                                POW_PRECISION = 0;
                                str = str.replace('.', '');
                                y = new BigNumber(baseIn);
                                x = y.pow(str.length - i);
                                POW_PRECISION = k;

                                // Convert str as if an integer, then restore the fraction part by dividing the
                                // result by its base raised to a power.

                                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
                                    10, baseOut, decimal);
                                y.e = y.c.length;
                            }

                            // Convert the number as integer.

                            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ?
                                (alphabet = ALPHABET, decimal) :
                                (alphabet = decimal, ALPHABET));

                            // xc now represents str as an integer and converted to baseOut. e is the exponent.
                            e = k = xc.length;

                            // Remove trailing zeros.
                            for (; xc[--k] == 0; xc.pop());

                            // Zero?
                            if (!xc[0]) return alphabet.charAt(0);

                            // Does str represent an integer? If so, no need for the division.
                            if (i < 0) {
                                --e;
                            } else {
                                x.c = xc;
                                x.e = e;

                                // The sign is needed for correct rounding.
                                x.s = sign;
                                x = div(x, y, dp, rm, baseOut);
                                xc = x.c;
                                r = x.r;
                                e = x.e;
                            }

                            // xc now represents str converted to baseOut.

                            // THe index of the rounding digit.
                            d = e + dp + 1;

                            // The rounding digit: the digit to the right of the digit that may be rounded up.
                            i = xc[d];

                            // Look at the rounding digits and mode to determine whether to round up.

                            k = baseOut / 2;
                            r = r || d < 0 || xc[d + 1] != null;

                            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) :
                                i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                                    rm == (x.s < 0 ? 8 : 7));

                            // If the index of the rounding digit is not greater than zero, or xc represents
                            // zero, then the result of the base conversion is zero or, if rounding up, a value
                            // such as 0.00001.
                            if (d < 1 || !xc[0]) {

                                // 1^-dp or 0
                                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                            } else {

                                // Truncate xc to the required number of decimal places.
                                xc.length = d;

                                // Round up?
                                if (r) {

                                    // Rounding up may mean the previous digit has to be rounded up and so on.
                                    for (--baseOut; ++xc[--d] > baseOut;) {
                                        xc[d] = 0;

                                        if (!d) {
                                            ++e;
                                            xc = [1].concat(xc);
                                        }
                                    }
                                }

                                // Determine trailing zeros.
                                for (k = xc.length; !xc[--k];);

                                // E.g. [4, 11, 15] becomes 4bf.
                                for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

                                // Add leading zeros, decimal point and trailing zeros as required.
                                str = toFixedPoint(str, e, alphabet.charAt(0));
                            }

                            // The caller will add the sign.
                            return str;
                        };
                    })();


                    // Perform division in the specified base. Called by div and convertBase.
                    div = (function() {

                        // Assume non-zero x and k.
                        function multiply(x, k, base) {
                            var m, temp, xlo, xhi,
                                carry = 0,
                                i = x.length,
                                klo = k % SQRT_BASE,
                                khi = k / SQRT_BASE | 0;

                            for (x = x.slice(); i--;) {
                                xlo = x[i] % SQRT_BASE;
                                xhi = x[i] / SQRT_BASE | 0;
                                m = khi * xlo + xhi * klo;
                                temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
                                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                                x[i] = temp % base;
                            }

                            if (carry) x = [carry].concat(x);

                            return x;
                        }

                        function compare(a, b, aL, bL) {
                            var i, cmp;

                            if (aL != bL) {
                                cmp = aL > bL ? 1 : -1;
                            } else {

                                for (i = cmp = 0; i < aL; i++) {

                                    if (a[i] != b[i]) {
                                        cmp = a[i] > b[i] ? 1 : -1;
                                        break;
                                    }
                                }
                            }

                            return cmp;
                        }

                        function subtract(a, b, aL, base) {
                            var i = 0;

                            // Subtract b from a.
                            for (; aL--;) {
                                a[aL] -= i;
                                i = a[aL] < b[aL] ? 1 : 0;
                                a[aL] = i * base + a[aL] - b[aL];
                            }

                            // Remove leading zeros.
                            for (; !a[0] && a.length > 1; a.splice(0, 1));
                        }

                        // x: dividend, y: divisor.
                        return function(x, y, dp, rm, base) {
                            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                                yL, yz,
                                s = x.s == y.s ? 1 : -1,
                                xc = x.c,
                                yc = y.c;

                            // Either NaN, Infinity or 0?
                            if (!xc || !xc[0] || !yc || !yc[0]) {

                                return new BigNumber(

                                    // Return NaN if either NaN, or both Infinity or 0.
                                    !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

                                    // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                                );
                            }

                            q = new BigNumber(s);
                            qc = q.c = [];
                            e = x.e - y.e;
                            s = dp + e + 1;

                            if (!base) {
                                base = BASE;
                                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                                s = s / LOG_BASE | 0;
                            }

                            // Result exponent may be one less then the current value of e.
                            // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                            for (i = 0; yc[i] == (xc[i] || 0); i++);

                            if (yc[i] > (xc[i] || 0)) e--;

                            if (s < 0) {
                                qc.push(1);
                                more = true;
                            } else {
                                xL = xc.length;
                                yL = yc.length;
                                i = 0;
                                s += 2;

                                // Normalise xc and yc so highest order digit of yc is >= base / 2.

                                n = mathfloor(base / (yc[0] + 1));

                                // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                                // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                                if (n > 1) {
                                    yc = multiply(yc, n, base);
                                    xc = multiply(xc, n, base);
                                    yL = yc.length;
                                    xL = xc.length;
                                }

                                xi = yL;
                                rem = xc.slice(0, yL);
                                remL = rem.length;

                                // Add zeros to make remainder as long as divisor.
                                for (; remL < yL; rem[remL++] = 0);
                                yz = yc.slice();
                                yz = [0].concat(yz);
                                yc0 = yc[0];
                                if (yc[1] >= base / 2) yc0++;
                                // Not necessary, but to prevent trial digit n > base, when using base 3.
                                // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

                                do {
                                    n = 0;

                                    // Compare divisor and remainder.
                                    cmp = compare(yc, rem, yL, remL);

                                    // If divisor < remainder.
                                    if (cmp < 0) {

                                        // Calculate trial digit, n.

                                        rem0 = rem[0];
                                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                                        // n is how many times the divisor goes into the current remainder.
                                        n = mathfloor(rem0 / yc0);

                                        //  Algorithm:
                                        //  product = divisor multiplied by trial digit (n).
                                        //  Compare product and remainder.
                                        //  If product is greater than remainder:
                                        //    Subtract divisor from product, decrement trial digit.
                                        //  Subtract product from remainder.
                                        //  If product was less than remainder at the last compare:
                                        //    Compare new remainder and divisor.
                                        //    If remainder is greater than divisor:
                                        //      Subtract divisor from remainder, increment trial digit.

                                        if (n > 1) {

                                            // n may be > base only when base is 3.
                                            if (n >= base) n = base - 1;

                                            // product = divisor * trial digit.
                                            prod = multiply(yc, n, base);
                                            prodL = prod.length;
                                            remL = rem.length;

                                            // Compare product and remainder.
                                            // If product > remainder then trial digit n too high.
                                            // n is 1 too high about 5% of the time, and is not known to have
                                            // ever been more than 1 too high.
                                            while (compare(prod, rem, prodL, remL) == 1) {
                                                n--;

                                                // Subtract divisor from product.
                                                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                                prodL = prod.length;
                                                cmp = 1;
                                            }
                                        } else {

                                            // n is 0 or 1, cmp is -1.
                                            // If n is 0, there is no need to compare yc and rem again below,
                                            // so change cmp to 1 to avoid it.
                                            // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                            if (n == 0) {

                                                // divisor < remainder, so n must be at least 1.
                                                cmp = n = 1;
                                            }

                                            // product = divisor
                                            prod = yc.slice();
                                            prodL = prod.length;
                                        }

                                        if (prodL < remL) prod = [0].concat(prod);

                                        // Subtract product from remainder.
                                        subtract(rem, prod, remL, base);
                                        remL = rem.length;

                                        // If product was < remainder.
                                        if (cmp == -1) {

                                            // Compare divisor and new remainder.
                                            // If divisor < new remainder, subtract divisor from remainder.
                                            // Trial digit n too low.
                                            // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                            while (compare(yc, rem, yL, remL) < 1) {
                                                n++;

                                                // Subtract divisor from remainder.
                                                subtract(rem, yL < remL ? yz : yc, remL, base);
                                                remL = rem.length;
                                            }
                                        }
                                    } else if (cmp === 0) {
                                        n++;
                                        rem = [0];
                                    } // else cmp === 1 and n will be 0

                                    // Add the next digit, n, to the result array.
                                    qc[i++] = n;

                                    // Update the remainder.
                                    if (rem[0]) {
                                        rem[remL++] = xc[xi] || 0;
                                    } else {
                                        rem = [xc[xi]];
                                        remL = 1;
                                    }
                                } while ((xi++ < xL || rem[0] != null) && s--);

                                more = rem[0] != null;

                                // Leading zero?
                                if (!qc[0]) qc.splice(0, 1);
                            }

                            if (base == BASE) {

                                // To calculate q.e, first get the number of digits of qc[0].
                                for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

                                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

                                // Caller is convertBase.
                            } else {
                                q.e = e;
                                q.r = +more;
                            }

                            return q;
                        };
                    })();


                    /*
                     * Return a string representing the value of BigNumber n in fixed-point or exponential
                     * notation rounded to the specified decimal places or significant digits.
                     *
                     * n: a BigNumber.
                     * i: the index of the last digit required (i.e. the digit that may be rounded up).
                     * rm: the rounding mode.
                     * id: 1 (toExponential) or 2 (toPrecision).
                     */
                    function format(n, i, rm, id) {
                        var c0, e, ne, len, str;

                        if (rm == null) rm = ROUNDING_MODE;
                        else intCheck(rm, 0, 8);

                        if (!n.c) return n.toString();

                        c0 = n.c[0];
                        ne = n.e;

                        if (i == null) {
                            str = coeffToString(n.c);
                            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ?
                                toExponential(str, ne) :
                                toFixedPoint(str, ne, '0');
                        } else {
                            n = round(new BigNumber(n), i, rm);

                            // n.e may have changed if the value was rounded up.
                            e = n.e;

                            str = coeffToString(n.c);
                            len = str.length;

                            // toPrecision returns exponential notation if the number of significant digits
                            // specified is less than the number of digits necessary to represent the integer
                            // part of the value in fixed-point notation.

                            // Exponential notation.
                            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

                                // Append zeros?
                                for (; len < i; str += '0', len++);
                                str = toExponential(str, e);

                                // Fixed-point notation.
                            } else {
                                i -= ne;
                                str = toFixedPoint(str, e, '0');

                                // Append zeros?
                                if (e + 1 > len) {
                                    if (--i > 0)
                                        for (str += '.'; i--; str += '0');
                                } else {
                                    i += e - len;
                                    if (i > 0) {
                                        if (e + 1 == len) str += '.';
                                        for (; i--; str += '0');
                                    }
                                }
                            }
                        }

                        return n.s < 0 && c0 ? '-' + str : str;
                    }


                    // Handle BigNumber.max and BigNumber.min.
                    // If any number is NaN, return NaN.
                    function maxOrMin(args, n) {
                        var k, y,
                            i = 1,
                            x = new BigNumber(args[0]);

                        for (; i < args.length; i++) {
                            y = new BigNumber(args[i]);
                            if (!y.s || (k = bignumber_compare(x, y)) === n || k === 0 && x.s === n) {
                                x = y;
                            }
                        }

                        return x;
                    }


                    /*
                     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
                     * Called by minus, plus and times.
                     */
                    function normalise(n, c, e) {
                        var i = 1,
                            j = c.length;

                        // Remove trailing zeros.
                        for (; !c[--j]; c.pop());

                        // Calculate the base 10 exponent. First get the number of digits of c[0].
                        for (j = c[0]; j >= 10; j /= 10, i++);

                        // Overflow?
                        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

                            // Infinity.
                            n.c = n.e = null;

                            // Underflow?
                        } else if (e < MIN_EXP) {

                            // Zero.
                            n.c = [n.e = 0];
                        } else {
                            n.e = e;
                            n.c = c;
                        }

                        return n;
                    }


                    // Handle values that fail the validity test in BigNumber.
                    parseNumeric = (function() {
                        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                            dotAfter = /^([^.]+)\.$/,
                            dotBefore = /^\.([^.]+)$/,
                            isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                            whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

                        return function(x, str, isNum, b) {
                            var base,
                                s = isNum ? str : str.replace(whitespaceOrPlus, '');

                            // No exception on ±Infinity or NaN.
                            if (isInfinityOrNaN.test(s)) {
                                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                            } else {
                                if (!isNum) {

                                    // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                                    s = s.replace(basePrefix, function(m, p1, p2) {
                                        base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                                        return !b || b == base ? p1 : m;
                                    });

                                    if (b) {
                                        base = b;

                                        // E.g. '1.' to '1', '.1' to '0.1'
                                        s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                                    }

                                    if (str != s) return new BigNumber(s, base);
                                }

                                // '[BigNumber Error] Not a number: {n}'
                                // '[BigNumber Error] Not a base {b} number: {n}'
                                if (BigNumber.DEBUG) {
                                    throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                                }

                                // NaN
                                x.s = null;
                            }

                            x.c = x.e = null;
                        }
                    })();


                    /*
                     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
                     * If r is truthy, it is known that there are more digits after the rounding digit.
                     */
                    function round(x, sd, rm, r) {
                        var d, i, j, k, n, ni, rd,
                            xc = x.c,
                            pows10 = POWS_TEN;

                        // if x is not Infinity or NaN...
                        if (xc) {

                            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                            // n is a base 1e14 number, the value of the element of array x.c containing rd.
                            // ni is the index of n within x.c.
                            // d is the number of digits of n.
                            // i is the index of rd within n including leading zeros.
                            // j is the actual index of rd within n (if < 0, rd is a leading zero).
                            out: {

                                // Get the number of digits of the first element of xc.
                                for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                                i = sd - d;

                                // If the rounding digit is in the first element of xc...
                                if (i < 0) {
                                    i += LOG_BASE;
                                    j = sd;
                                    n = xc[ni = 0];

                                    // Get the rounding digit at index j of n.
                                    rd = mathfloor(n / pows10[d - j - 1] % 10);
                                } else {
                                    ni = mathceil((i + 1) / LOG_BASE);

                                    if (ni >= xc.length) {

                                        if (r) {

                                            // Needed by sqrt.
                                            for (; xc.length <= ni; xc.push(0));
                                            n = rd = 0;
                                            d = 1;
                                            i %= LOG_BASE;
                                            j = i - LOG_BASE + 1;
                                        } else {
                                            break out;
                                        }
                                    } else {
                                        n = k = xc[ni];

                                        // Get the number of digits of n.
                                        for (d = 1; k >= 10; k /= 10, d++);

                                        // Get the index of rd within n.
                                        i %= LOG_BASE;

                                        // Get the index of rd within n, adjusted for leading zeros.
                                        // The number of leading zeros of n is given by LOG_BASE - d.
                                        j = i - LOG_BASE + d;

                                        // Get the rounding digit at index j of n.
                                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                                    }
                                }

                                r = r || sd < 0 ||

                                // Are there any non-zero digits after the rounding digit?
                                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

                                r = rm < 4 ?
                                (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) :
                                    rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

                                    // Check whether the digit to the left of the rounding digit is odd.
                                    ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
                                    rm == (x.s < 0 ? 8 : 7));

                                if (sd < 1 || !xc[0]) {
                                    xc.length = 0;

                                    if (r) {

                                        // Convert sd to decimal places.
                                        sd -= x.e + 1;

                                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                                        x.e = -sd || 0;
                                    } else {

                                        // Zero.
                                        xc[0] = x.e = 0;
                                    }

                                    return x;
                                }

                                // Remove excess digits.
                                if (i == 0) {
                                    xc.length = ni;
                                    k = 1;
                                    ni--;
                                } else {
                                    xc.length = ni + 1;
                                    k = pows10[LOG_BASE - i];

                                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                                    // j > 0 means i > number of leading zeros of n.
                                    xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                                }

                                // Round up?
                                if (r) {

                                    for (;;) {

                                        // If the digit to be rounded up is in the first element of xc...
                                        if (ni == 0) {

                                            // i will be the length of xc[0] before k is added.
                                            for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                                            j = xc[0] += k;
                                            for (k = 1; j >= 10; j /= 10, k++);

                                            // if i != k the length has increased.
                                            if (i != k) {
                                                x.e++;
                                                if (xc[0] == BASE) xc[0] = 1;
                                            }

                                            break;
                                        } else {
                                            xc[ni] += k;
                                            if (xc[ni] != BASE) break;
                                            xc[ni--] = 0;
                                            k = 1;
                                        }
                                    }
                                }

                                // Remove trailing zeros.
                                for (i = xc.length; xc[--i] === 0; xc.pop());
                            }

                            // Overflow? Infinity.
                            if (x.e > MAX_EXP) {
                                x.c = x.e = null;

                                // Underflow? Zero.
                            } else if (x.e < MIN_EXP) {
                                x.c = [x.e = 0];
                            }
                        }

                        return x;
                    }


                    function valueOf(n) {
                        var str,
                            e = n.e;

                        if (e === null) return n.toString();

                        str = coeffToString(n.c);

                        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ?
                            toExponential(str, e) :
                            toFixedPoint(str, e, '0');

                        return n.s < 0 ? '-' + str : str;
                    }


                    // PROTOTYPE/INSTANCE METHODS


                    /*
                     * Return a new BigNumber whose value is the absolute value of this BigNumber.
                     */
                    P.absoluteValue = P.abs = function() {
                        var x = new BigNumber(this);
                        if (x.s < 0) x.s = 1;
                        return x;
                    };


                    /*
                     * Return
                     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
                     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
                     *   0 if they have the same value,
                     *   or null if the value of either is NaN.
                     */
                    P.comparedTo = function(y, b) {
                        return bignumber_compare(this, new BigNumber(y, b));
                    };


                    /*
                     * If dp is undefined or null or true or false, return the number of decimal places of the
                     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
                     *
                     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
                     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
                     * ROUNDING_MODE if rm is omitted.
                     *
                     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                     */
                    P.decimalPlaces = P.dp = function(dp, rm) {
                        var c, n, v,
                            x = this;

                        if (dp != null) {
                            intCheck(dp, 0, MAX);
                            if (rm == null) rm = ROUNDING_MODE;
                            else intCheck(rm, 0, 8);

                            return round(new BigNumber(x), dp + x.e + 1, rm);
                        }

                        if (!(c = x.c)) return null;
                        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

                        // Subtract the number of trailing zeros of the last number.
                        if (v = c[v])
                            for (; v % 10 == 0; v /= 10, n--);
                        if (n < 0) n = 0;

                        return n;
                    };


                    /*
                     *  n / 0 = I
                     *  n / N = N
                     *  n / I = 0
                     *  0 / n = 0
                     *  0 / 0 = N
                     *  0 / N = N
                     *  0 / I = 0
                     *  N / n = N
                     *  N / 0 = N
                     *  N / N = N
                     *  N / I = N
                     *  I / n = I
                     *  I / 0 = I
                     *  I / N = N
                     *  I / I = N
                     *
                     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
                     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
                     */
                    P.dividedBy = P.div = function(y, b) {
                        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
                    };


                    /*
                     * Return a new BigNumber whose value is the integer part of dividing the value of this
                     * BigNumber by the value of BigNumber(y, b).
                     */
                    P.dividedToIntegerBy = P.idiv = function(y, b) {
                        return div(this, new BigNumber(y, b), 0, 1);
                    };


                    /*
                     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
                     *
                     * If m is present, return the result modulo m.
                     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
                     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
                     *
                     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
                     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
                     *
                     * n {number|string|BigNumber} The exponent. An integer.
                     * [m] {number|string|BigNumber} The modulus.
                     *
                     * '[BigNumber Error] Exponent not an integer: {n}'
                     */
                    P.exponentiatedBy = P.pow = function(n, m) {
                        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
                            x = this;

                        n = new BigNumber(n);

                        // Allow NaN and ±Infinity, but not other non-integers.
                        if (n.c && !n.isInteger()) {
                            throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
                        }

                        if (m != null) m = new BigNumber(m);

                        // Exponent of MAX_SAFE_INTEGER is 15.
                        nIsBig = n.e > 14;

                        // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
                        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

                            // The sign of the result of pow when x is negative depends on the evenness of n.
                            // If +n overflows to ±Infinity, the evenness of n would be not be known.
                            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
                            return m ? y.mod(m) : y;
                        }

                        nIsNeg = n.s < 0;

                        if (m) {

                            // x % m returns NaN if abs(m) is zero, or m is NaN.
                            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

                            isModExp = !nIsNeg && x.isInteger() && m.isInteger();

                            if (isModExp) x = x.mod(m);

                            // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
                            // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
                        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
                                // [1, 240000000]
                                ?
                                x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
                                // [80000000000000]  [99999750000000]
                                :
                                x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

                            // If x is negative and n is odd, k = -0, else k = 0.
                            k = x.s < 0 && isOdd(n) ? -0 : 0;

                            // If x >= 1, k = ±Infinity.
                            if (x.e > -1) k = 1 / k;

                            // If n is negative return ±0, else return ±Infinity.
                            return new BigNumber(nIsNeg ? 1 / k : k);

                        } else if (POW_PRECISION) {

                            // Truncating each coefficient array to a length of k after each multiplication
                            // equates to truncating significant digits to POW_PRECISION + [28, 41],
                            // i.e. there will be a minimum of 28 guard digits retained.
                            k = mathceil(POW_PRECISION / LOG_BASE + 2);
                        }

                        if (nIsBig) {
                            half = new BigNumber(0.5);
                            if (nIsNeg) n.s = 1;
                            nIsOdd = isOdd(n);
                        } else {
                            i = Math.abs(+valueOf(n));
                            nIsOdd = i % 2;
                        }

                        y = new BigNumber(ONE);

                        // Performs 54 loop iterations for n of 9007199254740991.
                        for (;;) {

                            if (nIsOdd) {
                                y = y.times(x);
                                if (!y.c) break;

                                if (k) {
                                    if (y.c.length > k) y.c.length = k;
                                } else if (isModExp) {
                                    y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                                }
                            }

                            if (i) {
                                i = mathfloor(i / 2);
                                if (i === 0) break;
                                nIsOdd = i % 2;
                            } else {
                                n = n.times(half);
                                round(n, n.e + 1, 1);

                                if (n.e > 14) {
                                    nIsOdd = isOdd(n);
                                } else {
                                    i = +valueOf(n);
                                    if (i === 0) break;
                                    nIsOdd = i % 2;
                                }
                            }

                            x = x.times(x);

                            if (k) {
                                if (x.c && x.c.length > k) x.c.length = k;
                            } else if (isModExp) {
                                x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
                            }
                        }

                        if (isModExp) return y;
                        if (nIsNeg) y = ONE.div(y);

                        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
                    };


                    /*
                     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
                     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
                     *
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
                     */
                    P.integerValue = function(rm) {
                        var n = new BigNumber(this);
                        if (rm == null) rm = ROUNDING_MODE;
                        else intCheck(rm, 0, 8);
                        return round(n, n.e + 1, rm);
                    };


                    /*
                     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
                     * otherwise return false.
                     */
                    P.isEqualTo = P.eq = function(y, b) {
                        return bignumber_compare(this, new BigNumber(y, b)) === 0;
                    };


                    /*
                     * Return true if the value of this BigNumber is a finite number, otherwise return false.
                     */
                    P.isFinite = function() {
                        return !!this.c;
                    };


                    /*
                     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
                     * otherwise return false.
                     */
                    P.isGreaterThan = P.gt = function(y, b) {
                        return bignumber_compare(this, new BigNumber(y, b)) > 0;
                    };


                    /*
                     * Return true if the value of this BigNumber is greater than or equal to the value of
                     * BigNumber(y, b), otherwise return false.
                     */
                    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
                        return (b = bignumber_compare(this, new BigNumber(y, b))) === 1 || b === 0;

                    };


                    /*
                     * Return true if the value of this BigNumber is an integer, otherwise return false.
                     */
                    P.isInteger = function() {
                        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
                    };


                    /*
                     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
                     * otherwise return false.
                     */
                    P.isLessThan = P.lt = function(y, b) {
                        return bignumber_compare(this, new BigNumber(y, b)) < 0;
                    };


                    /*
                     * Return true if the value of this BigNumber is less than or equal to the value of
                     * BigNumber(y, b), otherwise return false.
                     */
                    P.isLessThanOrEqualTo = P.lte = function(y, b) {
                        return (b = bignumber_compare(this, new BigNumber(y, b))) === -1 || b === 0;
                    };


                    /*
                     * Return true if the value of this BigNumber is NaN, otherwise return false.
                     */
                    P.isNaN = function() {
                        return !this.s;
                    };


                    /*
                     * Return true if the value of this BigNumber is negative, otherwise return false.
                     */
                    P.isNegative = function() {
                        return this.s < 0;
                    };


                    /*
                     * Return true if the value of this BigNumber is positive, otherwise return false.
                     */
                    P.isPositive = function() {
                        return this.s > 0;
                    };


                    /*
                     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
                     */
                    P.isZero = function() {
                        return !!this.c && this.c[0] == 0;
                    };


                    /*
                     *  n - 0 = n
                     *  n - N = N
                     *  n - I = -I
                     *  0 - n = -n
                     *  0 - 0 = 0
                     *  0 - N = N
                     *  0 - I = -I
                     *  N - n = N
                     *  N - 0 = N
                     *  N - N = N
                     *  N - I = N
                     *  I - n = I
                     *  I - 0 = I
                     *  I - N = N
                     *  I - I = N
                     *
                     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
                     * BigNumber(y, b).
                     */
                    P.minus = function(y, b) {
                        var i, j, t, xLTy,
                            x = this,
                            a = x.s;

                        y = new BigNumber(y, b);
                        b = y.s;

                        // Either NaN?
                        if (!a || !b) return new BigNumber(NaN);

                        // Signs differ?
                        if (a != b) {
                            y.s = -b;
                            return x.plus(y);
                        }

                        var xe = x.e / LOG_BASE,
                            ye = y.e / LOG_BASE,
                            xc = x.c,
                            yc = y.c;

                        if (!xe || !ye) {

                            // Either Infinity?
                            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

                            // Either zero?
                            if (!xc[0] || !yc[0]) {

                                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

                                    // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                                    ROUNDING_MODE == 3 ? -0 : 0);
                            }
                        }

                        xe = bitFloor(xe);
                        ye = bitFloor(ye);
                        xc = xc.slice();

                        // Determine which is the bigger number.
                        if (a = xe - ye) {

                            if (xLTy = a < 0) {
                                a = -a;
                                t = xc;
                            } else {
                                ye = xe;
                                t = yc;
                            }

                            t.reverse();

                            // Prepend zeros to equalise exponents.
                            for (b = a; b--; t.push(0));
                            t.reverse();
                        } else {

                            // Exponents equal. Check digit by digit.
                            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

                            for (a = b = 0; b < j; b++) {

                                if (xc[b] != yc[b]) {
                                    xLTy = xc[b] < yc[b];
                                    break;
                                }
                            }
                        }

                        // x < y? Point xc to the array of the bigger number.
                        if (xLTy) {
                            t = xc;
                            xc = yc;
                            yc = t;
                            y.s = -y.s;
                        }

                        b = (j = yc.length) - (i = xc.length);

                        // Append zeros to xc if shorter.
                        // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
                        if (b > 0)
                            for (; b--; xc[i++] = 0);
                        b = BASE - 1;

                        // Subtract yc from xc.
                        for (; j > a;) {

                            if (xc[--j] < yc[j]) {
                                for (i = j; i && !xc[--i]; xc[i] = b);
                                --xc[i];
                                xc[j] += BASE;
                            }

                            xc[j] -= yc[j];
                        }

                        // Remove leading zeros and adjust exponent accordingly.
                        for (; xc[0] == 0; xc.splice(0, 1), --ye);

                        // Zero?
                        if (!xc[0]) {

                            // Following IEEE 754 (2008) 6.3,
                            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                            y.s = ROUNDING_MODE == 3 ? -1 : 1;
                            y.c = [y.e = 0];
                            return y;
                        }

                        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
                        // for finite x and y.
                        return normalise(y, xc, ye);
                    };


                    /*
                     *   n % 0 =  N
                     *   n % N =  N
                     *   n % I =  n
                     *   0 % n =  0
                     *  -0 % n = -0
                     *   0 % 0 =  N
                     *   0 % N =  N
                     *   0 % I =  0
                     *   N % n =  N
                     *   N % 0 =  N
                     *   N % N =  N
                     *   N % I =  N
                     *   I % n =  N
                     *   I % 0 =  N
                     *   I % N =  N
                     *   I % I =  N
                     *
                     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
                     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
                     */
                    P.modulo = P.mod = function(y, b) {
                        var q, s,
                            x = this;

                        y = new BigNumber(y, b);

                        // Return NaN if x is Infinity or NaN, or y is NaN or zero.
                        if (!x.c || !y.s || y.c && !y.c[0]) {
                            return new BigNumber(NaN);

                            // Return x if y is Infinity or x is zero.
                        } else if (!y.c || x.c && !x.c[0]) {
                            return new BigNumber(x);
                        }

                        if (MODULO_MODE == 9) {

                            // Euclidian division: q = sign(y) * floor(x / abs(y))
                            // r = x - qy    where  0 <= r < abs(y)
                            s = y.s;
                            y.s = 1;
                            q = div(x, y, 0, 3);
                            y.s = s;
                            q.s *= s;
                        } else {
                            q = div(x, y, 0, MODULO_MODE);
                        }

                        y = x.minus(q.times(y));

                        // To match JavaScript %, ensure sign of zero is sign of dividend.
                        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

                        return y;
                    };


                    /*
                     *  n * 0 = 0
                     *  n * N = N
                     *  n * I = I
                     *  0 * n = 0
                     *  0 * 0 = 0
                     *  0 * N = N
                     *  0 * I = N
                     *  N * n = N
                     *  N * 0 = N
                     *  N * N = N
                     *  N * I = N
                     *  I * n = I
                     *  I * 0 = N
                     *  I * N = N
                     *  I * I = I
                     *
                     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
                     * of BigNumber(y, b).
                     */
                    P.multipliedBy = P.times = function(y, b) {
                        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                            base, sqrtBase,
                            x = this,
                            xc = x.c,
                            yc = (y = new BigNumber(y, b)).c;

                        // Either NaN, ±Infinity or ±0?
                        if (!xc || !yc || !xc[0] || !yc[0]) {

                            // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                                y.c = y.e = y.s = null;
                            } else {
                                y.s *= x.s;

                                // Return ±Infinity if either is ±Infinity.
                                if (!xc || !yc) {
                                    y.c = y.e = null;

                                    // Return ±0 if either is ±0.
                                } else {
                                    y.c = [0];
                                    y.e = 0;
                                }
                            }

                            return y;
                        }

                        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                        y.s *= x.s;
                        xcL = xc.length;
                        ycL = yc.length;

                        // Ensure xc points to longer array and xcL to its length.
                        if (xcL < ycL) {
                            zc = xc;
                            xc = yc;
                            yc = zc;
                            i = xcL;
                            xcL = ycL;
                            ycL = i;
                        }

                        // Initialise the result array with zeros.
                        for (i = xcL + ycL, zc = []; i--; zc.push(0));

                        base = BASE;
                        sqrtBase = SQRT_BASE;

                        for (i = ycL; --i >= 0;) {
                            c = 0;
                            ylo = yc[i] % sqrtBase;
                            yhi = yc[i] / sqrtBase | 0;

                            for (k = xcL, j = i + k; j > i;) {
                                xlo = xc[--k] % sqrtBase;
                                xhi = xc[k] / sqrtBase | 0;
                                m = yhi * xlo + xhi * ylo;
                                xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
                                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                                zc[j--] = xlo % base;
                            }

                            zc[j] = c;
                        }

                        if (c) {
                            ++e;
                        } else {
                            zc.splice(0, 1);
                        }

                        return normalise(y, zc, e);
                    };


                    /*
                     * Return a new BigNumber whose value is the value of this BigNumber negated,
                     * i.e. multiplied by -1.
                     */
                    P.negated = function() {
                        var x = new BigNumber(this);
                        x.s = -x.s || null;
                        return x;
                    };


                    /*
                     *  n + 0 = n
                     *  n + N = N
                     *  n + I = I
                     *  0 + n = n
                     *  0 + 0 = 0
                     *  0 + N = N
                     *  0 + I = I
                     *  N + n = N
                     *  N + 0 = N
                     *  N + N = N
                     *  N + I = N
                     *  I + n = I
                     *  I + 0 = I
                     *  I + N = N
                     *  I + I = I
                     *
                     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
                     * BigNumber(y, b).
                     */
                    P.plus = function(y, b) {
                        var t,
                            x = this,
                            a = x.s;

                        y = new BigNumber(y, b);
                        b = y.s;

                        // Either NaN?
                        if (!a || !b) return new BigNumber(NaN);

                        // Signs differ?
                        if (a != b) {
                            y.s = -b;
                            return x.minus(y);
                        }

                        var xe = x.e / LOG_BASE,
                            ye = y.e / LOG_BASE,
                            xc = x.c,
                            yc = y.c;

                        if (!xe || !ye) {

                            // Return ±Infinity if either ±Infinity.
                            if (!xc || !yc) return new BigNumber(a / 0);

                            // Either zero?
                            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
                        }

                        xe = bitFloor(xe);
                        ye = bitFloor(ye);
                        xc = xc.slice();

                        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
                        if (a = xe - ye) {
                            if (a > 0) {
                                ye = xe;
                                t = yc;
                            } else {
                                a = -a;
                                t = xc;
                            }

                            t.reverse();
                            for (; a--; t.push(0));
                            t.reverse();
                        }

                        a = xc.length;
                        b = yc.length;

                        // Point xc to the longer array, and b to the shorter length.
                        if (a - b < 0) {
                            t = yc;
                            yc = xc;
                            xc = t;
                            b = a;
                        }

                        // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
                        for (a = 0; b;) {
                            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                        }

                        if (a) {
                            xc = [a].concat(xc);
                            ++ye;
                        }

                        // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                        // ye = MAX_EXP + 1 possible
                        return normalise(y, xc, ye);
                    };


                    /*
                     * If sd is undefined or null or true or false, return the number of significant digits of
                     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
                     * If sd is true include integer-part trailing zeros in the count.
                     *
                     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
                     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
                     * ROUNDING_MODE if rm is omitted.
                     *
                     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
                     *                     boolean: whether to count integer-part trailing zeros: true or false.
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
                     */
                    P.precision = P.sd = function(sd, rm) {
                        var c, n, v,
                            x = this;

                        if (sd != null && sd !== !!sd) {
                            intCheck(sd, 1, MAX);
                            if (rm == null) rm = ROUNDING_MODE;
                            else intCheck(rm, 0, 8);

                            return round(new BigNumber(x), sd, rm);
                        }

                        if (!(c = x.c)) return null;
                        v = c.length - 1;
                        n = v * LOG_BASE + 1;

                        if (v = c[v]) {

                            // Subtract the number of trailing zeros of the last element.
                            for (; v % 10 == 0; v /= 10, n--);

                            // Add the number of digits of the first element.
                            for (v = c[0]; v >= 10; v /= 10, n++);
                        }

                        if (sd && x.e + 1 > n) n = x.e + 1;

                        return n;
                    };


                    /*
                     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
                     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
                     *
                     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
                     */
                    P.shiftedBy = function(k) {
                        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                        return this.times('1e' + k);
                    };


                    /*
                     *  sqrt(-n) =  N
                     *  sqrt(N) =  N
                     *  sqrt(-I) =  N
                     *  sqrt(I) =  I
                     *  sqrt(0) =  0
                     *  sqrt(-0) = -0
                     *
                     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
                     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
                     */
                    P.squareRoot = P.sqrt = function() {
                        var m, n, r, rep, t,
                            x = this,
                            c = x.c,
                            s = x.s,
                            e = x.e,
                            dp = DECIMAL_PLACES + 4,
                            half = new BigNumber('0.5');

                        // Negative/NaN/Infinity/zero?
                        if (s !== 1 || !c || !c[0]) {
                            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                        }

                        // Initial estimate.
                        s = Math.sqrt(+valueOf(x));

                        // Math.sqrt underflow/overflow?
                        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
                        if (s == 0 || s == 1 / 0) {
                            n = coeffToString(c);
                            if ((n.length + e) % 2 == 0) n += '0';
                            s = Math.sqrt(+n);
                            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

                            if (s == 1 / 0) {
                                n = '5e' + e;
                            } else {
                                n = s.toExponential();
                                n = n.slice(0, n.indexOf('e') + 1) + e;
                            }

                            r = new BigNumber(n);
                        } else {
                            r = new BigNumber(s + '');
                        }

                        // Check for zero.
                        // r could be zero if MIN_EXP is changed after the this value was created.
                        // This would cause a division by zero (x/t) and hence Infinity below, which would cause
                        // coeffToString to throw.
                        if (r.c[0]) {
                            e = r.e;
                            s = e + dp;
                            if (s < 3) s = 0;

                            // Newton-Raphson iteration.
                            for (;;) {
                                t = r;
                                r = half.times(t.plus(div(x, t, dp, 1)));

                                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

                                    // The exponent of r may here be one less than the final result exponent,
                                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                                    // are indexed correctly.
                                    if (r.e < e) --s;
                                    n = n.slice(s - 3, s + 1);

                                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                                    // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                                    // iteration.
                                    if (n == '9999' || !rep && n == '4999') {

                                        // On the first iteration only, check to see if rounding up gives the
                                        // exact result as the nines may infinitely repeat.
                                        if (!rep) {
                                            round(t, t.e + DECIMAL_PLACES + 2, 0);

                                            if (t.times(t).eq(x)) {
                                                r = t;
                                                break;
                                            }
                                        }

                                        dp += 4;
                                        s += 4;
                                        rep = 1;
                                    } else {

                                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                                        // result. If not, then there are further digits and m will be truthy.
                                        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                                            // Truncate to the first rounding digit.
                                            round(r, r.e + DECIMAL_PLACES + 2, 1);
                                            m = !r.times(r).eq(x);
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
                    };


                    /*
                     * Return a string representing the value of this BigNumber in exponential notation and
                     * rounded using ROUNDING_MODE to dp fixed decimal places.
                     *
                     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                     */
                    P.toExponential = function(dp, rm) {
                        if (dp != null) {
                            intCheck(dp, 0, MAX);
                            dp++;
                        }
                        return format(this, dp, rm, 1);
                    };


                    /*
                     * Return a string representing the value of this BigNumber in fixed-point notation rounding
                     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
                     *
                     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
                     * but e.g. (-0.00001).toFixed(0) is '-0'.
                     *
                     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                     */
                    P.toFixed = function(dp, rm) {
                        if (dp != null) {
                            intCheck(dp, 0, MAX);
                            dp = dp + this.e + 1;
                        }
                        return format(this, dp, rm);
                    };


                    /*
                     * Return a string representing the value of this BigNumber in fixed-point notation rounded
                     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
                     * of the format or FORMAT object (see BigNumber.set).
                     *
                     * The formatting object may contain some or all of the properties shown below.
                     *
                     * FORMAT = {
                     *   prefix: '',
                     *   groupSize: 3,
                     *   secondaryGroupSize: 0,
                     *   groupSeparator: ',',
                     *   decimalSeparator: '.',
                     *   fractionGroupSize: 0,
                     *   fractionGroupSeparator: '\xA0',      // non-breaking space
                     *   suffix: ''
                     * };
                     *
                     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     * [format] {object} Formatting options. See FORMAT pbject above.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                     * '[BigNumber Error] Argument not an object: {format}'
                     */
                    P.toFormat = function(dp, rm, format) {
                        var str,
                            x = this;

                        if (format == null) {
                            if (dp != null && rm && typeof rm == 'object') {
                                format = rm;
                                rm = null;
                            } else if (dp && typeof dp == 'object') {
                                format = dp;
                                dp = rm = null;
                            } else {
                                format = FORMAT;
                            }
                        } else if (typeof format != 'object') {
                            throw Error(bignumberError + 'Argument not an object: ' + format);
                        }

                        str = x.toFixed(dp, rm);

                        if (x.c) {
                            var i,
                                arr = str.split('.'),
                                g1 = +format.groupSize,
                                g2 = +format.secondaryGroupSize,
                                groupSeparator = format.groupSeparator || '',
                                intPart = arr[0],
                                fractionPart = arr[1],
                                isNeg = x.s < 0,
                                intDigits = isNeg ? intPart.slice(1) : intPart,
                                len = intDigits.length;

                            if (g2) {
                                i = g1;
                                g1 = g2;
                                g2 = i;
                                len -= i;
                            }

                            if (g1 > 0 && len > 0) {
                                i = len % g1 || g1;
                                intPart = intDigits.substr(0, i);
                                for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
                                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                                if (isNeg) intPart = '-' + intPart;
                            }

                            str = fractionPart ?
                                intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ?
                                    fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
                                        '$&' + (format.fractionGroupSeparator || '')) :
                                    fractionPart) :
                                intPart;
                        }

                        return (format.prefix || '') + str + (format.suffix || '');
                    };


                    /*
                     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
                     * fraction with an integer numerator and an integer denominator.
                     * The denominator will be a positive non-zero value less than or equal to the specified
                     * maximum denominator. If a maximum denominator is not specified, the denominator will be
                     * the lowest value necessary to represent the number exactly.
                     *
                     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
                     *
                     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
                     */
                    P.toFraction = function(md) {
                        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
                            x = this,
                            xc = x.c;

                        if (md != null) {
                            n = new BigNumber(md);

                            // Throw if md is less than one or is not an integer, unless it is Infinity.
                            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                                throw Error(bignumberError + 'Argument ' +
                                    (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
                            }
                        }

                        if (!xc) return new BigNumber(x);

                        d = new BigNumber(ONE);
                        n1 = d0 = new BigNumber(ONE);
                        d1 = n0 = new BigNumber(ONE);
                        s = coeffToString(xc);

                        // Determine initial denominator.
                        // d is a power of 10 and the minimum max denominator that specifies the value exactly.
                        e = d.e = s.length - x.e - 1;
                        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                        md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

                        exp = MAX_EXP;
                        MAX_EXP = 1 / 0;
                        n = new BigNumber(s);

                        // n0 = d1 = 0
                        n0.c[0] = 0;

                        for (;;) {
                            q = div(n, d, 0, 1);
                            d2 = d0.plus(q.times(d1));
                            if (d2.comparedTo(md) == 1) break;
                            d0 = d1;
                            d1 = d2;
                            n1 = n0.plus(q.times(d2 = n1));
                            n0 = d2;
                            d = n.minus(q.times(d2 = d));
                            n = d2;
                        }

                        d2 = div(md.minus(d0), d1, 0, 1);
                        n0 = n0.plus(d2.times(n1));
                        d0 = d0.plus(d2.times(d1));
                        n0.s = n1.s = x.s;
                        e = e * 2;

                        // Determine which fraction is closer to x, n0/d0 or n1/d1
                        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
                            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

                        MAX_EXP = exp;

                        return r;
                    };


                    /*
                     * Return the value of this BigNumber converted to a number primitive.
                     */
                    P.toNumber = function() {
                        return +valueOf(this);
                    };


                    /*
                     * Return a string representing the value of this BigNumber rounded to sd significant digits
                     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
                     * necessary to represent the integer part of the value in fixed-point notation, then use
                     * exponential notation.
                     *
                     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
                     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                     *
                     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
                     */
                    P.toPrecision = function(sd, rm) {
                        if (sd != null) intCheck(sd, 1, MAX);
                        return format(this, sd, rm, 2);
                    };


                    /*
                     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
                     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
                     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
                     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
                     * TO_EXP_NEG, return exponential notation.
                     *
                     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
                     *
                     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                     */
                    P.toString = function(b) {
                        var str,
                            n = this,
                            s = n.s,
                            e = n.e;

                        // Infinity or NaN?
                        if (e === null) {
                            if (s) {
                                str = 'Infinity';
                                if (s < 0) str = '-' + str;
                            } else {
                                str = 'NaN';
                            }
                        } else {
                            if (b == null) {
                                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ?
                                    toExponential(coeffToString(n.c), e) :
                                    toFixedPoint(coeffToString(n.c), e, '0');
                            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                                n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                                str = toFixedPoint(coeffToString(n.c), n.e, '0');
                            } else {
                                intCheck(b, 2, ALPHABET.length, 'Base');
                                str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
                            }

                            if (s < 0 && n.c[0]) str = '-' + str;
                        }

                        return str;
                    };


                    /*
                     * Return as toString, but do not accept a base argument, and include the minus sign for
                     * negative zero.
                     */
                    P.valueOf = P.toJSON = function() {
                        return valueOf(this);
                    };


                    P._isBigNumber = true;

                    P[Symbol.toStringTag] = 'BigNumber';

                    // Node.js v10.12.0+
                    P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;

                    if (configObject != null) BigNumber.set(configObject);

                    return BigNumber;
                }


                // PRIVATE HELPER FUNCTIONS

                // These functions don't need access to variables,
                // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


                function bitFloor(n) {
                    var i = n | 0;
                    return n > 0 || n === i ? i : i - 1;
                }


                // Return a coefficient array as a string of base 10 digits.
                function coeffToString(a) {
                    var s, z,
                        i = 1,
                        j = a.length,
                        r = a[0] + '';

                    for (; i < j;) {
                        s = a[i++] + '';
                        z = LOG_BASE - s.length;
                        for (; z--; s = '0' + s);
                        r += s;
                    }

                    // Determine trailing zeros.
                    for (j = r.length; r.charCodeAt(--j) === 48;);

                    return r.slice(0, j + 1 || 1);
                }


                // Compare the value of BigNumbers x and y.
                function bignumber_compare(x, y) {
                    var a, b,
                        xc = x.c,
                        yc = y.c,
                        i = x.s,
                        j = y.s,
                        k = x.e,
                        l = y.e;

                    // Either NaN?
                    if (!i || !j) return null;

                    a = xc && !xc[0];
                    b = yc && !yc[0];

                    // Either zero?
                    if (a || b) return a ? b ? 0 : -j : i;

                    // Signs differ?
                    if (i != j) return i;

                    a = i < 0;
                    b = k == l;

                    // Either Infinity?
                    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

                    // Compare exponents.
                    if (!b) return k > l ^ a ? 1 : -1;

                    j = (k = xc.length) < (l = yc.length) ? k : l;

                    // Compare digit by digit.
                    for (i = 0; i < j; i++)
                        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

                    // Compare lengths.
                    return k == l ? 0 : k > l ^ a ? 1 : -1;
                }


                /*
                 * Check that n is a primitive number, an integer, and in range, otherwise throw.
                 */
                function intCheck(n, min, max, name) {
                    if (n < min || n > max || n !== mathfloor(n)) {
                        throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ?
                            n < min || n > max ? ' out of range: ' : ' not an integer: ' :
                            ' not a primitive number: ') + String(n));
                    }
                }


                // Assumes finite n.
                function isOdd(n) {
                    var k = n.c.length - 1;
                    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
                }


                function toExponential(str, e) {
                    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
                        (e < 0 ? 'e' : 'e+') + e;
                }


                function toFixedPoint(str, e, z) {
                    var len, zs;

                    // Negative exponent?
                    if (e < 0) {

                        // Prepend zeros.
                        for (zs = z + '.'; ++e; zs += z);
                        str = zs + str;

                        // Positive exponent
                    } else {
                        len = str.length;

                        // Append zeros.
                        if (++e > len) {
                            for (zs = z, e -= len; --e; zs += z);
                            str += zs;
                        } else if (e < len) {
                            str = str.slice(0, e) + '.' + str.slice(e);
                        }
                    }

                    return str;
                }


                // EXPORT


                var BigNumber = clone();

                /* harmony default export */
                const bignumber = (BigNumber);

                ; // CONCATENATED MODULE: ./src/utils/number.ts

                var numberToPercents = function(num) {
                    var dp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2,
                        less = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    var n1 = new bignumber(num);
                    if (!n1.isFinite()) {
                        return "--";
                    }
                    if (n1.isLessThan(0.0001) && less) {
                        return "<0.01%";
                    }
                    var result = n1.multipliedBy(100).decimalPlaces(dp).toString();
                    return "".concat(result, "%");
                };

                // EXTERNAL MODULE: ./src/components/Button.tsx
                var Button = __webpack_require__("uBHB");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread_props.mjs
                var _object_spread_props = __webpack_require__("L2LL");; // CONCATENATED MODULE: ./src/icons/Venus.tsx



                var Venus = function(props) {
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("svg", (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                        width: "112",
                        height: "112",
                        viewBox: "0 0 112 112",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg"
                    }, props), {
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("rect", {
                                width: "112",
                                height: "112",
                                rx: "56",
                                fill: "#13161F"
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("path", {
                                d: "M104 56C104 29.4903 82.5097 8 56 8C29.4903 8 8 29.4903 8 56C8 82.5097 29.4903 104 56 104C82.5097 104 104 82.5097 104 56Z",
                                fill: "#13161F"
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("path", {
                                d: "M90.3901 41.3939L64.5446 86.1524C63.7369 87.4985 62.66 88.6428 61.3139 89.3831C59.9678 90.1908 58.4198 90.5946 56.8717 90.5946C55.3237 90.5946 53.7756 90.1908 52.4295 89.3831C51.0834 88.5754 49.9392 87.4985 49.1988 86.1524L44.6893 78.3449V78.2776C44.6893 78.2776 44.6893 78.2103 44.7566 78.2103H44.8239C44.8239 78.2103 44.8913 78.2103 44.8913 78.2776C45.6989 79.0853 46.7085 79.6911 47.7854 80.0276C48.8623 80.3641 50.0065 80.4987 51.1507 80.3641C52.2949 80.2295 53.3718 79.8257 54.3141 79.1526C55.2564 78.5468 56.0641 77.6719 56.6025 76.7296L78.2077 39.2401C78.7462 38.2305 79.0827 37.1536 79.2173 36.0094C79.2846 34.8652 79.0827 33.721 78.6789 32.6441C78.2077 31.5672 77.5347 30.6249 76.727 29.8846C75.852 29.1442 74.8424 28.6058 73.7655 28.2692H73.6982V28.2019V28.1346H73.7655H82.9192C84.4672 28.1346 86.0152 28.5384 87.3614 29.3461C88.7075 30.1538 89.8517 31.2307 90.592 32.5768C91.3997 33.9229 91.8036 35.471 91.8036 37.019C91.5343 38.4997 91.1305 39.9805 90.3901 41.3939ZM59.7659 28H50.8142H50.7469V28.0673V28.1346C50.7469 28.1346 50.7469 28.1346 50.8142 28.1346C51.4199 28.3365 51.9584 28.7404 52.4295 29.2115C52.9007 29.6827 53.2372 30.2211 53.4391 30.8269C53.641 31.4326 53.7083 32.1057 53.7083 32.7114C53.641 33.3845 53.4391 33.9902 53.1026 34.5287L40.0452 57.0762C39.7087 57.682 39.2375 58.1531 38.6991 58.4896C38.1606 58.8935 37.5549 59.0954 36.8818 59.23C36.2088 59.3646 35.5357 59.2973 34.93 59.0954C34.3242 58.8935 33.7184 58.5569 33.18 58.1531C33.18 58.1531 33.1127 58.1531 33.1127 58.0858H33.0454C33.0454 58.0858 33.0454 58.1531 32.9781 58.1531V58.2204L37.5549 66.1625C38.0933 67.0375 38.8337 67.7779 39.7087 68.3163C40.5837 68.8548 41.5933 69.124 42.6702 69.124C43.6797 69.124 44.6893 68.8548 45.6316 68.3163C46.5739 67.7779 47.247 67.0375 47.7854 66.1625L64.8811 36.8171C65.4196 35.9421 65.6888 34.9325 65.6888 33.8556C65.6888 32.846 65.4196 31.8364 64.8811 30.8942C64.3427 30.0192 63.6023 29.2788 62.7274 28.7404C61.8524 28.2692 60.8428 28 59.7659 28ZM28.7378 28C27.1898 28 25.709 28.4711 24.4302 29.2788C23.1514 30.1538 22.1418 31.3653 21.6034 32.7787C20.9976 34.1922 20.863 35.7402 21.1322 37.2209C21.4014 38.7017 22.1418 40.1151 23.2187 41.192C24.2956 42.2689 25.709 43.0093 27.1898 43.2785C28.6705 43.5477 30.2185 43.4131 31.632 42.8073C33.0454 42.2016 34.2569 41.2593 35.1319 39.9805C36.0069 38.7017 36.4107 37.2209 36.4107 35.6729C36.4107 34.6633 36.2088 33.6537 35.8049 32.7114C35.4011 31.7691 34.8627 30.8942 34.1223 30.2211C33.3819 29.4807 32.5742 28.9423 31.632 28.5385C30.757 28.2019 29.7474 28 28.7378 28Z",
                                fill: "url(#paint0_linear_1739_53442)"
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("defs", {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)("linearGradient", {
                                    id: "paint0_linear_1739_53442",
                                    x1: "92.5243",
                                    y1: "74.7364",
                                    x2: "11.8426",
                                    y2: "19.9464",
                                    gradientUnits: "userSpaceOnUse",
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("stop", {
                                            stopColor: "#454D9C"
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("stop", {
                                            offset: "0.5",
                                            stopColor: "#47B8EA"
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("stop", {
                                            offset: "1",
                                            stopColor: "#82C28A"
                                        })
                                    ]
                                })
                            })
                        ]
                    }));
                };

                // EXTERNAL MODULE: ./src/hooks/useLng.ts
                var useLng = __webpack_require__("Vo9m");
                // EXTERNAL MODULE: ./src/hooks/useUA.ts + 2 modules
                var useUA = __webpack_require__("OKG+");; // CONCATENATED MODULE: ./src/components/JumpStack/JumpStack.tsx












                var cardCls = "card translate-y-[var(--y)] scale-[--s] rotate-[var(--r)]";
                var iconWrap = "hover:bg-2 p-4 rounded-full cursor-pointer rtl:rotate-180";
                var TOKENS = new Set([
                    "DAI",
                    "USDC",
                    "USDT",
                    "ETH",
                    "BNB"
                ]);

                function JumpStack(param) {
                    var openQrcode = param.openQrcode;
                    var data = useSWR("earn-list", apis /* fetchEarnList$ */ .EX).data;
                    (0, external_React_.useLayoutEffect)(function() {
                        if (!document) return;
                        var stack = document.querySelector(".stack");
                        if (!stack || !stack.children) return;
                        Array.from(stack.children).reverse().forEach(function(i) {
                            return stack.append(i);
                        });
                    }, []);
                    var onRightClick = function() {
                        var stack = document.querySelector(".stack");
                        var card = document.querySelector(".card:last-child");
                        card.style.animation = "swap 500ms forwards";
                        setTimeout(function() {
                            card.style.animation = "";
                            stack === null || stack === void 0 ? void 0 : stack.prepend(card);
                        }, 500);
                    };
                    var onLeftClick = function() {
                        var stack = document.querySelector(".stack");
                        var card = document.querySelector(".card:first-child");
                        card.style.animation = "swap-reverse 500ms forwards";
                        setTimeout(function() {
                            card.style.animation = "";
                            stack === null || stack === void 0 ? void 0 : stack.append(card);
                        }, 500);
                    };
                    var newData = (0, external_React_.useMemo)(function() {
                        return data === null || data === void 0 ? void 0 : data.filter(function(item) {
                            var ref, ref1;
                            return item.protocol === "Venus" && TOKENS.has((ref = item.tokens) === null || ref === void 0 ? void 0 : (ref1 = ref[0]) === null || ref1 === void 0 ? void 0 : ref1.symbol);
                        });
                    }, [
                        data
                    ]);
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                        className: "mx-auto flex items-center lg:mx-0",
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                onClick: onLeftClick,
                                className: "".concat(iconWrap, " left-stack"),
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)("img", {
                                    src: "".concat(constants /* IMG_URL */ .bV, "/chevron-left-f.svg")
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                className: "stack mx-1 h-[354px] w-[228px] md:mx-7 lg:mx-4",
                                children: newData === null || newData === void 0 ? void 0 : newData.map(function(item, index) {
                                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                                        className: cardCls,
                                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Card, {
                                            data: item,
                                            openQrcode: openQrcode
                                        })
                                    }, index);
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                onClick: onRightClick,
                                className: "".concat(iconWrap, " right-stack"),
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)("img", {
                                    className: "rotate-180",
                                    src: "".concat(constants /* IMG_URL */ .bV, "/chevron-left-f.svg")
                                })
                            })
                        ]
                    });
                }

                function Card(param) {
                    var data = param.data,
                        openQrcode = param.openQrcode;
                    var ref, ref1, ref2, ref3;
                    var t = (0, hooks /* useTranslation */ .$G)();
                    var symbol = (ref = data.tokens) === null || ref === void 0 ? void 0 : (ref1 = ref[0]) === null || ref1 === void 0 ? void 0 : ref1.symbol;
                    var contractAddress = (ref2 = data.tokens) === null || ref2 === void 0 ? void 0 : (ref3 = ref2[0]) === null || ref3 === void 0 ? void 0 : ref3.contractAddress;
                    var lng = (0, useLng /* useLng */ .t)();
                    var isDesktop = (0, useUA /* useUA */ .nD)().isDesktop;
                    var onClick = function() {
                        if (isDesktop) {
                            openQrcode();
                        } else {
                            window.open((0, constants /* getEarnLink */ .UP)(lng));
                        }
                    };
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                        className: "w-[228px] p-6 ",
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsxs)("div", {
                                className: "mb-4 flex items-center",
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        className: "relative mr-4 rtl:ml-4",
                                        children: [
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("img", {
                                                src: "".concat(constants /* STATIC_HOST */ .Xs, "/static/images/crypto/").concat(contractAddress, "-56.png"),
                                                className: "h-[48px] w-[48px]"
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "absolute bottom-[0] right-[17px]",
                                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Venus, {
                                                    className: "h-[24px] w-[24px]"
                                                })
                                            })
                                        ]
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        children: [
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "subtitle-1 t-primary",
                                                children: symbol
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("div", {
                                                className: "body-2 t-secondary",
                                                children: data.protocol
                                            })
                                        ]
                                    })
                                ]
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsxs)("div", {
                                className: " t-buy py-4 text-center",
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "subtitle-2-1",
                                        children: t("apy", {
                                            defaultValue: "APY"
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "headline-3",
                                        children: numberToPercents(data.apr || data.apy || 0, 2, true)
                                    })
                                ]
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(Button /* Button */ .z, {
                                onClick: onClick,
                                className: "!bg-[#EAECEF] hover:!bg-[#FAFAFA]",
                                children: t("invest-now", {
                                    defaultValue: "Invest Now"
                                })
                            })
                        ]
                    });
                }

                ; // CONCATENATED MODULE: ./src/routes/defiwallet/components/Section3.tsx









                function Section3(param) {
                    var openQrcode = param.openQrcode;
                    var t = (0, hooks /* useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(Section /* Section */ .$, {
                        className: "mb-10 mt-[80px] md:mb-[120px] md:mt-[120px]",
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(FadeInComp /* FadeInComp */ .O, {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(Section3_Card, {
                                    className: "flex-col-reverse lg:flex-row lg:rtl:text-left",
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("div", {
                                            className: "relative top-[-26px] overflow-hidden",
                                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Video /* Video */ .n, {
                                                className: "mx-auto flex w-full translate-y-[1px] justify-center md:w-[384px] lg:mx-0",
                                                src: "".concat(constants /* IMG_URL */ .bV, "/switch-v2.mp4")
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(Text, {
                                            title: t("transfer", {
                                                defaultValue: "Transfer"
                                            }),
                                            subtitle: t("transfer-title", {
                                                defaultValue: "Bridge Between Exchange and Web3"
                                            }),
                                            text: t("transfer-text", {
                                                defaultValue: "Why juggle across multiple apps, when you can do it all with one? Transition across CeFi, DeFi and Web3 in a tap. Enjoy quick and easy transfer of funds between exchange and wallet."
                                            })
                                        })
                                    ]
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(FadeInComp /* FadeInComp */ .O, {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(Section3_Card, {
                                    className: "flex-col lg:flex-row",
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(Text, {
                                            title: t("swap", {
                                                defaultValue: "Swap"
                                            }),
                                            subtitle: t("swap-title", {
                                                defaultValue: "Swap tokens cross-chain at the best prices"
                                            }),
                                            text: t("swap-text", {
                                                defaultValue: "Enjoy deep liquidity and low slippage. Powered by Binance Bridge, Web3 Wallet facilitates trades across 30+ networks at the best prices."
                                            })
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)("div", {
                                            className: "overflow-hidden",
                                            children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Video /* Video */ .n, {
                                                className: "mx-auto flex h-[240px] w-full translate-y-[1px] justify-center md:h-[300px] md:w-[384px] lg:mx-0",
                                                src: "".concat(constants /* IMG_URL */ .bV, "/swap-v3.mp4")
                                            })
                                        })
                                    ]
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(FadeInComp /* FadeInComp */ .O, {
                                children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(Section3_Card, {
                                    className: "flex-col-reverse lg:flex-row",
                                    children: [
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(JumpStack, {
                                            openQrcode: openQrcode
                                        }),
                                        /*#__PURE__*/
                                        (0, jsx_runtime.jsx)(Text, {
                                            title: t("earn", {
                                                defaultValue: "Earn"
                                            }),
                                            subtitle: t("earn-title", {
                                                defaultValue: "Grow your portfolio with one click"
                                            }),
                                            text: t("earn-text", {
                                                defaultValue: "Put your idle crypto to work. Find the best opportunities to earn yield on your assets in seconds."
                                            })
                                        })
                                    ]
                                })
                            })
                        ]
                    });
                }

                function Section3_Card(_param) {
                    var className = _param.className,
                        props = (0, _object_without_properties /* default */ .Z)(_param, [
                            "className"
                        ]);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", (0, _object_spread /* default */ .Z)({
                        className: "flex w-full justify-between py-10 md:mb-12 md:p-12 lg:mb-15  lg:px-[102px] lg:py-[48px] ".concat(className)
                    }, props));
                }

                function Text(param) {
                    var title = param.title,
                        subtitle = param.subtitle,
                        text = param.text;
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)("div", {
                        className: "mb-[48px] flex w-full flex-col justify-center md:mb-[64px] lg:mb-0 lg:w-[486px]",
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                className: "t-primary-hover subtitle-1 mb-2",
                                children: title
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("h6", {
                                className: "t-primary headline-6 md:headline-3 mb-6",
                                children: subtitle
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)("div", {
                                className: "body-2 t-secondary",
                                children: text
                            })
                        ]
                    });
                }


                /***/
            }),

        /***/
        "GDbF":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "f": () => ( /* binding */ Section4)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread.mjs
                var _object_spread = __webpack_require__("ys0/");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_without_properties.mjs + 1 modules
                var _object_without_properties = __webpack_require__("Cmqe");
                // EXTERNAL MODULE: ./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
                var jsx_runtime = __webpack_require__("oUqw");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/ssr-window.esm.mjs
                /**
                 * SSR Window 4.0.2
                 * Better handling for window object in SSR environment
                 * https://github.com/nolimits4web/ssr-window
                 *
                 * Copyright 2021, Vladimir Kharlampidi
                 *
                 * Licensed under MIT
                 *
                 * Released on: December 13, 2021
                 */
                /* eslint-disable no-param-reassign */
                function ssr_window_esm_isObject(obj) {
                    return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
                }

                function extend(target, src) {
                    if (target === void 0) {
                        target = {};
                    }
                    if (src === void 0) {
                        src = {};
                    }
                    Object.keys(src).forEach(key => {
                        if (typeof target[key] === 'undefined') target[key] = src[key];
                        else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) {
                            extend(target[key], src[key]);
                        }
                    });
                }
                const ssrDocument = {
                    body: {},
                    addEventListener() {},
                    removeEventListener() {},
                    activeElement: {
                        blur() {},
                        nodeName: ''
                    },
                    querySelector() {
                        return null;
                    },
                    querySelectorAll() {
                        return [];
                    },
                    getElementById() {
                        return null;
                    },
                    createEvent() {
                        return {
                            initEvent() {}
                        };
                    },
                    createElement() {
                        return {
                            children: [],
                            childNodes: [],
                            style: {},
                            setAttribute() {},
                            getElementsByTagName() {
                                return [];
                            }
                        };
                    },
                    createElementNS() {
                        return {};
                    },
                    importNode() {
                        return null;
                    },
                    location: {
                        hash: '',
                        host: '',
                        hostname: '',
                        href: '',
                        origin: '',
                        pathname: '',
                        protocol: '',
                        search: ''
                    }
                };

                function ssr_window_esm_getDocument() {
                    const doc = typeof document !== 'undefined' ? document : {};
                    extend(doc, ssrDocument);
                    return doc;
                }
                const ssrWindow = {
                    document: ssrDocument,
                    navigator: {
                        userAgent: ''
                    },
                    location: {
                        hash: '',
                        host: '',
                        hostname: '',
                        href: '',
                        origin: '',
                        pathname: '',
                        protocol: '',
                        search: ''
                    },
                    history: {
                        replaceState() {},
                        pushState() {},
                        go() {},
                        back() {}
                    },
                    CustomEvent: function CustomEvent() {
                        return this;
                    },
                    addEventListener() {},
                    removeEventListener() {},
                    getComputedStyle() {
                        return {
                            getPropertyValue() {
                                return '';
                            }
                        };
                    },
                    Image() {},
                    Date() {},
                    screen: {},
                    setTimeout() {},
                    clearTimeout() {},
                    matchMedia() {
                        return {};
                    },
                    requestAnimationFrame(callback) {
                        if (typeof setTimeout === 'undefined') {
                            callback();
                            return null;
                        }
                        return setTimeout(callback, 0);
                    },
                    cancelAnimationFrame(id) {
                        if (typeof setTimeout === 'undefined') {
                            return;
                        }
                        clearTimeout(id);
                    }
                };

                function ssr_window_esm_getWindow() {
                    const win = true ? window : 0;
                    extend(win, ssrWindow);
                    return win;
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/utils.mjs


                function deleteProps(obj) {
                    const object = obj;
                    Object.keys(object).forEach(key => {
                        try {
                            object[key] = null;
                        } catch (e) {
                            // no getter for object
                        }
                        try {
                            delete object[key];
                        } catch (e) {
                            // something got wrong
                        }
                    });
                }

                function utils_nextTick(callback, delay) {
                    if (delay === void 0) {
                        delay = 0;
                    }
                    return setTimeout(callback, delay);
                }

                function utils_now() {
                    return Date.now();
                }

                function utils_getComputedStyle(el) {
                    const window = ssr_window_esm_getWindow();
                    let style;
                    if (window.getComputedStyle) {
                        style = window.getComputedStyle(el, null);
                    }
                    if (!style && el.currentStyle) {
                        style = el.currentStyle;
                    }
                    if (!style) {
                        style = el.style;
                    }
                    return style;
                }

                function utils_getTranslate(el, axis) {
                    if (axis === void 0) {
                        axis = 'x';
                    }
                    const window = ssr_window_esm_getWindow();
                    let matrix;
                    let curTransform;
                    let transformMatrix;
                    const curStyle = utils_getComputedStyle(el);
                    if (window.WebKitCSSMatrix) {
                        curTransform = curStyle.transform || curStyle.webkitTransform;
                        if (curTransform.split(',').length > 6) {
                            curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
                        }
                        // Some old versions of Webkit choke when 'none' is passed; pass
                        // empty string instead in this case
                        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
                    } else {
                        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                        matrix = transformMatrix.toString().split(',');
                    }
                    if (axis === 'x') {
                        // Latest Chrome and webkits Fix
                        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
                        // Crazy IE10 Matrix
                        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
                        // Normal Browsers
                        else curTransform = parseFloat(matrix[4]);
                    }
                    if (axis === 'y') {
                        // Latest Chrome and webkits Fix
                        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
                        // Crazy IE10 Matrix
                        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
                        // Normal Browsers
                        else curTransform = parseFloat(matrix[5]);
                    }
                    return curTransform || 0;
                }

                function utils_isObject(o) {
                    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
                }

                function isNode(node) {
                    // eslint-disable-next-line
                    if (true && typeof window.HTMLElement !== 'undefined') {
                        return node instanceof HTMLElement;
                    }
                    return node && (node.nodeType === 1 || node.nodeType === 11);
                }

                function utils_extend() {
                    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
                    const noExtend = ['__proto__', 'constructor', 'prototype'];
                    for (let i = 1; i < arguments.length; i += 1) {
                        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
                        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
                            const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                            for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                                const nextKey = keysArray[nextIndex];
                                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                                if (desc !== undefined && desc.enumerable) {
                                    if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                                        if (nextSource[nextKey].__swiper__) {
                                            to[nextKey] = nextSource[nextKey];
                                        } else {
                                            utils_extend(to[nextKey], nextSource[nextKey]);
                                        }
                                    } else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                                        to[nextKey] = {};
                                        if (nextSource[nextKey].__swiper__) {
                                            to[nextKey] = nextSource[nextKey];
                                        } else {
                                            utils_extend(to[nextKey], nextSource[nextKey]);
                                        }
                                    } else {
                                        to[nextKey] = nextSource[nextKey];
                                    }
                                }
                            }
                        }
                    }
                    return to;
                }

                function utils_setCSSProperty(el, varName, varValue) {
                    el.style.setProperty(varName, varValue);
                }

                function animateCSSModeScroll(_ref) {
                    let {
                        swiper,
                        targetPosition,
                        side
                    } = _ref;
                    const window = ssr_window_esm_getWindow();
                    const startPosition = -swiper.translate;
                    let startTime = null;
                    let time;
                    const duration = swiper.params.speed;
                    swiper.wrapperEl.style.scrollSnapType = 'none';
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    const dir = targetPosition > startPosition ? 'next' : 'prev';
                    const isOutOfBound = (current, target) => {
                        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
                    };
                    const animate = () => {
                        time = new Date().getTime();
                        if (startTime === null) {
                            startTime = time;
                        }
                        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
                        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                        if (isOutOfBound(currentPosition, targetPosition)) {
                            currentPosition = targetPosition;
                        }
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                        if (isOutOfBound(currentPosition, targetPosition)) {
                            swiper.wrapperEl.style.overflow = 'hidden';
                            swiper.wrapperEl.style.scrollSnapType = '';
                            setTimeout(() => {
                                swiper.wrapperEl.style.overflow = '';
                                swiper.wrapperEl.scrollTo({
                                    [side]: currentPosition
                                });
                            });
                            window.cancelAnimationFrame(swiper.cssModeFrameID);
                            return;
                        }
                        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
                    };
                    animate();
                }

                function utils_getSlideTransformEl(slideEl) {
                    return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;
                }

                function utils_elementChildren(element, selector) {
                    if (selector === void 0) {
                        selector = '';
                    }
                    return [...element.children].filter(el => el.matches(selector));
                }

                function utils_createElement(tag, classes) {
                    if (classes === void 0) {
                        classes = [];
                    }
                    const el = document.createElement(tag);
                    el.classList.add(...(Array.isArray(classes) ? classes : [classes]));
                    return el;
                }

                function utils_elementOffset(el) {
                    const window = getWindow();
                    const document = getDocument();
                    const box = el.getBoundingClientRect();
                    const body = document.body;
                    const clientTop = el.clientTop || body.clientTop || 0;
                    const clientLeft = el.clientLeft || body.clientLeft || 0;
                    const scrollTop = el === window ? window.scrollY : el.scrollTop;
                    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
                    return {
                        top: box.top + scrollTop - clientTop,
                        left: box.left + scrollLeft - clientLeft
                    };
                }

                function elementPrevAll(el, selector) {
                    const prevEls = [];
                    while (el.previousElementSibling) {
                        const prev = el.previousElementSibling; // eslint-disable-line
                        if (selector) {
                            if (prev.matches(selector)) prevEls.push(prev);
                        } else prevEls.push(prev);
                        el = prev;
                    }
                    return prevEls;
                }

                function elementNextAll(el, selector) {
                    const nextEls = [];
                    while (el.nextElementSibling) {
                        const next = el.nextElementSibling; // eslint-disable-line
                        if (selector) {
                            if (next.matches(selector)) nextEls.push(next);
                        } else nextEls.push(next);
                        el = next;
                    }
                    return nextEls;
                }

                function elementStyle(el, prop) {
                    const window = ssr_window_esm_getWindow();
                    return window.getComputedStyle(el, null).getPropertyValue(prop);
                }

                function utils_elementIndex(el) {
                    let child = el;
                    let i;
                    if (child) {
                        i = 0;
                        // eslint-disable-next-line
                        while ((child = child.previousSibling) !== null) {
                            if (child.nodeType === 1) i += 1;
                        }
                        return i;
                    }
                    return undefined;
                }

                function utils_elementParents(el, selector) {
                    const parents = []; // eslint-disable-line
                    let parent = el.parentElement; // eslint-disable-line
                    while (parent) {
                        if (selector) {
                            if (parent.matches(selector)) parents.push(parent);
                        } else {
                            parents.push(parent);
                        }
                        parent = parent.parentElement;
                    }
                    return parents;
                }

                function utils_elementTransitionEnd(el, callback) {
                    function fireCallBack(e) {
                        if (e.target !== el) return;
                        callback.call(el, e);
                        el.removeEventListener('transitionend', fireCallBack);
                    }
                    if (callback) {
                        el.addEventListener('transitionend', fireCallBack);
                    }
                }

                function elementOuterSize(el, size, includeMargins) {
                    const window = ssr_window_esm_getWindow();
                    if (includeMargins) {
                        return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
                    }
                    return el.offsetWidth;
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/swiper-core.mjs



                let support;

                function calcSupport() {
                    const window = ssr_window_esm_getWindow();
                    const document = ssr_window_esm_getDocument();
                    return {
                        smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
                        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
                    };
                }

                function getSupport() {
                    if (!support) {
                        support = calcSupport();
                    }
                    return support;
                }

                let deviceCached;

                function calcDevice(_temp) {
                    let {
                        userAgent
                    } = _temp === void 0 ? {} : _temp;
                    const support = getSupport();
                    const window = ssr_window_esm_getWindow();
                    const platform = window.navigator.platform;
                    const ua = userAgent || window.navigator.userAgent;
                    const device = {
                        ios: false,
                        android: false
                    };
                    const screenWidth = window.screen.width;
                    const screenHeight = window.screen.height;
                    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
                    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
                    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
                    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
                    const windows = platform === 'Win32';
                    let macos = platform === 'MacIntel';

                    // iPadOs 13 fix
                    const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
                    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                        ipad = ua.match(/(Version)\/([\d.]+)/);
                        if (!ipad) ipad = [0, 1, '13_0_0'];
                        macos = false;
                    }

                    // Android
                    if (android && !windows) {
                        device.os = 'android';
                        device.android = true;
                    }
                    if (ipad || iphone || ipod) {
                        device.os = 'ios';
                        device.ios = true;
                    }

                    // Export object
                    return device;
                }

                function getDevice(overrides) {
                    if (overrides === void 0) {
                        overrides = {};
                    }
                    if (!deviceCached) {
                        deviceCached = calcDevice(overrides);
                    }
                    return deviceCached;
                }

                let browser;

                function calcBrowser() {
                    const window = ssr_window_esm_getWindow();
                    let needPerspectiveFix = false;

                    function isSafari() {
                        const ua = window.navigator.userAgent.toLowerCase();
                        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
                    }
                    if (isSafari()) {
                        const ua = String(window.navigator.userAgent);
                        if (ua.includes('Version/')) {
                            const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
                            needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                        }
                    }
                    return {
                        isSafari: needPerspectiveFix || isSafari(),
                        needPerspectiveFix,
                        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
                    };
                }

                function getBrowser() {
                    if (!browser) {
                        browser = calcBrowser();
                    }
                    return browser;
                }

                function Resize(_ref) {
                    let {
                        swiper,
                        on,
                        emit
                    } = _ref;
                    const window = ssr_window_esm_getWindow();
                    let observer = null;
                    let animationFrame = null;
                    const resizeHandler = () => {
                        if (!swiper || swiper.destroyed || !swiper.initialized) return;
                        emit('beforeResize');
                        emit('resize');
                    };
                    const createObserver = () => {
                        if (!swiper || swiper.destroyed || !swiper.initialized) return;
                        observer = new ResizeObserver(entries => {
                            animationFrame = window.requestAnimationFrame(() => {
                                const {
                                    width,
                                    height
                                } = swiper;
                                let newWidth = width;
                                let newHeight = height;
                                entries.forEach(_ref2 => {
                                    let {
                                        contentBoxSize,
                                        contentRect,
                                        target
                                    } = _ref2;
                                    if (target && target !== swiper.el) return;
                                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                                });
                                if (newWidth !== width || newHeight !== height) {
                                    resizeHandler();
                                }
                            });
                        });
                        observer.observe(swiper.el);
                    };
                    const removeObserver = () => {
                        if (animationFrame) {
                            window.cancelAnimationFrame(animationFrame);
                        }
                        if (observer && observer.unobserve && swiper.el) {
                            observer.unobserve(swiper.el);
                            observer = null;
                        }
                    };
                    const orientationChangeHandler = () => {
                        if (!swiper || swiper.destroyed || !swiper.initialized) return;
                        emit('orientationchange');
                    };
                    on('init', () => {
                        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
                            createObserver();
                            return;
                        }
                        window.addEventListener('resize', resizeHandler);
                        window.addEventListener('orientationchange', orientationChangeHandler);
                    });
                    on('destroy', () => {
                        removeObserver();
                        window.removeEventListener('resize', resizeHandler);
                        window.removeEventListener('orientationchange', orientationChangeHandler);
                    });
                }

                function Observer(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    const observers = [];
                    const window = ssr_window_esm_getWindow();
                    const attach = function(target, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                        const observer = new ObserverFunc(mutations => {
                            // The observerUpdate event should only be triggered
                            // once despite the number of mutations.  Additional
                            // triggers are redundant and are very costly
                            if (swiper.__preventObserver__) return;
                            if (mutations.length === 1) {
                                emit('observerUpdate', mutations[0]);
                                return;
                            }
                            const observerUpdate = function observerUpdate() {
                                emit('observerUpdate', mutations[0]);
                            };
                            if (window.requestAnimationFrame) {
                                window.requestAnimationFrame(observerUpdate);
                            } else {
                                window.setTimeout(observerUpdate, 0);
                            }
                        });
                        observer.observe(target, {
                            attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                            childList: typeof options.childList === 'undefined' ? true : options.childList,
                            characterData: typeof options.characterData === 'undefined' ? true : options.characterData
                        });
                        observers.push(observer);
                    };
                    const init = () => {
                        if (!swiper.params.observer) return;
                        if (swiper.params.observeParents) {
                            const containerParents = utils_elementParents(swiper.hostEl);
                            for (let i = 0; i < containerParents.length; i += 1) {
                                attach(containerParents[i]);
                            }
                        }
                        // Observe container
                        attach(swiper.hostEl, {
                            childList: swiper.params.observeSlideChildren
                        });

                        // Observe wrapper
                        attach(swiper.wrapperEl, {
                            attributes: false
                        });
                    };
                    const destroy = () => {
                        observers.forEach(observer => {
                            observer.disconnect();
                        });
                        observers.splice(0, observers.length);
                    };
                    extendParams({
                        observer: false,
                        observeParents: false,
                        observeSlideChildren: false
                    });
                    on('init', init);
                    on('destroy', destroy);
                }

                /* eslint-disable no-underscore-dangle */

                var eventsEmitter = {
                    on(events, handler, priority) {
                        const self = this;
                        if (!self.eventsListeners || self.destroyed) return self;
                        if (typeof handler !== 'function') return self;
                        const method = priority ? 'unshift' : 'push';
                        events.split(' ').forEach(event => {
                            if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                            self.eventsListeners[event][method](handler);
                        });
                        return self;
                    },
                    once(events, handler, priority) {
                        const self = this;
                        if (!self.eventsListeners || self.destroyed) return self;
                        if (typeof handler !== 'function') return self;

                        function onceHandler() {
                            self.off(events, onceHandler);
                            if (onceHandler.__emitterProxy) {
                                delete onceHandler.__emitterProxy;
                            }
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            handler.apply(self, args);
                        }
                        onceHandler.__emitterProxy = handler;
                        return self.on(events, onceHandler, priority);
                    },
                    onAny(handler, priority) {
                        const self = this;
                        if (!self.eventsListeners || self.destroyed) return self;
                        if (typeof handler !== 'function') return self;
                        const method = priority ? 'unshift' : 'push';
                        if (self.eventsAnyListeners.indexOf(handler) < 0) {
                            self.eventsAnyListeners[method](handler);
                        }
                        return self;
                    },
                    offAny(handler) {
                        const self = this;
                        if (!self.eventsListeners || self.destroyed) return self;
                        if (!self.eventsAnyListeners) return self;
                        const index = self.eventsAnyListeners.indexOf(handler);
                        if (index >= 0) {
                            self.eventsAnyListeners.splice(index, 1);
                        }
                        return self;
                    },
                    off(events, handler) {
                        const self = this;
                        if (!self.eventsListeners || self.destroyed) return self;
                        if (!self.eventsListeners) return self;
                        events.split(' ').forEach(event => {
                            if (typeof handler === 'undefined') {
                                self.eventsListeners[event] = [];
                            } else if (self.eventsListeners[event]) {
                                self.eventsListeners[event].forEach((eventHandler, index) => {
                                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                                        self.eventsListeners[event].splice(index, 1);
                                    }
                                });
                            }
                        });
                        return self;
                    },
                    emit() {
                        const self = this;
                        if (!self.eventsListeners || self.destroyed) return self;
                        if (!self.eventsListeners) return self;
                        let events;
                        let data;
                        let context;
                        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }
                        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
                            events = args[0];
                            data = args.slice(1, args.length);
                            context = self;
                        } else {
                            events = args[0].events;
                            data = args[0].data;
                            context = args[0].context || self;
                        }
                        data.unshift(context);
                        const eventsArray = Array.isArray(events) ? events : events.split(' ');
                        eventsArray.forEach(event => {
                            if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                                self.eventsAnyListeners.forEach(eventHandler => {
                                    eventHandler.apply(context, [event, ...data]);
                                });
                            }
                            if (self.eventsListeners && self.eventsListeners[event]) {
                                self.eventsListeners[event].forEach(eventHandler => {
                                    eventHandler.apply(context, data);
                                });
                            }
                        });
                        return self;
                    }
                };

                function updateSize() {
                    const swiper = this;
                    let width;
                    let height;
                    const el = swiper.el;
                    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
                        width = swiper.params.width;
                    } else {
                        width = el.clientWidth;
                    }
                    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
                        height = swiper.params.height;
                    } else {
                        height = el.clientHeight;
                    }
                    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
                        return;
                    }

                    // Subtract paddings
                    width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
                    height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
                    if (Number.isNaN(width)) width = 0;
                    if (Number.isNaN(height)) height = 0;
                    Object.assign(swiper, {
                        width,
                        height,
                        size: swiper.isHorizontal() ? width : height
                    });
                }

                function updateSlides() {
                    const swiper = this;

                    function getDirectionLabel(property) {
                        if (swiper.isHorizontal()) {
                            return property;
                        }
                        // prettier-ignore
                        return {
                            'width': 'height',
                            'margin-top': 'margin-left',
                            'margin-bottom ': 'margin-right',
                            'margin-left': 'margin-top',
                            'margin-right': 'margin-bottom',
                            'padding-left': 'padding-top',
                            'padding-right': 'padding-bottom',
                            'marginRight': 'marginBottom'
                        }[property];
                    }

                    function getDirectionPropertyValue(node, label) {
                        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
                    }
                    const params = swiper.params;
                    const {
                        wrapperEl,
                        slidesEl,
                        size: swiperSize,
                        rtlTranslate: rtl,
                        wrongRTL
                    } = swiper;
                    const isVirtual = swiper.virtual && params.virtual.enabled;
                    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
                    const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
                    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
                    let snapGrid = [];
                    const slidesGrid = [];
                    const slidesSizesGrid = [];
                    let offsetBefore = params.slidesOffsetBefore;
                    if (typeof offsetBefore === 'function') {
                        offsetBefore = params.slidesOffsetBefore.call(swiper);
                    }
                    let offsetAfter = params.slidesOffsetAfter;
                    if (typeof offsetAfter === 'function') {
                        offsetAfter = params.slidesOffsetAfter.call(swiper);
                    }
                    const previousSnapGridLength = swiper.snapGrid.length;
                    const previousSlidesGridLength = swiper.slidesGrid.length;
                    let spaceBetween = params.spaceBetween;
                    let slidePosition = -offsetBefore;
                    let prevSlideSize = 0;
                    let index = 0;
                    if (typeof swiperSize === 'undefined') {
                        return;
                    }
                    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
                    } else if (typeof spaceBetween === 'string') {
                        spaceBetween = parseFloat(spaceBetween);
                    }
                    swiper.virtualSize = -spaceBetween;

                    // reset margins
                    slides.forEach(slideEl => {
                        if (rtl) {
                            slideEl.style.marginLeft = '';
                        } else {
                            slideEl.style.marginRight = '';
                        }
                        slideEl.style.marginBottom = '';
                        slideEl.style.marginTop = '';
                    });

                    // reset cssMode offsets
                    if (params.centeredSlides && params.cssMode) {
                        utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
                        utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
                    }
                    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
                    if (gridEnabled) {
                        swiper.grid.initSlides(slidesLength);
                    }

                    // Calc slides
                    let slideSize;
                    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
                        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
                    }).length > 0;
                    for (let i = 0; i < slidesLength; i += 1) {
                        slideSize = 0;
                        let slide;
                        if (slides[i]) slide = slides[i];
                        if (gridEnabled) {
                            swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
                        }
                        if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

                        if (params.slidesPerView === 'auto') {
                            if (shouldResetSlideSize) {
                                slides[i].style[getDirectionLabel('width')] = ``;
                            }
                            const slideStyles = getComputedStyle(slide);
                            const currentTransform = slide.style.transform;
                            const currentWebKitTransform = slide.style.webkitTransform;
                            if (currentTransform) {
                                slide.style.transform = 'none';
                            }
                            if (currentWebKitTransform) {
                                slide.style.webkitTransform = 'none';
                            }
                            if (params.roundLengths) {
                                slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);
                            } else {
                                // eslint-disable-next-line
                                const width = getDirectionPropertyValue(slideStyles, 'width');
                                const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
                                const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
                                const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
                                const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
                                const boxSizing = slideStyles.getPropertyValue('box-sizing');
                                if (boxSizing && boxSizing === 'border-box') {
                                    slideSize = width + marginLeft + marginRight;
                                } else {
                                    const {
                                        clientWidth,
                                        offsetWidth
                                    } = slide;
                                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                                }
                            }
                            if (currentTransform) {
                                slide.style.transform = currentTransform;
                            }
                            if (currentWebKitTransform) {
                                slide.style.webkitTransform = currentWebKitTransform;
                            }
                            if (params.roundLengths) slideSize = Math.floor(slideSize);
                        } else {
                            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                            if (params.roundLengths) slideSize = Math.floor(slideSize);
                            if (slides[i]) {
                                slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
                            }
                        }
                        if (slides[i]) {
                            slides[i].swiperSlideSize = slideSize;
                        }
                        slidesSizesGrid.push(slideSize);
                        if (params.centeredSlides) {
                            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                            if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                            if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                            if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                            slidesGrid.push(slidePosition);
                        } else {
                            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                            slidesGrid.push(slidePosition);
                            slidePosition = slidePosition + slideSize + spaceBetween;
                        }
                        swiper.virtualSize += slideSize + spaceBetween;
                        prevSlideSize = slideSize;
                        index += 1;
                    }
                    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
                    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
                        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
                    }
                    if (params.setWrapperSize) {
                        wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
                    }
                    if (gridEnabled) {
                        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
                    }

                    // Remove last grid elements depending on width
                    if (!params.centeredSlides) {
                        const newSlidesGrid = [];
                        for (let i = 0; i < snapGrid.length; i += 1) {
                            let slidesGridItem = snapGrid[i];
                            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                            if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                                newSlidesGrid.push(slidesGridItem);
                            }
                        }
                        snapGrid = newSlidesGrid;
                        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                            snapGrid.push(swiper.virtualSize - swiperSize);
                        }
                    }
                    if (isVirtual && params.loop) {
                        const size = slidesSizesGrid[0] + spaceBetween;
                        if (params.slidesPerGroup > 1) {
                            const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                            const groupSize = size * params.slidesPerGroup;
                            for (let i = 0; i < groups; i += 1) {
                                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                            }
                        }
                        for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                            if (params.slidesPerGroup === 1) {
                                snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                            }
                            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                            swiper.virtualSize += size;
                        }
                    }
                    if (snapGrid.length === 0) snapGrid = [0];
                    if (spaceBetween !== 0) {
                        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
                        slides.filter((_, slideIndex) => {
                            if (!params.cssMode || params.loop) return true;
                            if (slideIndex === slides.length - 1) {
                                return false;
                            }
                            return true;
                        }).forEach(slideEl => {
                            slideEl.style[key] = `${spaceBetween}px`;
                        });
                    }
                    if (params.centeredSlides && params.centeredSlidesBounds) {
                        let allSlidesSize = 0;
                        slidesSizesGrid.forEach(slideSizeValue => {
                            allSlidesSize += slideSizeValue + (spaceBetween || 0);
                        });
                        allSlidesSize -= spaceBetween;
                        const maxSnap = allSlidesSize - swiperSize;
                        snapGrid = snapGrid.map(snap => {
                            if (snap <= 0) return -offsetBefore;
                            if (snap > maxSnap) return maxSnap + offsetAfter;
                            return snap;
                        });
                    }
                    if (params.centerInsufficientSlides) {
                        let allSlidesSize = 0;
                        slidesSizesGrid.forEach(slideSizeValue => {
                            allSlidesSize += slideSizeValue + (spaceBetween || 0);
                        });
                        allSlidesSize -= spaceBetween;
                        if (allSlidesSize < swiperSize) {
                            const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                            snapGrid.forEach((snap, snapIndex) => {
                                snapGrid[snapIndex] = snap - allSlidesOffset;
                            });
                            slidesGrid.forEach((snap, snapIndex) => {
                                slidesGrid[snapIndex] = snap + allSlidesOffset;
                            });
                        }
                    }
                    Object.assign(swiper, {
                        slides,
                        snapGrid,
                        slidesGrid,
                        slidesSizesGrid
                    });
                    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                        utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
                        utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                        const addToSnapGrid = -swiper.snapGrid[0];
                        const addToSlidesGrid = -swiper.slidesGrid[0];
                        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
                        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
                    }
                    if (slidesLength !== previousSlidesLength) {
                        swiper.emit('slidesLengthChange');
                    }
                    if (snapGrid.length !== previousSnapGridLength) {
                        if (swiper.params.watchOverflow) swiper.checkOverflow();
                        swiper.emit('snapGridLengthChange');
                    }
                    if (slidesGrid.length !== previousSlidesGridLength) {
                        swiper.emit('slidesGridLengthChange');
                    }
                    if (params.watchSlidesProgress) {
                        swiper.updateSlidesOffset();
                    }
                    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
                        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                        if (slidesLength <= params.maxBackfaceHiddenSlides) {
                            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                        } else if (hasClassBackfaceClassAdded) {
                            swiper.el.classList.remove(backFaceHiddenClass);
                        }
                    }
                }

                function updateAutoHeight(speed) {
                    const swiper = this;
                    const activeSlides = [];
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    let newHeight = 0;
                    let i;
                    if (typeof speed === 'number') {
                        swiper.setTransition(speed);
                    } else if (speed === true) {
                        swiper.setTransition(swiper.params.speed);
                    }
                    const getSlideByIndex = index => {
                        if (isVirtual) {
                            return swiper.slides[swiper.getSlideIndexByData(index)];
                        }
                        return swiper.slides[index];
                    };
                    // Find slides currently in view
                    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
                        if (swiper.params.centeredSlides) {
                            (swiper.visibleSlides || []).forEach(slide => {
                                activeSlides.push(slide);
                            });
                        } else {
                            for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                                const index = swiper.activeIndex + i;
                                if (index > swiper.slides.length && !isVirtual) break;
                                activeSlides.push(getSlideByIndex(index));
                            }
                        }
                    } else {
                        activeSlides.push(getSlideByIndex(swiper.activeIndex));
                    }

                    // Find new height from highest slide in view
                    for (i = 0; i < activeSlides.length; i += 1) {
                        if (typeof activeSlides[i] !== 'undefined') {
                            const height = activeSlides[i].offsetHeight;
                            newHeight = height > newHeight ? height : newHeight;
                        }
                    }

                    // Update Height
                    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
                }

                function updateSlidesOffset() {
                    const swiper = this;
                    const slides = swiper.slides;
                    // eslint-disable-next-line
                    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
                    for (let i = 0; i < slides.length; i += 1) {
                        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
                    }
                }

                function updateSlidesProgress(translate) {
                    if (translate === void 0) {
                        translate = this && this.translate || 0;
                    }
                    const swiper = this;
                    const params = swiper.params;
                    const {
                        slides,
                        rtlTranslate: rtl,
                        snapGrid
                    } = swiper;
                    if (slides.length === 0) return;
                    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
                    let offsetCenter = -translate;
                    if (rtl) offsetCenter = translate;

                    // Visible Slides
                    slides.forEach(slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass);
                    });
                    swiper.visibleSlidesIndexes = [];
                    swiper.visibleSlides = [];
                    let spaceBetween = params.spaceBetween;
                    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
                    } else if (typeof spaceBetween === 'string') {
                        spaceBetween = parseFloat(spaceBetween);
                    }
                    for (let i = 0; i < slides.length; i += 1) {
                        const slide = slides[i];
                        let slideOffset = slide.swiperSlideOffset;
                        if (params.cssMode && params.centeredSlides) {
                            slideOffset -= slides[0].swiperSlideOffset;
                        }
                        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                        const slideBefore = -(offsetCenter - slideOffset);
                        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                        if (isVisible) {
                            swiper.visibleSlides.push(slide);
                            swiper.visibleSlidesIndexes.push(i);
                            slides[i].classList.add(params.slideVisibleClass);
                        }
                        slide.progress = rtl ? -slideProgress : slideProgress;
                        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
                    }
                }

                function updateProgress(translate) {
                    const swiper = this;
                    if (typeof translate === 'undefined') {
                        const multiplier = swiper.rtlTranslate ? -1 : 1;
                        // eslint-disable-next-line
                        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
                    }
                    const params = swiper.params;
                    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                    let {
                        progress,
                        isBeginning,
                        isEnd,
                        progressLoop
                    } = swiper;
                    const wasBeginning = isBeginning;
                    const wasEnd = isEnd;
                    if (translatesDiff === 0) {
                        progress = 0;
                        isBeginning = true;
                        isEnd = true;
                    } else {
                        progress = (translate - swiper.minTranslate()) / translatesDiff;
                        const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                        const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                        isBeginning = isBeginningRounded || progress <= 0;
                        isEnd = isEndRounded || progress >= 1;
                        if (isBeginningRounded) progress = 0;
                        if (isEndRounded) progress = 1;
                    }
                    if (params.loop) {
                        const firstSlideIndex = swiper.getSlideIndexByData(0);
                        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                        const translateAbs = Math.abs(translate);
                        if (translateAbs >= firstSlideTranslate) {
                            progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
                        } else {
                            progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                        }
                        if (progressLoop > 1) progressLoop -= 1;
                    }
                    Object.assign(swiper, {
                        progress,
                        progressLoop,
                        isBeginning,
                        isEnd
                    });
                    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
                    if (isBeginning && !wasBeginning) {
                        swiper.emit('reachBeginning toEdge');
                    }
                    if (isEnd && !wasEnd) {
                        swiper.emit('reachEnd toEdge');
                    }
                    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
                        swiper.emit('fromEdge');
                    }
                    swiper.emit('progress', progress);
                }

                function updateSlidesClasses() {
                    const swiper = this;
                    const {
                        slides,
                        params,
                        slidesEl,
                        activeIndex
                    } = swiper;
                    const isVirtual = swiper.virtual && params.virtual.enabled;
                    const getFilteredSlide = selector => {
                        return utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
                    };
                    slides.forEach(slideEl => {
                        slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                    });
                    let activeSlide;
                    if (isVirtual) {
                        if (params.loop) {
                            let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                            if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                            if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                            activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
                        } else {
                            activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
                        }
                    } else {
                        activeSlide = slides[activeIndex];
                    }
                    if (activeSlide) {
                        // Active classes
                        activeSlide.classList.add(params.slideActiveClass);

                        // Next Slide
                        let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                        if (params.loop && !nextSlide) {
                            nextSlide = slides[0];
                        }
                        if (nextSlide) {
                            nextSlide.classList.add(params.slideNextClass);
                        }
                        // Prev Slide
                        let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                        if (params.loop && !prevSlide === 0) {
                            prevSlide = slides[slides.length - 1];
                        }
                        if (prevSlide) {
                            prevSlide.classList.add(params.slidePrevClass);
                        }
                    }
                    swiper.emitSlidesClasses();
                }

                const processLazyPreloader = (swiper, imageEl) => {
                    if (!swiper || swiper.destroyed || !swiper.params) return;
                    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
                    const slideEl = imageEl.closest(slideSelector());
                    if (slideEl) {
                        let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (!lazyEl && swiper.isElement) {
                            if (slideEl.shadowRoot) {
                                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                            } else {
                                // init later
                                requestAnimationFrame(() => {
                                    if (slideEl.shadowRoot) {
                                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                                        if (lazyEl) lazyEl.remove();
                                    }
                                });
                            }
                        }
                        if (lazyEl) lazyEl.remove();
                    }
                };
                const unlazy = (swiper, index) => {
                    if (!swiper.slides[index]) return;
                    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
                    if (imageEl) imageEl.removeAttribute('loading');
                };
                const preload = swiper => {
                    if (!swiper || swiper.destroyed || !swiper.params) return;
                    let amount = swiper.params.lazyPreloadPrevNext;
                    const len = swiper.slides.length;
                    if (!len || !amount || amount < 0) return;
                    amount = Math.min(amount, len);
                    const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
                    const activeIndex = swiper.activeIndex;
                    if (swiper.params.grid && swiper.params.grid.rows > 1) {
                        const activeColumn = activeIndex;
                        const preloadColumns = [activeColumn - amount];
                        preloadColumns.push(...Array.from({
                            length: amount
                        }).map((_, i) => {
                            return activeColumn + slidesPerView + i;
                        }));
                        swiper.slides.forEach((slideEl, i) => {
                            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
                        });
                        return;
                    }
                    const slideIndexLastInView = activeIndex + slidesPerView - 1;
                    if (swiper.params.rewind || swiper.params.loop) {
                        for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                            const realIndex = (i % len + len) % len;
                            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
                        }
                    } else {
                        for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
                            if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
                                unlazy(swiper, i);
                            }
                        }
                    }
                };

                function getActiveIndexByTranslate(swiper) {
                    const {
                        slidesGrid,
                        params
                    } = swiper;
                    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
                    let activeIndex;
                    for (let i = 0; i < slidesGrid.length; i += 1) {
                        if (typeof slidesGrid[i + 1] !== 'undefined') {
                            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                                activeIndex = i;
                            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                                activeIndex = i + 1;
                            }
                        } else if (translate >= slidesGrid[i]) {
                            activeIndex = i;
                        }
                    }
                    // Normalize slideIndex
                    if (params.normalizeSlideIndex) {
                        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
                    }
                    return activeIndex;
                }

                function updateActiveIndex(newActiveIndex) {
                    const swiper = this;
                    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
                    const {
                        snapGrid,
                        params,
                        activeIndex: previousIndex,
                        realIndex: previousRealIndex,
                        snapIndex: previousSnapIndex
                    } = swiper;
                    let activeIndex = newActiveIndex;
                    let snapIndex;
                    const getVirtualRealIndex = aIndex => {
                        let realIndex = aIndex - swiper.virtual.slidesBefore;
                        if (realIndex < 0) {
                            realIndex = swiper.virtual.slides.length + realIndex;
                        }
                        if (realIndex >= swiper.virtual.slides.length) {
                            realIndex -= swiper.virtual.slides.length;
                        }
                        return realIndex;
                    };
                    if (typeof activeIndex === 'undefined') {
                        activeIndex = getActiveIndexByTranslate(swiper);
                    }
                    if (snapGrid.indexOf(translate) >= 0) {
                        snapIndex = snapGrid.indexOf(translate);
                    } else {
                        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
                    }
                    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
                    if (activeIndex === previousIndex) {
                        if (snapIndex !== previousSnapIndex) {
                            swiper.snapIndex = snapIndex;
                            swiper.emit('snapIndexChange');
                        }
                        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
                            swiper.realIndex = getVirtualRealIndex(activeIndex);
                        }
                        return;
                    }
                    // Get real index
                    let realIndex;
                    if (swiper.virtual && params.virtual.enabled && params.loop) {
                        realIndex = getVirtualRealIndex(activeIndex);
                    } else if (swiper.slides[activeIndex]) {
                        realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);
                    } else {
                        realIndex = activeIndex;
                    }
                    Object.assign(swiper, {
                        previousSnapIndex,
                        snapIndex,
                        previousRealIndex,
                        realIndex,
                        previousIndex,
                        activeIndex
                    });
                    if (swiper.initialized) {
                        preload(swiper);
                    }
                    swiper.emit('activeIndexChange');
                    swiper.emit('snapIndexChange');
                    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
                        if (previousRealIndex !== realIndex) {
                            swiper.emit('realIndexChange');
                        }
                        swiper.emit('slideChange');
                    }
                }

                function updateClickedSlide(el, path) {
                    const swiper = this;
                    const params = swiper.params;
                    let slide = el.closest(`.${params.slideClass}, swiper-slide`);
                    if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
                        [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
                            if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
                                slide = pathEl;
                            }
                        });
                    }
                    let slideFound = false;
                    let slideIndex;
                    if (slide) {
                        for (let i = 0; i < swiper.slides.length; i += 1) {
                            if (swiper.slides[i] === slide) {
                                slideFound = true;
                                slideIndex = i;
                                break;
                            }
                        }
                    }
                    if (slide && slideFound) {
                        swiper.clickedSlide = slide;
                        if (swiper.virtual && swiper.params.virtual.enabled) {
                            swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
                        } else {
                            swiper.clickedIndex = slideIndex;
                        }
                    } else {
                        swiper.clickedSlide = undefined;
                        swiper.clickedIndex = undefined;
                        return;
                    }
                    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
                        swiper.slideToClickedSlide();
                    }
                }

                var update = {
                    updateSize,
                    updateSlides,
                    updateAutoHeight,
                    updateSlidesOffset,
                    updateSlidesProgress,
                    updateProgress,
                    updateSlidesClasses,
                    updateActiveIndex,
                    updateClickedSlide
                };

                function getSwiperTranslate(axis) {
                    if (axis === void 0) {
                        axis = this.isHorizontal() ? 'x' : 'y';
                    }
                    const swiper = this;
                    const {
                        params,
                        rtlTranslate: rtl,
                        translate,
                        wrapperEl
                    } = swiper;
                    if (params.virtualTranslate) {
                        return rtl ? -translate : translate;
                    }
                    if (params.cssMode) {
                        return translate;
                    }
                    let currentTranslate = utils_getTranslate(wrapperEl, axis);
                    currentTranslate += swiper.cssOverflowAdjustment();
                    if (rtl) currentTranslate = -currentTranslate;
                    return currentTranslate || 0;
                }

                function setTranslate(translate, byController) {
                    const swiper = this;
                    const {
                        rtlTranslate: rtl,
                        params,
                        wrapperEl,
                        progress
                    } = swiper;
                    let x = 0;
                    let y = 0;
                    const z = 0;
                    if (swiper.isHorizontal()) {
                        x = rtl ? -translate : translate;
                    } else {
                        y = translate;
                    }
                    if (params.roundLengths) {
                        x = Math.floor(x);
                        y = Math.floor(y);
                    }
                    swiper.previousTranslate = swiper.translate;
                    swiper.translate = swiper.isHorizontal() ? x : y;
                    if (params.cssMode) {
                        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
                    } else if (!params.virtualTranslate) {
                        if (swiper.isHorizontal()) {
                            x -= swiper.cssOverflowAdjustment();
                        } else {
                            y -= swiper.cssOverflowAdjustment();
                        }
                        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
                    }

                    // Check if we need to update progress
                    let newProgress;
                    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                    if (translatesDiff === 0) {
                        newProgress = 0;
                    } else {
                        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
                    }
                    if (newProgress !== progress) {
                        swiper.updateProgress(translate);
                    }
                    swiper.emit('setTranslate', swiper.translate, byController);
                }

                function minTranslate() {
                    return -this.snapGrid[0];
                }

                function maxTranslate() {
                    return -this.snapGrid[this.snapGrid.length - 1];
                }

                function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
                    if (translate === void 0) {
                        translate = 0;
                    }
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    if (translateBounds === void 0) {
                        translateBounds = true;
                    }
                    const swiper = this;
                    const {
                        params,
                        wrapperEl
                    } = swiper;
                    if (swiper.animating && params.preventInteractionOnTransition) {
                        return false;
                    }
                    const minTranslate = swiper.minTranslate();
                    const maxTranslate = swiper.maxTranslate();
                    let newTranslate;
                    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
                    else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
                    else newTranslate = translate;

                    // Update progress
                    swiper.updateProgress(newTranslate);
                    if (params.cssMode) {
                        const isH = swiper.isHorizontal();
                        if (speed === 0) {
                            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
                        } else {
                            if (!swiper.support.smoothScroll) {
                                animateCSSModeScroll({
                                    swiper,
                                    targetPosition: -newTranslate,
                                    side: isH ? 'left' : 'top'
                                });
                                return true;
                            }
                            wrapperEl.scrollTo({
                                [isH ? 'left' : 'top']: -newTranslate,
                                behavior: 'smooth'
                            });
                        }
                        return true;
                    }
                    if (speed === 0) {
                        swiper.setTransition(0);
                        swiper.setTranslate(newTranslate);
                        if (runCallbacks) {
                            swiper.emit('beforeTransitionStart', speed, internal);
                            swiper.emit('transitionEnd');
                        }
                    } else {
                        swiper.setTransition(speed);
                        swiper.setTranslate(newTranslate);
                        if (runCallbacks) {
                            swiper.emit('beforeTransitionStart', speed, internal);
                            swiper.emit('transitionStart');
                        }
                        if (!swiper.animating) {
                            swiper.animating = true;
                            if (!swiper.onTranslateToWrapperTransitionEnd) {
                                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                                    if (!swiper || swiper.destroyed) return;
                                    if (e.target !== this) return;
                                    swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                                    swiper.onTranslateToWrapperTransitionEnd = null;
                                    delete swiper.onTranslateToWrapperTransitionEnd;
                                    if (runCallbacks) {
                                        swiper.emit('transitionEnd');
                                    }
                                };
                            }
                            swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                        }
                    }
                    return true;
                }

                var translate = {
                    getTranslate: getSwiperTranslate,
                    setTranslate,
                    minTranslate,
                    maxTranslate,
                    translateTo
                };

                function setTransition(duration, byController) {
                    const swiper = this;
                    if (!swiper.params.cssMode) {
                        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
                        swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
                    }
                    swiper.emit('setTransition', duration, byController);
                }

                function transitionEmit(_ref) {
                    let {
                        swiper,
                        runCallbacks,
                        direction,
                        step
                    } = _ref;
                    const {
                        activeIndex,
                        previousIndex
                    } = swiper;
                    let dir = direction;
                    if (!dir) {
                        if (activeIndex > previousIndex) dir = 'next';
                        else if (activeIndex < previousIndex) dir = 'prev';
                        else dir = 'reset';
                    }
                    swiper.emit(`transition${step}`);
                    if (runCallbacks && activeIndex !== previousIndex) {
                        if (dir === 'reset') {
                            swiper.emit(`slideResetTransition${step}`);
                            return;
                        }
                        swiper.emit(`slideChangeTransition${step}`);
                        if (dir === 'next') {
                            swiper.emit(`slideNextTransition${step}`);
                        } else {
                            swiper.emit(`slidePrevTransition${step}`);
                        }
                    }
                }

                function transitionStart(runCallbacks, direction) {
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    const swiper = this;
                    const {
                        params
                    } = swiper;
                    if (params.cssMode) return;
                    if (params.autoHeight) {
                        swiper.updateAutoHeight();
                    }
                    transitionEmit({
                        swiper,
                        runCallbacks,
                        direction,
                        step: 'Start'
                    });
                }

                function transitionEnd(runCallbacks, direction) {
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    const swiper = this;
                    const {
                        params
                    } = swiper;
                    swiper.animating = false;
                    if (params.cssMode) return;
                    swiper.setTransition(0);
                    transitionEmit({
                        swiper,
                        runCallbacks,
                        direction,
                        step: 'End'
                    });
                }

                var transition = {
                    setTransition,
                    transitionStart,
                    transitionEnd
                };

                function slideTo(index, speed, runCallbacks, internal, initial) {
                    if (index === void 0) {
                        index = 0;
                    }
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    if (typeof index === 'string') {
                        index = parseInt(index, 10);
                    }
                    const swiper = this;
                    let slideIndex = index;
                    if (slideIndex < 0) slideIndex = 0;
                    const {
                        params,
                        snapGrid,
                        slidesGrid,
                        previousIndex,
                        activeIndex,
                        rtlTranslate: rtl,
                        wrapperEl,
                        enabled
                    } = swiper;
                    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
                        return false;
                    }
                    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
                    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
                    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
                    const translate = -snapGrid[snapIndex];
                    // Normalize slideIndex
                    if (params.normalizeSlideIndex) {
                        for (let i = 0; i < slidesGrid.length; i += 1) {
                            const normalizedTranslate = -Math.floor(translate * 100);
                            const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                            if (typeof slidesGrid[i + 1] !== 'undefined') {
                                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                                    slideIndex = i;
                                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                                    slideIndex = i + 1;
                                }
                            } else if (normalizedTranslate >= normalizedGrid) {
                                slideIndex = i;
                            }
                        }
                    }
                    // Directions locks
                    if (swiper.initialized && slideIndex !== activeIndex) {
                        if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
                            return false;
                        }
                        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                            if ((activeIndex || 0) !== slideIndex) {
                                return false;
                            }
                        }
                    }
                    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
                        swiper.emit('beforeSlideChangeStart');
                    }

                    // Update progress
                    swiper.updateProgress(translate);
                    let direction;
                    if (slideIndex > activeIndex) direction = 'next';
                    else if (slideIndex < activeIndex) direction = 'prev';
                    else direction = 'reset';

                    // Update Index
                    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                        swiper.updateActiveIndex(slideIndex);
                        // Update Height
                        if (params.autoHeight) {
                            swiper.updateAutoHeight();
                        }
                        swiper.updateSlidesClasses();
                        if (params.effect !== 'slide') {
                            swiper.setTranslate(translate);
                        }
                        if (direction !== 'reset') {
                            swiper.transitionStart(runCallbacks, direction);
                            swiper.transitionEnd(runCallbacks, direction);
                        }
                        return false;
                    }
                    if (params.cssMode) {
                        const isH = swiper.isHorizontal();
                        const t = rtl ? translate : -translate;
                        if (speed === 0) {
                            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                            if (isVirtual) {
                                swiper.wrapperEl.style.scrollSnapType = 'none';
                                swiper._immediateVirtual = true;
                            }
                            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                                swiper._cssModeVirtualInitialSet = true;
                                requestAnimationFrame(() => {
                                    wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                                });
                            } else {
                                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                            }
                            if (isVirtual) {
                                requestAnimationFrame(() => {
                                    swiper.wrapperEl.style.scrollSnapType = '';
                                    swiper._immediateVirtual = false;
                                });
                            }
                        } else {
                            if (!swiper.support.smoothScroll) {
                                animateCSSModeScroll({
                                    swiper,
                                    targetPosition: t,
                                    side: isH ? 'left' : 'top'
                                });
                                return true;
                            }
                            wrapperEl.scrollTo({
                                [isH ? 'left' : 'top']: t,
                                behavior: 'smooth'
                            });
                        }
                        return true;
                    }
                    swiper.setTransition(speed);
                    swiper.setTranslate(translate);
                    swiper.updateActiveIndex(slideIndex);
                    swiper.updateSlidesClasses();
                    swiper.emit('beforeTransitionStart', speed, internal);
                    swiper.transitionStart(runCallbacks, direction);
                    if (speed === 0) {
                        swiper.transitionEnd(runCallbacks, direction);
                    } else if (!swiper.animating) {
                        swiper.animating = true;
                        if (!swiper.onSlideToWrapperTransitionEnd) {
                            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                                if (!swiper || swiper.destroyed) return;
                                if (e.target !== this) return;
                                swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                                swiper.onSlideToWrapperTransitionEnd = null;
                                delete swiper.onSlideToWrapperTransitionEnd;
                                swiper.transitionEnd(runCallbacks, direction);
                            };
                        }
                        swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                    }
                    return true;
                }

                function slideToLoop(index, speed, runCallbacks, internal) {
                    if (index === void 0) {
                        index = 0;
                    }
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    if (typeof index === 'string') {
                        const indexAsNumber = parseInt(index, 10);
                        index = indexAsNumber;
                    }
                    const swiper = this;
                    let newIndex = index;
                    if (swiper.params.loop) {
                        if (swiper.virtual && swiper.params.virtual.enabled) {
                            // eslint-disable-next-line
                            newIndex = newIndex + swiper.virtual.slidesBefore;
                        } else {
                            newIndex = swiper.getSlideIndexByData(newIndex);
                        }
                    }
                    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
                }

                /* eslint no-unused-vars: "off" */
                function slideNext(speed, runCallbacks, internal) {
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    const swiper = this;
                    const {
                        enabled,
                        params,
                        animating
                    } = swiper;
                    if (!enabled) return swiper;
                    let perGroup = params.slidesPerGroup;
                    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
                    }
                    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
                    const isVirtual = swiper.virtual && params.virtual.enabled;
                    if (params.loop) {
                        if (animating && !isVirtual && params.loopPreventsSliding) return false;
                        swiper.loopFix({
                            direction: 'next'
                        });
                        // eslint-disable-next-line
                        swiper._clientLeft = swiper.wrapperEl.clientLeft;
                        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
                            requestAnimationFrame(() => {
                                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
                            });
                            return true;
                        }
                    }
                    if (params.rewind && swiper.isEnd) {
                        return swiper.slideTo(0, speed, runCallbacks, internal);
                    }
                    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
                }

                /* eslint no-unused-vars: "off" */
                function slidePrev(speed, runCallbacks, internal) {
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    const swiper = this;
                    const {
                        params,
                        snapGrid,
                        slidesGrid,
                        rtlTranslate,
                        enabled,
                        animating
                    } = swiper;
                    if (!enabled) return swiper;
                    const isVirtual = swiper.virtual && params.virtual.enabled;
                    if (params.loop) {
                        if (animating && !isVirtual && params.loopPreventsSliding) return false;
                        swiper.loopFix({
                            direction: 'prev'
                        });
                        // eslint-disable-next-line
                        swiper._clientLeft = swiper.wrapperEl.clientLeft;
                    }
                    const translate = rtlTranslate ? swiper.translate : -swiper.translate;

                    function normalize(val) {
                        if (val < 0) return -Math.floor(Math.abs(val));
                        return Math.floor(val);
                    }
                    const normalizedTranslate = normalize(translate);
                    const normalizedSnapGrid = snapGrid.map(val => normalize(val));
                    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
                    if (typeof prevSnap === 'undefined' && params.cssMode) {
                        let prevSnapIndex;
                        snapGrid.forEach((snap, snapIndex) => {
                            if (normalizedTranslate >= snap) {
                                // prevSnap = snap;
                                prevSnapIndex = snapIndex;
                            }
                        });
                        if (typeof prevSnapIndex !== 'undefined') {
                            prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
                        }
                    }
                    let prevIndex = 0;
                    if (typeof prevSnap !== 'undefined') {
                        prevIndex = slidesGrid.indexOf(prevSnap);
                        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                            prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
                            prevIndex = Math.max(prevIndex, 0);
                        }
                    }
                    if (params.rewind && swiper.isBeginning) {
                        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
                    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
                        requestAnimationFrame(() => {
                            swiper.slideTo(prevIndex, speed, runCallbacks, internal);
                        });
                        return true;
                    }
                    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
                }

                /* eslint no-unused-vars: "off" */
                function slideReset(speed, runCallbacks, internal) {
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    const swiper = this;
                    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
                }

                /* eslint no-unused-vars: "off" */
                function slideToClosest(speed, runCallbacks, internal, threshold) {
                    if (speed === void 0) {
                        speed = this.params.speed;
                    }
                    if (runCallbacks === void 0) {
                        runCallbacks = true;
                    }
                    if (threshold === void 0) {
                        threshold = 0.5;
                    }
                    const swiper = this;
                    let index = swiper.activeIndex;
                    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
                    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
                    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
                    if (translate >= swiper.snapGrid[snapIndex]) {
                        // The current translate is on or after the current snap index, so the choice
                        // is between the current index and the one after it.
                        const currentSnap = swiper.snapGrid[snapIndex];
                        const nextSnap = swiper.snapGrid[snapIndex + 1];
                        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
                            index += swiper.params.slidesPerGroup;
                        }
                    } else {
                        // The current translate is before the current snap index, so the choice
                        // is between the current index and the one before it.
                        const prevSnap = swiper.snapGrid[snapIndex - 1];
                        const currentSnap = swiper.snapGrid[snapIndex];
                        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
                            index -= swiper.params.slidesPerGroup;
                        }
                    }
                    index = Math.max(index, 0);
                    index = Math.min(index, swiper.slidesGrid.length - 1);
                    return swiper.slideTo(index, speed, runCallbacks, internal);
                }

                function slideToClickedSlide() {
                    const swiper = this;
                    const {
                        params,
                        slidesEl
                    } = swiper;
                    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
                    let slideToIndex = swiper.clickedIndex;
                    let realIndex;
                    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
                    if (params.loop) {
                        if (swiper.animating) return;
                        realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
                        if (params.centeredSlides) {
                            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                                swiper.loopFix();
                                slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                                utils_nextTick(() => {
                                    swiper.slideTo(slideToIndex);
                                });
                            } else {
                                swiper.slideTo(slideToIndex);
                            }
                        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                            swiper.loopFix();
                            slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                            utils_nextTick(() => {
                                swiper.slideTo(slideToIndex);
                            });
                        } else {
                            swiper.slideTo(slideToIndex);
                        }
                    } else {
                        swiper.slideTo(slideToIndex);
                    }
                }

                var slide = {
                    slideTo,
                    slideToLoop,
                    slideNext,
                    slidePrev,
                    slideReset,
                    slideToClosest,
                    slideToClickedSlide
                };

                function loopCreate(slideRealIndex) {
                    const swiper = this;
                    const {
                        params,
                        slidesEl
                    } = swiper;
                    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
                    const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                    slides.forEach((el, index) => {
                        el.setAttribute('data-swiper-slide-index', index);
                    });
                    swiper.loopFix({
                        slideRealIndex,
                        direction: params.centeredSlides ? undefined : 'next'
                    });
                }

                function loopFix(_temp) {
                    let {
                        slideRealIndex,
                        slideTo = true,
                        direction,
                        setTranslate,
                        activeSlideIndex,
                        byController,
                        byMousewheel
                    } = _temp === void 0 ? {} : _temp;
                    const swiper = this;
                    if (!swiper.params.loop) return;
                    swiper.emit('beforeLoopFix');
                    const {
                        slides,
                        allowSlidePrev,
                        allowSlideNext,
                        slidesEl,
                        params
                    } = swiper;
                    swiper.allowSlidePrev = true;
                    swiper.allowSlideNext = true;
                    if (swiper.virtual && params.virtual.enabled) {
                        if (slideTo) {
                            if (!params.centeredSlides && swiper.snapIndex === 0) {
                                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
                            } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
                                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
                            } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
                                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                            }
                        }
                        swiper.allowSlidePrev = allowSlidePrev;
                        swiper.allowSlideNext = allowSlideNext;
                        swiper.emit('loopFix');
                        return;
                    }
                    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
                    let loopedSlides = params.loopedSlides || slidesPerView;
                    if (loopedSlides % params.slidesPerGroup !== 0) {
                        loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
                    }
                    swiper.loopedSlides = loopedSlides;
                    const prependSlidesIndexes = [];
                    const appendSlidesIndexes = [];
                    let activeIndex = swiper.activeIndex;
                    if (typeof activeSlideIndex === 'undefined') {
                        activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
                    } else {
                        activeIndex = activeSlideIndex;
                    }
                    const isNext = direction === 'next' || !direction;
                    const isPrev = direction === 'prev' || !direction;
                    let slidesPrepended = 0;
                    let slidesAppended = 0;
                    // prepend last slides before start
                    if (activeSlideIndex < loopedSlides) {
                        slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
                        for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
                            const index = i - Math.floor(i / slides.length) * slides.length;
                            prependSlidesIndexes.push(slides.length - index - 1);
                        }
                    } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {
                        slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
                        for (let i = 0; i < slidesAppended; i += 1) {
                            const index = i - Math.floor(i / slides.length) * slides.length;
                            appendSlidesIndexes.push(index);
                        }
                    }
                    if (isPrev) {
                        prependSlidesIndexes.forEach(index => {
                            swiper.slides[index].swiperLoopMoveDOM = true;
                            slidesEl.prepend(swiper.slides[index]);
                            swiper.slides[index].swiperLoopMoveDOM = false;
                        });
                    }
                    if (isNext) {
                        appendSlidesIndexes.forEach(index => {
                            swiper.slides[index].swiperLoopMoveDOM = true;
                            slidesEl.append(swiper.slides[index]);
                            swiper.slides[index].swiperLoopMoveDOM = false;
                        });
                    }
                    swiper.recalcSlides();
                    if (params.slidesPerView === 'auto') {
                        swiper.updateSlides();
                    }
                    if (params.watchSlidesProgress) {
                        swiper.updateSlidesOffset();
                    }
                    if (slideTo) {
                        if (prependSlidesIndexes.length > 0 && isPrev) {
                            if (typeof slideRealIndex === 'undefined') {
                                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                                const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                                const diff = newSlideTranslate - currentSlideTranslate;
                                if (byMousewheel) {
                                    swiper.setTranslate(swiper.translate - diff);
                                } else {
                                    swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                                    if (setTranslate) {
                                        swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
                                        swiper.touchEventsData.currentTranslate = swiper.translate;
                                    }
                                }
                            } else {
                                if (setTranslate) {
                                    swiper.slideToLoop(slideRealIndex, 0, false, true);
                                    swiper.touchEventsData.currentTranslate = swiper.translate;
                                }
                            }
                        } else if (appendSlidesIndexes.length > 0 && isNext) {
                            if (typeof slideRealIndex === 'undefined') {
                                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                                const diff = newSlideTranslate - currentSlideTranslate;
                                if (byMousewheel) {
                                    swiper.setTranslate(swiper.translate - diff);
                                } else {
                                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                                    if (setTranslate) {
                                        swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
                                        swiper.touchEventsData.currentTranslate = swiper.translate;
                                    }
                                }
                            } else {
                                swiper.slideToLoop(slideRealIndex, 0, false, true);
                            }
                        }
                    }
                    swiper.allowSlidePrev = allowSlidePrev;
                    swiper.allowSlideNext = allowSlideNext;
                    if (swiper.controller && swiper.controller.control && !byController) {
                        const loopParams = {
                            slideRealIndex,
                            direction,
                            setTranslate,
                            activeSlideIndex,
                            byController: true
                        };
                        if (Array.isArray(swiper.controller.control)) {
                            swiper.controller.control.forEach(c => {
                                if (!c.destroyed && c.params.loop) c.loopFix({
                                    ...loopParams,
                                    slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                                });
                            });
                        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
                            swiper.controller.control.loopFix({
                                ...loopParams,
                                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
                            });
                        }
                    }
                    swiper.emit('loopFix');
                }

                function loopDestroy() {
                    const swiper = this;
                    const {
                        params,
                        slidesEl
                    } = swiper;
                    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
                    swiper.recalcSlides();
                    const newSlidesOrder = [];
                    swiper.slides.forEach(slideEl => {
                        const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
                        newSlidesOrder[index] = slideEl;
                    });
                    swiper.slides.forEach(slideEl => {
                        slideEl.removeAttribute('data-swiper-slide-index');
                    });
                    newSlidesOrder.forEach(slideEl => {
                        slidesEl.append(slideEl);
                    });
                    swiper.recalcSlides();
                    swiper.slideTo(swiper.realIndex, 0);
                }

                var loop = {
                    loopCreate,
                    loopFix,
                    loopDestroy
                };

                function setGrabCursor(moving) {
                    const swiper = this;
                    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
                    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
                    if (swiper.isElement) {
                        swiper.__preventObserver__ = true;
                    }
                    el.style.cursor = 'move';
                    el.style.cursor = moving ? 'grabbing' : 'grab';
                    if (swiper.isElement) {
                        requestAnimationFrame(() => {
                            swiper.__preventObserver__ = false;
                        });
                    }
                }

                function unsetGrabCursor() {
                    const swiper = this;
                    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
                        return;
                    }
                    if (swiper.isElement) {
                        swiper.__preventObserver__ = true;
                    }
                    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
                    if (swiper.isElement) {
                        requestAnimationFrame(() => {
                            swiper.__preventObserver__ = false;
                        });
                    }
                }

                var grabCursor = {
                    setGrabCursor,
                    unsetGrabCursor
                };

                // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
                function closestElement(selector, base) {
                    if (base === void 0) {
                        base = this;
                    }

                    function __closestFrom(el) {
                        if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                        if (el.assignedSlot) el = el.assignedSlot;
                        const found = el.closest(selector);
                        if (!found && !el.getRootNode) {
                            return null;
                        }
                        return found || __closestFrom(el.getRootNode().host);
                    }
                    return __closestFrom(base);
                }

                function onTouchStart(event) {
                    const swiper = this;
                    const document = ssr_window_esm_getDocument();
                    const window = ssr_window_esm_getWindow();
                    const data = swiper.touchEventsData;
                    data.evCache.push(event);
                    const {
                        params,
                        touches,
                        enabled
                    } = swiper;
                    if (!enabled) return;
                    if (!params.simulateTouch && event.pointerType === 'mouse') return;
                    if (swiper.animating && params.preventInteractionOnTransition) {
                        return;
                    }
                    if (!swiper.animating && params.cssMode && params.loop) {
                        swiper.loopFix();
                    }
                    let e = event;
                    if (e.originalEvent) e = e.originalEvent;
                    let targetEl = e.target;
                    if (params.touchEventsTarget === 'wrapper') {
                        if (!swiper.wrapperEl.contains(targetEl)) return;
                    }
                    if ('which' in e && e.which === 3) return;
                    if ('button' in e && e.button > 0) return;
                    if (data.isTouched && data.isMoved) return;

                    // change target el for shadow root component
                    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
                    // eslint-disable-next-line
                    const eventPath = event.composedPath ? event.composedPath() : event.path;
                    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
                        targetEl = eventPath[0];
                    }
                    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
                    const isTargetShadow = !!(e.target && e.target.shadowRoot);

                    // use closestElement for shadow root element to get the actual closest for nested shadow root element
                    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                        swiper.allowClick = true;
                        return;
                    }
                    if (params.swipeHandler) {
                        if (!targetEl.closest(params.swipeHandler)) return;
                    }
                    touches.currentX = e.pageX;
                    touches.currentY = e.pageY;
                    const startX = touches.currentX;
                    const startY = touches.currentY;

                    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

                    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
                    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
                    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
                        if (edgeSwipeDetection === 'prevent') {
                            event.preventDefault();
                        } else {
                            return;
                        }
                    }
                    Object.assign(data, {
                        isTouched: true,
                        isMoved: false,
                        allowTouchCallbacks: true,
                        isScrolling: undefined,
                        startMoving: undefined
                    });
                    touches.startX = startX;
                    touches.startY = startY;
                    data.touchStartTime = utils_now();
                    swiper.allowClick = true;
                    swiper.updateSize();
                    swiper.swipeDirection = undefined;
                    if (params.threshold > 0) data.allowThresholdMove = false;
                    let preventDefault = true;
                    if (targetEl.matches(data.focusableElements)) {
                        preventDefault = false;
                        if (targetEl.nodeName === 'SELECT') {
                            data.isTouched = false;
                        }
                    }
                    if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
                        document.activeElement.blur();
                    }
                    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
                    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
                        e.preventDefault();
                    }
                    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
                        swiper.freeMode.onTouchStart();
                    }
                    swiper.emit('touchStart', e);
                }

                function onTouchMove(event) {
                    const document = ssr_window_esm_getDocument();
                    const swiper = this;
                    const data = swiper.touchEventsData;
                    const {
                        params,
                        touches,
                        rtlTranslate: rtl,
                        enabled
                    } = swiper;
                    if (!enabled) return;
                    if (!params.simulateTouch && event.pointerType === 'mouse') return;
                    let e = event;
                    if (e.originalEvent) e = e.originalEvent;
                    if (!data.isTouched) {
                        if (data.startMoving && data.isScrolling) {
                            swiper.emit('touchMoveOpposite', e);
                        }
                        return;
                    }
                    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
                    if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
                    const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
                    const pageX = targetTouch.pageX;
                    const pageY = targetTouch.pageY;
                    if (e.preventedByNestedSwiper) {
                        touches.startX = pageX;
                        touches.startY = pageY;
                        return;
                    }
                    if (!swiper.allowTouchMove) {
                        if (!e.target.matches(data.focusableElements)) {
                            swiper.allowClick = false;
                        }
                        if (data.isTouched) {
                            Object.assign(touches, {
                                startX: pageX,
                                startY: pageY,
                                prevX: swiper.touches.currentX,
                                prevY: swiper.touches.currentY,
                                currentX: pageX,
                                currentY: pageY
                            });
                            data.touchStartTime = utils_now();
                        }
                        return;
                    }
                    if (params.touchReleaseOnEdges && !params.loop) {
                        if (swiper.isVertical()) {
                            // Vertical
                            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                                data.isTouched = false;
                                data.isMoved = false;
                                return;
                            }
                        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
                            return;
                        }
                    }
                    if (document.activeElement) {
                        if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                            data.isMoved = true;
                            swiper.allowClick = false;
                            return;
                        }
                    }
                    if (data.allowTouchCallbacks) {
                        swiper.emit('touchMove', e);
                    }
                    if (e.targetTouches && e.targetTouches.length > 1) return;
                    touches.currentX = pageX;
                    touches.currentY = pageY;
                    const diffX = touches.currentX - touches.startX;
                    const diffY = touches.currentY - touches.startY;
                    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
                    if (typeof data.isScrolling === 'undefined') {
                        let touchAngle;
                        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
                            data.isScrolling = false;
                        } else {
                            // eslint-disable-next-line
                            if (diffX * diffX + diffY * diffY >= 25) {
                                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                            }
                        }
                    }
                    if (data.isScrolling) {
                        swiper.emit('touchMoveOpposite', e);
                    }
                    if (typeof data.startMoving === 'undefined') {
                        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                            data.startMoving = true;
                        }
                    }
                    if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
                        data.isTouched = false;
                        return;
                    }
                    if (!data.startMoving) {
                        return;
                    }
                    swiper.allowClick = false;
                    if (!params.cssMode && e.cancelable) {
                        e.preventDefault();
                    }
                    if (params.touchMoveStopPropagation && !params.nested) {
                        e.stopPropagation();
                    }
                    let diff = swiper.isHorizontal() ? diffX : diffY;
                    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
                    if (params.oneWayMovement) {
                        diff = Math.abs(diff) * (rtl ? 1 : -1);
                        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
                    }
                    touches.diff = diff;
                    diff *= params.touchRatio;
                    if (rtl) {
                        diff = -diff;
                        touchesDiff = -touchesDiff;
                    }
                    const prevTouchesDirection = swiper.touchesDirection;
                    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
                    swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
                    const isLoop = swiper.params.loop && !params.cssMode;
                    const allowLoopFix = swiper.swipeDirection === 'next' && swiper.allowSlideNext || swiper.swipeDirection === 'prev' && swiper.allowSlidePrev;
                    if (!data.isMoved) {
                        if (isLoop && allowLoopFix) {
                            swiper.loopFix({
                                direction: swiper.swipeDirection
                            });
                        }
                        data.startTranslate = swiper.getTranslate();
                        swiper.setTransition(0);
                        if (swiper.animating) {
                            const evt = new window.CustomEvent('transitionend', {
                                bubbles: true,
                                cancelable: true
                            });
                            swiper.wrapperEl.dispatchEvent(evt);
                        }
                        data.allowMomentumBounce = false;
                        // Grab Cursor
                        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                            swiper.setGrabCursor(true);
                        }
                        swiper.emit('sliderFirstMove', e);
                    }
                    let loopFixed;
                    if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
                        // need another loop fix
                        swiper.loopFix({
                            direction: swiper.swipeDirection,
                            setTranslate: true
                        });
                        loopFixed = true;
                    }
                    swiper.emit('sliderMove', e);
                    data.isMoved = true;
                    data.currentTranslate = diff + data.startTranslate;
                    let disableParentSwiper = true;
                    let resistanceRatio = params.resistanceRatio;
                    if (params.touchReleaseOnEdges) {
                        resistanceRatio = 0;
                    }
                    if (diff > 0) {
                        if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {
                            swiper.loopFix({
                                direction: 'prev',
                                setTranslate: true,
                                activeSlideIndex: 0
                            });
                        }
                        if (data.currentTranslate > swiper.minTranslate()) {
                            disableParentSwiper = false;
                            if (params.resistance) {
                                data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                            }
                        }
                    } else if (diff < 0) {
                        if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {
                            swiper.loopFix({
                                direction: 'next',
                                setTranslate: true,
                                activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                            });
                        }
                        if (data.currentTranslate < swiper.maxTranslate()) {
                            disableParentSwiper = false;
                            if (params.resistance) {
                                data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                            }
                        }
                    }
                    if (disableParentSwiper) {
                        e.preventedByNestedSwiper = true;
                    }

                    // Directions locks
                    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
                        data.currentTranslate = data.startTranslate;
                    }
                    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
                        data.currentTranslate = data.startTranslate;
                    }
                    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
                        data.currentTranslate = data.startTranslate;
                    }

                    // Threshold
                    if (params.threshold > 0) {
                        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                            if (!data.allowThresholdMove) {
                                data.allowThresholdMove = true;
                                touches.startX = touches.currentX;
                                touches.startY = touches.currentY;
                                data.currentTranslate = data.startTranslate;
                                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                                return;
                            }
                        } else {
                            data.currentTranslate = data.startTranslate;
                            return;
                        }
                    }
                    if (!params.followFinger || params.cssMode) return;

                    // Update active index in free mode
                    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                    }
                    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
                        swiper.freeMode.onTouchMove();
                    }
                    // Update progress
                    swiper.updateProgress(data.currentTranslate);
                    // Update translate
                    swiper.setTranslate(data.currentTranslate);
                }

                function onTouchEnd(event) {
                    const swiper = this;
                    const data = swiper.touchEventsData;
                    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);
                    if (pointerIndex >= 0) {
                        data.evCache.splice(pointerIndex, 1);
                    }
                    if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(event.type)) {
                        const proceed = ['pointercancel', 'contextmenu'].includes(event.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
                        if (!proceed) {
                            return;
                        }
                    }
                    const {
                        params,
                        touches,
                        rtlTranslate: rtl,
                        slidesGrid,
                        enabled
                    } = swiper;
                    if (!enabled) return;
                    if (!params.simulateTouch && event.pointerType === 'mouse') return;
                    let e = event;
                    if (e.originalEvent) e = e.originalEvent;
                    if (data.allowTouchCallbacks) {
                        swiper.emit('touchEnd', e);
                    }
                    data.allowTouchCallbacks = false;
                    if (!data.isTouched) {
                        if (data.isMoved && params.grabCursor) {
                            swiper.setGrabCursor(false);
                        }
                        data.isMoved = false;
                        data.startMoving = false;
                        return;
                    }
                    // Return Grab Cursor
                    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                        swiper.setGrabCursor(false);
                    }

                    // Time diff
                    const touchEndTime = utils_now();
                    const timeDiff = touchEndTime - data.touchStartTime;

                    // Tap, doubleTap, Click
                    if (swiper.allowClick) {
                        const pathTree = e.path || e.composedPath && e.composedPath();
                        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
                        swiper.emit('tap click', e);
                        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
                            swiper.emit('doubleTap doubleClick', e);
                        }
                    }
                    data.lastClickTime = utils_now();
                    utils_nextTick(() => {
                        if (!swiper.destroyed) swiper.allowClick = true;
                    });
                    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
                        data.isTouched = false;
                        data.isMoved = false;
                        data.startMoving = false;
                        return;
                    }
                    data.isTouched = false;
                    data.isMoved = false;
                    data.startMoving = false;
                    let currentPos;
                    if (params.followFinger) {
                        currentPos = rtl ? swiper.translate : -swiper.translate;
                    } else {
                        currentPos = -data.currentTranslate;
                    }
                    if (params.cssMode) {
                        return;
                    }
                    if (params.freeMode && params.freeMode.enabled) {
                        swiper.freeMode.onTouchEnd({
                            currentPos
                        });
                        return;
                    }

                    // Find current slide
                    let stopIndex = 0;
                    let groupSize = swiper.slidesSizesGrid[0];
                    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                        if (typeof slidesGrid[i + increment] !== 'undefined') {
                            if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                                stopIndex = i;
                                groupSize = slidesGrid[i + increment] - slidesGrid[i];
                            }
                        } else if (currentPos >= slidesGrid[i]) {
                            stopIndex = i;
                            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                        }
                    }
                    let rewindFirstIndex = null;
                    let rewindLastIndex = null;
                    if (params.rewind) {
                        if (swiper.isBeginning) {
                            rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                        } else if (swiper.isEnd) {
                            rewindFirstIndex = 0;
                        }
                    }
                    // Find current slide size
                    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
                    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                    if (timeDiff > params.longSwipesMs) {
                        // Long touches
                        if (!params.longSwipes) {
                            swiper.slideTo(swiper.activeIndex);
                            return;
                        }
                        if (swiper.swipeDirection === 'next') {
                            if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
                            else swiper.slideTo(stopIndex);
                        }
                        if (swiper.swipeDirection === 'prev') {
                            if (ratio > 1 - params.longSwipesRatio) {
                                swiper.slideTo(stopIndex + increment);
                            } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                                swiper.slideTo(rewindLastIndex);
                            } else {
                                swiper.slideTo(stopIndex);
                            }
                        }
                    } else {
                        // Short swipes
                        if (!params.shortSwipes) {
                            swiper.slideTo(swiper.activeIndex);
                            return;
                        }
                        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                        if (!isNavButtonTarget) {
                            if (swiper.swipeDirection === 'next') {
                                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                            }
                            if (swiper.swipeDirection === 'prev') {
                                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                            }
                        } else if (e.target === swiper.navigation.nextEl) {
                            swiper.slideTo(stopIndex + increment);
                        } else {
                            swiper.slideTo(stopIndex);
                        }
                    }
                }

                function onResize() {
                    const swiper = this;
                    const {
                        params,
                        el
                    } = swiper;
                    if (el && el.offsetWidth === 0) return;

                    // Breakpoints
                    if (params.breakpoints) {
                        swiper.setBreakpoint();
                    }

                    // Save locks
                    const {
                        allowSlideNext,
                        allowSlidePrev,
                        snapGrid
                    } = swiper;
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

                    // Disable locks on resize
                    swiper.allowSlideNext = true;
                    swiper.allowSlidePrev = true;
                    swiper.updateSize();
                    swiper.updateSlides();
                    swiper.updateSlidesClasses();
                    const isVirtualLoop = isVirtual && params.loop;
                    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
                        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                    } else {
                        if (swiper.params.loop && !isVirtual) {
                            swiper.slideToLoop(swiper.realIndex, 0, false, true);
                        } else {
                            swiper.slideTo(swiper.activeIndex, 0, false, true);
                        }
                    }
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                        clearTimeout(swiper.autoplay.resizeTimeout);
                        swiper.autoplay.resizeTimeout = setTimeout(() => {
                            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                                swiper.autoplay.resume();
                            }
                        }, 500);
                    }
                    // Return locks after resize
                    swiper.allowSlidePrev = allowSlidePrev;
                    swiper.allowSlideNext = allowSlideNext;
                    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
                        swiper.checkOverflow();
                    }
                }

                function onClick(e) {
                    const swiper = this;
                    if (!swiper.enabled) return;
                    if (!swiper.allowClick) {
                        if (swiper.params.preventClicks) e.preventDefault();
                        if (swiper.params.preventClicksPropagation && swiper.animating) {
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                        }
                    }
                }

                function onScroll() {
                    const swiper = this;
                    const {
                        wrapperEl,
                        rtlTranslate,
                        enabled
                    } = swiper;
                    if (!enabled) return;
                    swiper.previousTranslate = swiper.translate;
                    if (swiper.isHorizontal()) {
                        swiper.translate = -wrapperEl.scrollLeft;
                    } else {
                        swiper.translate = -wrapperEl.scrollTop;
                    }
                    // eslint-disable-next-line
                    if (swiper.translate === 0) swiper.translate = 0;
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                    let newProgress;
                    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                    if (translatesDiff === 0) {
                        newProgress = 0;
                    } else {
                        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
                    }
                    if (newProgress !== swiper.progress) {
                        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
                    }
                    swiper.emit('setTranslate', swiper.translate, false);
                }

                function onLoad(e) {
                    const swiper = this;
                    processLazyPreloader(swiper, e.target);
                    if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
                        return;
                    }
                    swiper.update();
                }

                let dummyEventAttached = false;

                function dummyEventListener() {}
                const events = (swiper, method) => {
                    const document = ssr_window_esm_getDocument();
                    const {
                        params,
                        el,
                        wrapperEl,
                        device
                    } = swiper;
                    const capture = !!params.nested;
                    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
                    const swiperMethod = method;

                    // Touch Events
                    el[domMethod]('pointerdown', swiper.onTouchStart, {
                        passive: false
                    });
                    document[domMethod]('pointermove', swiper.onTouchMove, {
                        passive: false,
                        capture
                    });
                    document[domMethod]('pointerup', swiper.onTouchEnd, {
                        passive: true
                    });
                    document[domMethod]('pointercancel', swiper.onTouchEnd, {
                        passive: true
                    });
                    document[domMethod]('pointerout', swiper.onTouchEnd, {
                        passive: true
                    });
                    document[domMethod]('pointerleave', swiper.onTouchEnd, {
                        passive: true
                    });
                    document[domMethod]('contextmenu', swiper.onTouchEnd, {
                        passive: true
                    });

                    // Prevent Links Clicks
                    if (params.preventClicks || params.preventClicksPropagation) {
                        el[domMethod]('click', swiper.onClick, true);
                    }
                    if (params.cssMode) {
                        wrapperEl[domMethod]('scroll', swiper.onScroll);
                    }

                    // Resize handler
                    if (params.updateOnWindowResize) {
                        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
                    } else {
                        swiper[swiperMethod]('observerUpdate', onResize, true);
                    }

                    // Images loader
                    el[domMethod]('load', swiper.onLoad, {
                        capture: true
                    });
                };

                function attachEvents() {
                    const swiper = this;
                    const document = ssr_window_esm_getDocument();
                    const {
                        params
                    } = swiper;
                    swiper.onTouchStart = onTouchStart.bind(swiper);
                    swiper.onTouchMove = onTouchMove.bind(swiper);
                    swiper.onTouchEnd = onTouchEnd.bind(swiper);
                    if (params.cssMode) {
                        swiper.onScroll = onScroll.bind(swiper);
                    }
                    swiper.onClick = onClick.bind(swiper);
                    swiper.onLoad = onLoad.bind(swiper);
                    if (!dummyEventAttached) {
                        document.addEventListener('touchstart', dummyEventListener);
                        dummyEventAttached = true;
                    }
                    events(swiper, 'on');
                }

                function detachEvents() {
                    const swiper = this;
                    events(swiper, 'off');
                }
                var events$1 = {
                    attachEvents,
                    detachEvents
                };

                const isGridEnabled = (swiper, params) => {
                    return swiper.grid && params.grid && params.grid.rows > 1;
                };

                function setBreakpoint() {
                    const swiper = this;
                    const {
                        realIndex,
                        initialized,
                        params,
                        el
                    } = swiper;
                    const breakpoints = params.breakpoints;
                    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

                    // Get breakpoint for window width and update parameters
                    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
                    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
                    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
                    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
                    const wasMultiRow = isGridEnabled(swiper, params);
                    const isMultiRow = isGridEnabled(swiper, breakpointParams);
                    const wasEnabled = params.enabled;
                    if (wasMultiRow && !isMultiRow) {
                        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                        swiper.emitContainerClasses();
                    } else if (!wasMultiRow && isMultiRow) {
                        el.classList.add(`${params.containerModifierClass}grid`);
                        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
                            el.classList.add(`${params.containerModifierClass}grid-column`);
                        }
                        swiper.emitContainerClasses();
                    }

                    // Toggle navigation, pagination, scrollbar
                    ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
                        if (typeof breakpointParams[prop] === 'undefined') return;
                        const wasModuleEnabled = params[prop] && params[prop].enabled;
                        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                        if (wasModuleEnabled && !isModuleEnabled) {
                            swiper[prop].disable();
                        }
                        if (!wasModuleEnabled && isModuleEnabled) {
                            swiper[prop].enable();
                        }
                    });
                    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
                    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
                    const wasLoop = params.loop;
                    if (directionChanged && initialized) {
                        swiper.changeDirection();
                    }
                    utils_extend(swiper.params, breakpointParams);
                    const isEnabled = swiper.params.enabled;
                    const hasLoop = swiper.params.loop;
                    Object.assign(swiper, {
                        allowTouchMove: swiper.params.allowTouchMove,
                        allowSlideNext: swiper.params.allowSlideNext,
                        allowSlidePrev: swiper.params.allowSlidePrev
                    });
                    if (wasEnabled && !isEnabled) {
                        swiper.disable();
                    } else if (!wasEnabled && isEnabled) {
                        swiper.enable();
                    }
                    swiper.currentBreakpoint = breakpoint;
                    swiper.emit('_beforeBreakpoint', breakpointParams);
                    if (initialized) {
                        if (needsReLoop) {
                            swiper.loopDestroy();
                            swiper.loopCreate(realIndex);
                            swiper.updateSlides();
                        } else if (!wasLoop && hasLoop) {
                            swiper.loopCreate(realIndex);
                            swiper.updateSlides();
                        } else if (wasLoop && !hasLoop) {
                            swiper.loopDestroy();
                        }
                    }
                    swiper.emit('breakpoint', breakpointParams);
                }

                function getBreakpoint(breakpoints, base, containerEl) {
                    if (base === void 0) {
                        base = 'window';
                    }
                    if (!breakpoints || base === 'container' && !containerEl) return undefined;
                    let breakpoint = false;
                    const window = ssr_window_esm_getWindow();
                    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
                    const points = Object.keys(breakpoints).map(point => {
                        if (typeof point === 'string' && point.indexOf('@') === 0) {
                            const minRatio = parseFloat(point.substr(1));
                            const value = currentHeight * minRatio;
                            return {
                                value,
                                point
                            };
                        }
                        return {
                            value: point,
                            point
                        };
                    });
                    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
                    for (let i = 0; i < points.length; i += 1) {
                        const {
                            point,
                            value
                        } = points[i];
                        if (base === 'window') {
                            if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                                breakpoint = point;
                            }
                        } else if (value <= containerEl.clientWidth) {
                            breakpoint = point;
                        }
                    }
                    return breakpoint || 'max';
                }

                var breakpoints = {
                    setBreakpoint,
                    getBreakpoint
                };

                function prepareClasses(entries, prefix) {
                    const resultClasses = [];
                    entries.forEach(item => {
                        if (typeof item === 'object') {
                            Object.keys(item).forEach(classNames => {
                                if (item[classNames]) {
                                    resultClasses.push(prefix + classNames);
                                }
                            });
                        } else if (typeof item === 'string') {
                            resultClasses.push(prefix + item);
                        }
                    });
                    return resultClasses;
                }

                function addClasses() {
                    const swiper = this;
                    const {
                        classNames,
                        params,
                        rtl,
                        el,
                        device
                    } = swiper;
                    // prettier-ignore
                    const suffixes = prepareClasses(['initialized', params.direction, {
                        'free-mode': swiper.params.freeMode && params.freeMode.enabled
                    }, {
                        'autoheight': params.autoHeight
                    }, {
                        'rtl': rtl
                    }, {
                        'grid': params.grid && params.grid.rows > 1
                    }, {
                        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
                    }, {
                        'android': device.android
                    }, {
                        'ios': device.ios
                    }, {
                        'css-mode': params.cssMode
                    }, {
                        'centered': params.cssMode && params.centeredSlides
                    }, {
                        'watch-progress': params.watchSlidesProgress
                    }], params.containerModifierClass);
                    classNames.push(...suffixes);
                    el.classList.add(...classNames);
                    swiper.emitContainerClasses();
                }

                function removeClasses() {
                    const swiper = this;
                    const {
                        el,
                        classNames
                    } = swiper;
                    el.classList.remove(...classNames);
                    swiper.emitContainerClasses();
                }

                var classes = {
                    addClasses,
                    removeClasses
                };

                function checkOverflow() {
                    const swiper = this;
                    const {
                        isLocked: wasLocked,
                        params
                    } = swiper;
                    const {
                        slidesOffsetBefore
                    } = params;
                    if (slidesOffsetBefore) {
                        const lastSlideIndex = swiper.slides.length - 1;
                        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                        swiper.isLocked = swiper.size > lastSlideRightEdge;
                    } else {
                        swiper.isLocked = swiper.snapGrid.length === 1;
                    }
                    if (params.allowSlideNext === true) {
                        swiper.allowSlideNext = !swiper.isLocked;
                    }
                    if (params.allowSlidePrev === true) {
                        swiper.allowSlidePrev = !swiper.isLocked;
                    }
                    if (wasLocked && wasLocked !== swiper.isLocked) {
                        swiper.isEnd = false;
                    }
                    if (wasLocked !== swiper.isLocked) {
                        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
                    }
                }
                var checkOverflow$1 = {
                    checkOverflow
                };

                var defaults = {
                    init: true,
                    direction: 'horizontal',
                    oneWayMovement: false,
                    touchEventsTarget: 'wrapper',
                    initialSlide: 0,
                    speed: 300,
                    cssMode: false,
                    updateOnWindowResize: true,
                    resizeObserver: true,
                    nested: false,
                    createElements: false,
                    enabled: true,
                    focusableElements: 'input, select, option, textarea, button, video, label',
                    // Overrides
                    width: null,
                    height: null,
                    //
                    preventInteractionOnTransition: false,
                    // ssr
                    userAgent: null,
                    url: null,
                    // To support iOS's swipe-to-go-back gesture (when being used in-app).
                    edgeSwipeDetection: false,
                    edgeSwipeThreshold: 20,
                    // Autoheight
                    autoHeight: false,
                    // Set wrapper width
                    setWrapperSize: false,
                    // Virtual Translate
                    virtualTranslate: false,
                    // Effects
                    effect: 'slide',
                    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

                    // Breakpoints
                    breakpoints: undefined,
                    breakpointsBase: 'window',
                    // Slides grid
                    spaceBetween: 0,
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    slidesPerGroupSkip: 0,
                    slidesPerGroupAuto: false,
                    centeredSlides: false,
                    centeredSlidesBounds: false,
                    slidesOffsetBefore: 0,
                    // in px
                    slidesOffsetAfter: 0,
                    // in px
                    normalizeSlideIndex: true,
                    centerInsufficientSlides: false,
                    // Disable swiper and hide navigation when container not overflow
                    watchOverflow: true,
                    // Round length
                    roundLengths: false,
                    // Touches
                    touchRatio: 1,
                    touchAngle: 45,
                    simulateTouch: true,
                    shortSwipes: true,
                    longSwipes: true,
                    longSwipesRatio: 0.5,
                    longSwipesMs: 300,
                    followFinger: true,
                    allowTouchMove: true,
                    threshold: 5,
                    touchMoveStopPropagation: false,
                    touchStartPreventDefault: true,
                    touchStartForcePreventDefault: false,
                    touchReleaseOnEdges: false,
                    // Unique Navigation Elements
                    uniqueNavElements: true,
                    // Resistance
                    resistance: true,
                    resistanceRatio: 0.85,
                    // Progress
                    watchSlidesProgress: false,
                    // Cursor
                    grabCursor: false,
                    // Clicks
                    preventClicks: true,
                    preventClicksPropagation: true,
                    slideToClickedSlide: false,
                    // loop
                    loop: false,
                    loopedSlides: null,
                    loopPreventsSliding: true,
                    // rewind
                    rewind: false,
                    // Swiping/no swiping
                    allowSlidePrev: true,
                    allowSlideNext: true,
                    swipeHandler: null,
                    // '.swipe-handler',
                    noSwiping: true,
                    noSwipingClass: 'swiper-no-swiping',
                    noSwipingSelector: null,
                    // Passive Listeners
                    passiveListeners: true,
                    maxBackfaceHiddenSlides: 10,
                    // NS
                    containerModifierClass: 'swiper-',
                    // NEW
                    slideClass: 'swiper-slide',
                    slideActiveClass: 'swiper-slide-active',
                    slideVisibleClass: 'swiper-slide-visible',
                    slideNextClass: 'swiper-slide-next',
                    slidePrevClass: 'swiper-slide-prev',
                    wrapperClass: 'swiper-wrapper',
                    lazyPreloaderClass: 'swiper-lazy-preloader',
                    lazyPreloadPrevNext: 0,
                    // Callbacks
                    runCallbacksOnInit: true,
                    // Internals
                    _emitClasses: false
                };

                function moduleExtendParams(params, allModulesParams) {
                    return function extendParams(obj) {
                        if (obj === void 0) {
                            obj = {};
                        }
                        const moduleParamName = Object.keys(obj)[0];
                        const moduleParams = obj[moduleParamName];
                        if (typeof moduleParams !== 'object' || moduleParams === null) {
                            utils_extend(allModulesParams, obj);
                            return;
                        }
                        if (params[moduleParamName] === true) {
                            params[moduleParamName] = {
                                enabled: true
                            };
                        }
                        if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
                            params[moduleParamName].auto = true;
                        }
                        if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
                            params[moduleParamName].auto = true;
                        }
                        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
                            utils_extend(allModulesParams, obj);
                            return;
                        }
                        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
                            params[moduleParamName].enabled = true;
                        }
                        if (!params[moduleParamName]) params[moduleParamName] = {
                            enabled: false
                        };
                        utils_extend(allModulesParams, obj);
                    };
                }

                /* eslint no-param-reassign: "off" */
                const prototypes = {
                    eventsEmitter,
                    update,
                    translate,
                    transition,
                    slide,
                    loop,
                    grabCursor,
                    events: events$1,
                    breakpoints,
                    checkOverflow: checkOverflow$1,
                    classes
                };
                const extendedDefaults = {};
                class Swiper {
                    constructor() {
                        let el;
                        let params;
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }
                        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
                            params = args[0];
                        } else {
                            [el, params] = args;
                        }
                        if (!params) params = {};
                        params = utils_extend({}, params);
                        if (el && !params.el) params.el = el;
                        const document = ssr_window_esm_getDocument();
                        if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
                            const swipers = [];
                            document.querySelectorAll(params.el).forEach(containerEl => {
                                const newParams = utils_extend({}, params, {
                                    el: containerEl
                                });
                                swipers.push(new Swiper(newParams));
                            });
                            // eslint-disable-next-line no-constructor-return
                            return swipers;
                        }

                        // Swiper Instance
                        const swiper = this;
                        swiper.__swiper__ = true;
                        swiper.support = getSupport();
                        swiper.device = getDevice({
                            userAgent: params.userAgent
                        });
                        swiper.browser = getBrowser();
                        swiper.eventsListeners = {};
                        swiper.eventsAnyListeners = [];
                        swiper.modules = [...swiper.__modules__];
                        if (params.modules && Array.isArray(params.modules)) {
                            swiper.modules.push(...params.modules);
                        }
                        const allModulesParams = {};
                        swiper.modules.forEach(mod => {
                            mod({
                                params,
                                swiper,
                                extendParams: moduleExtendParams(params, allModulesParams),
                                on: swiper.on.bind(swiper),
                                once: swiper.once.bind(swiper),
                                off: swiper.off.bind(swiper),
                                emit: swiper.emit.bind(swiper)
                            });
                        });

                        // Extend defaults with modules params
                        const swiperParams = utils_extend({}, defaults, allModulesParams);

                        // Extend defaults with passed params
                        swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                        swiper.originalParams = utils_extend({}, swiper.params);
                        swiper.passedParams = utils_extend({}, params);

                        // add event listeners
                        if (swiper.params && swiper.params.on) {
                            Object.keys(swiper.params.on).forEach(eventName => {
                                swiper.on(eventName, swiper.params.on[eventName]);
                            });
                        }
                        if (swiper.params && swiper.params.onAny) {
                            swiper.onAny(swiper.params.onAny);
                        }

                        // Extend Swiper
                        Object.assign(swiper, {
                            enabled: swiper.params.enabled,
                            el,
                            // Classes
                            classNames: [],
                            // Slides
                            slides: [],
                            slidesGrid: [],
                            snapGrid: [],
                            slidesSizesGrid: [],
                            // isDirection
                            isHorizontal() {
                                return swiper.params.direction === 'horizontal';
                            },
                            isVertical() {
                                return swiper.params.direction === 'vertical';
                            },
                            // Indexes
                            activeIndex: 0,
                            realIndex: 0,
                            //
                            isBeginning: true,
                            isEnd: false,
                            // Props
                            translate: 0,
                            previousTranslate: 0,
                            progress: 0,
                            velocity: 0,
                            animating: false,
                            cssOverflowAdjustment() {
                                // Returns 0 unless `translate` is > 2**23
                                // Should be subtracted from css values to prevent overflow
                                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                            },
                            // Locks
                            allowSlideNext: swiper.params.allowSlideNext,
                            allowSlidePrev: swiper.params.allowSlidePrev,
                            // Touch Events
                            touchEventsData: {
                                isTouched: undefined,
                                isMoved: undefined,
                                allowTouchCallbacks: undefined,
                                touchStartTime: undefined,
                                isScrolling: undefined,
                                currentTranslate: undefined,
                                startTranslate: undefined,
                                allowThresholdMove: undefined,
                                // Form elements to match
                                focusableElements: swiper.params.focusableElements,
                                // Last click time
                                lastClickTime: 0,
                                clickTimeout: undefined,
                                // Velocities
                                velocities: [],
                                allowMomentumBounce: undefined,
                                startMoving: undefined,
                                evCache: []
                            },
                            // Clicks
                            allowClick: true,
                            // Touches
                            allowTouchMove: swiper.params.allowTouchMove,
                            touches: {
                                startX: 0,
                                startY: 0,
                                currentX: 0,
                                currentY: 0,
                                diff: 0
                            },
                            // Images
                            imagesToLoad: [],
                            imagesLoaded: 0
                        });
                        swiper.emit('_swiper');

                        // Init
                        if (swiper.params.init) {
                            swiper.init();
                        }

                        // Return app instance
                        // eslint-disable-next-line no-constructor-return
                        return swiper;
                    }
                    getSlideIndex(slideEl) {
                        const {
                            slidesEl,
                            params
                        } = this;
                        const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                        const firstSlideIndex = utils_elementIndex(slides[0]);
                        return utils_elementIndex(slideEl) - firstSlideIndex;
                    }
                    getSlideIndexByData(index) {
                        return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
                    }
                    recalcSlides() {
                        const swiper = this;
                        const {
                            slidesEl,
                            params
                        } = swiper;
                        swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                    }
                    enable() {
                        const swiper = this;
                        if (swiper.enabled) return;
                        swiper.enabled = true;
                        if (swiper.params.grabCursor) {
                            swiper.setGrabCursor();
                        }
                        swiper.emit('enable');
                    }
                    disable() {
                        const swiper = this;
                        if (!swiper.enabled) return;
                        swiper.enabled = false;
                        if (swiper.params.grabCursor) {
                            swiper.unsetGrabCursor();
                        }
                        swiper.emit('disable');
                    }
                    setProgress(progress, speed) {
                        const swiper = this;
                        progress = Math.min(Math.max(progress, 0), 1);
                        const min = swiper.minTranslate();
                        const max = swiper.maxTranslate();
                        const current = (max - min) * progress + min;
                        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                    }
                    emitContainerClasses() {
                        const swiper = this;
                        if (!swiper.params._emitClasses || !swiper.el) return;
                        const cls = swiper.el.className.split(' ').filter(className => {
                            return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
                        });
                        swiper.emit('_containerClasses', cls.join(' '));
                    }
                    getSlideClasses(slideEl) {
                        const swiper = this;
                        if (swiper.destroyed) return '';
                        return slideEl.className.split(' ').filter(className => {
                            return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
                        }).join(' ');
                    }
                    emitSlidesClasses() {
                        const swiper = this;
                        if (!swiper.params._emitClasses || !swiper.el) return;
                        const updates = [];
                        swiper.slides.forEach(slideEl => {
                            const classNames = swiper.getSlideClasses(slideEl);
                            updates.push({
                                slideEl,
                                classNames
                            });
                            swiper.emit('_slideClass', slideEl, classNames);
                        });
                        swiper.emit('_slideClasses', updates);
                    }
                    slidesPerViewDynamic(view, exact) {
                        if (view === void 0) {
                            view = 'current';
                        }
                        if (exact === void 0) {
                            exact = false;
                        }
                        const swiper = this;
                        const {
                            params,
                            slides,
                            slidesGrid,
                            slidesSizesGrid,
                            size: swiperSize,
                            activeIndex
                        } = swiper;
                        let spv = 1;
                        if (typeof params.slidesPerView === 'number') return params.slidesPerView;
                        if (params.centeredSlides) {
                            let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
                            let breakLoop;
                            for (let i = activeIndex + 1; i < slides.length; i += 1) {
                                if (slides[i] && !breakLoop) {
                                    slideSize += slides[i].swiperSlideSize;
                                    spv += 1;
                                    if (slideSize > swiperSize) breakLoop = true;
                                }
                            }
                            for (let i = activeIndex - 1; i >= 0; i -= 1) {
                                if (slides[i] && !breakLoop) {
                                    slideSize += slides[i].swiperSlideSize;
                                    spv += 1;
                                    if (slideSize > swiperSize) breakLoop = true;
                                }
                            }
                        } else {
                            // eslint-disable-next-line
                            if (view === 'current') {
                                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                                    if (slideInView) {
                                        spv += 1;
                                    }
                                }
                            } else {
                                // previous
                                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                                    if (slideInView) {
                                        spv += 1;
                                    }
                                }
                            }
                        }
                        return spv;
                    }
                    update() {
                        const swiper = this;
                        if (!swiper || swiper.destroyed) return;
                        const {
                            snapGrid,
                            params
                        } = swiper;
                        // Breakpoints
                        if (params.breakpoints) {
                            swiper.setBreakpoint();
                        }
                        [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
                            if (imageEl.complete) {
                                processLazyPreloader(swiper, imageEl);
                            }
                        });
                        swiper.updateSize();
                        swiper.updateSlides();
                        swiper.updateProgress();
                        swiper.updateSlidesClasses();

                        function setTranslate() {
                            const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                            const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                            swiper.setTranslate(newTranslate);
                            swiper.updateActiveIndex();
                            swiper.updateSlidesClasses();
                        }
                        let translated;
                        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
                            setTranslate();
                            if (params.autoHeight) {
                                swiper.updateAutoHeight();
                            }
                        } else {
                            if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                                translated = swiper.slideTo(slides.length - 1, 0, false, true);
                            } else {
                                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                            }
                            if (!translated) {
                                setTranslate();
                            }
                        }
                        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                            swiper.checkOverflow();
                        }
                        swiper.emit('update');
                    }
                    changeDirection(newDirection, needUpdate) {
                        if (needUpdate === void 0) {
                            needUpdate = true;
                        }
                        const swiper = this;
                        const currentDirection = swiper.params.direction;
                        if (!newDirection) {
                            // eslint-disable-next-line
                            newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
                        }
                        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
                            return swiper;
                        }
                        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                        swiper.emitContainerClasses();
                        swiper.params.direction = newDirection;
                        swiper.slides.forEach(slideEl => {
                            if (newDirection === 'vertical') {
                                slideEl.style.width = '';
                            } else {
                                slideEl.style.height = '';
                            }
                        });
                        swiper.emit('changeDirection');
                        if (needUpdate) swiper.update();
                        return swiper;
                    }
                    changeLanguageDirection(direction) {
                        const swiper = this;
                        if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
                        swiper.rtl = direction === 'rtl';
                        swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
                        if (swiper.rtl) {
                            swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                            swiper.el.dir = 'rtl';
                        } else {
                            swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                            swiper.el.dir = 'ltr';
                        }
                        swiper.update();
                    }
                    mount(element) {
                        const swiper = this;
                        if (swiper.mounted) return true;

                        // Find el
                        let el = element || swiper.params.el;
                        if (typeof el === 'string') {
                            el = document.querySelector(el);
                        }
                        if (!el) {
                            return false;
                        }
                        el.swiper = swiper;
                        if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === 'SWIPER-CONTAINER') {
                            swiper.isElement = true;
                        }
                        const getWrapperSelector = () => {
                            return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
                        };
                        const getWrapper = () => {
                            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                                const res = el.shadowRoot.querySelector(getWrapperSelector());
                                // Children needs to return slot items
                                return res;
                            }
                            return utils_elementChildren(el, getWrapperSelector())[0];
                        };
                        // Find Wrapper
                        let wrapperEl = getWrapper();
                        if (!wrapperEl && swiper.params.createElements) {
                            wrapperEl = utils_createElement('div', swiper.params.wrapperClass);
                            el.append(wrapperEl);
                            utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
                                wrapperEl.append(slideEl);
                            });
                        }
                        Object.assign(swiper, {
                            el,
                            wrapperEl,
                            slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
                            hostEl: swiper.isElement ? el.parentNode.host : el,
                            mounted: true,
                            // RTL
                            rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
                            rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
                            wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
                        });
                        return true;
                    }
                    init(el) {
                        const swiper = this;
                        if (swiper.initialized) return swiper;
                        const mounted = swiper.mount(el);
                        if (mounted === false) return swiper;
                        swiper.emit('beforeInit');

                        // Set breakpoint
                        if (swiper.params.breakpoints) {
                            swiper.setBreakpoint();
                        }

                        // Add Classes
                        swiper.addClasses();

                        // Update size
                        swiper.updateSize();

                        // Update slides
                        swiper.updateSlides();
                        if (swiper.params.watchOverflow) {
                            swiper.checkOverflow();
                        }

                        // Set Grab Cursor
                        if (swiper.params.grabCursor && swiper.enabled) {
                            swiper.setGrabCursor();
                        }

                        // Slide To Initial Slide
                        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
                            swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
                        } else {
                            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                        }

                        // Create loop
                        if (swiper.params.loop) {
                            swiper.loopCreate();
                        }

                        // Attach events
                        swiper.attachEvents();
                        const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
                        if (swiper.isElement) {
                            lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
                        }
                        lazyElements.forEach(imageEl => {
                            if (imageEl.complete) {
                                processLazyPreloader(swiper, imageEl);
                            } else {
                                imageEl.addEventListener('load', e => {
                                    processLazyPreloader(swiper, e.target);
                                });
                            }
                        });
                        preload(swiper);

                        // Init Flag
                        swiper.initialized = true;
                        preload(swiper);

                        // Emit
                        swiper.emit('init');
                        swiper.emit('afterInit');
                        return swiper;
                    }
                    destroy(deleteInstance, cleanStyles) {
                        if (deleteInstance === void 0) {
                            deleteInstance = true;
                        }
                        if (cleanStyles === void 0) {
                            cleanStyles = true;
                        }
                        const swiper = this;
                        const {
                            params,
                            el,
                            wrapperEl,
                            slides
                        } = swiper;
                        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                            return null;
                        }
                        swiper.emit('beforeDestroy');

                        // Init Flag
                        swiper.initialized = false;

                        // Detach events
                        swiper.detachEvents();

                        // Destroy loop
                        if (params.loop) {
                            swiper.loopDestroy();
                        }

                        // Cleanup styles
                        if (cleanStyles) {
                            swiper.removeClasses();
                            el.removeAttribute('style');
                            wrapperEl.removeAttribute('style');
                            if (slides && slides.length) {
                                slides.forEach(slideEl => {
                                    slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                                    slideEl.removeAttribute('style');
                                    slideEl.removeAttribute('data-swiper-slide-index');
                                });
                            }
                        }
                        swiper.emit('destroy');

                        // Detach emitter events
                        Object.keys(swiper.eventsListeners).forEach(eventName => {
                            swiper.off(eventName);
                        });
                        if (deleteInstance !== false) {
                            swiper.el.swiper = null;
                            deleteProps(swiper);
                        }
                        swiper.destroyed = true;
                        return null;
                    }
                    static extendDefaults(newDefaults) {
                        utils_extend(extendedDefaults, newDefaults);
                    }
                    static get extendedDefaults() {
                        return extendedDefaults;
                    }
                    static get defaults() {
                        return defaults;
                    }
                    static installModule(mod) {
                        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
                        const modules = Swiper.prototype.__modules__;
                        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
                            modules.push(mod);
                        }
                    }
                    static use(module) {
                        if (Array.isArray(module)) {
                            module.forEach(m => Swiper.installModule(m));
                            return Swiper;
                        }
                        Swiper.installModule(module);
                        return Swiper;
                    }
                }
                Object.keys(prototypes).forEach(prototypeGroup => {
                    Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
                        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
                    });
                });
                Swiper.use([Resize, Observer]);



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/update-swiper.mjs
                /* underscore in name -> watch for changes */
                const paramsList = ['eventsPrefix', 'injectStyles', 'injectStylesUrls', 'modules', 'init', '_direction', 'oneWayMovement', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', 'breakpointsBase', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_loop', 'loopedSlides', 'loopPreventsSliding', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideActiveClass', 'slideVisibleClass', 'slideNextClass', 'slidePrevClass', 'wrapperClass', 'lazyPreloaderClass', 'lazyPreloadPrevNext', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren',
                    // modules
                    'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom', 'control'
                ];

                function update_swiper_isObject(o) {
                    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object' && !o.__swiper__;
                }

                function update_swiper_extend(target, src) {
                    const noExtend = ['__proto__', 'constructor', 'prototype'];
                    Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
                        if (typeof target[key] === 'undefined') target[key] = src[key];
                        else if (update_swiper_isObject(src[key]) && update_swiper_isObject(target[key]) && Object.keys(src[key]).length > 0) {
                            if (src[key].__swiper__) target[key] = src[key];
                            else update_swiper_extend(target[key], src[key]);
                        } else {
                            target[key] = src[key];
                        }
                    });
                }

                function needsNavigation(params) {
                    if (params === void 0) {
                        params = {};
                    }
                    return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
                }

                function needsPagination(params) {
                    if (params === void 0) {
                        params = {};
                    }
                    return params.pagination && typeof params.pagination.el === 'undefined';
                }

                function needsScrollbar(params) {
                    if (params === void 0) {
                        params = {};
                    }
                    return params.scrollbar && typeof params.scrollbar.el === 'undefined';
                }

                function uniqueClasses(classNames) {
                    if (classNames === void 0) {
                        classNames = '';
                    }
                    const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);
                    const unique = [];
                    classes.forEach(c => {
                        if (unique.indexOf(c) < 0) unique.push(c);
                    });
                    return unique.join(' ');
                }

                function attrToProp(attrName) {
                    if (attrName === void 0) {
                        attrName = '';
                    }
                    return attrName.replace(/-[a-z]/g, l => l.toUpperCase().replace('-', ''));
                }

                function wrapperClass(className) {
                    if (className === void 0) {
                        className = '';
                    }
                    if (!className) return 'swiper-wrapper';
                    if (!className.includes('swiper-wrapper')) return `swiper-wrapper ${className}`;
                    return className;
                }

                function updateSwiper(_ref) {
                    let {
                        swiper,
                        slides,
                        passedParams,
                        changedParams,
                        nextEl,
                        prevEl,
                        scrollbarEl,
                        paginationEl
                    } = _ref;
                    const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction' && key !== 'wrapperClass');
                    const {
                        params: currentParams,
                        pagination,
                        navigation,
                        scrollbar,
                        virtual,
                        thumbs
                    } = swiper;
                    let needThumbsInit;
                    let needControllerInit;
                    let needPaginationInit;
                    let needScrollbarInit;
                    let needNavigationInit;
                    let loopNeedDestroy;
                    let loopNeedEnable;
                    let loopNeedReloop;
                    if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
                        needThumbsInit = true;
                    }
                    if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
                        needControllerInit = true;
                    }
                    if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
                        needPaginationInit = true;
                    }
                    if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
                        needScrollbarInit = true;
                    }
                    if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
                        needNavigationInit = true;
                    }
                    const destroyModule = mod => {
                        if (!swiper[mod]) return;
                        swiper[mod].destroy();
                        if (mod === 'navigation') {
                            if (swiper.isElement) {
                                swiper[mod].prevEl.remove();
                                swiper[mod].nextEl.remove();
                            }
                            currentParams[mod].prevEl = undefined;
                            currentParams[mod].nextEl = undefined;
                            swiper[mod].prevEl = undefined;
                            swiper[mod].nextEl = undefined;
                        } else {
                            if (swiper.isElement) {
                                swiper[mod].el.remove();
                            }
                            currentParams[mod].el = undefined;
                            swiper[mod].el = undefined;
                        }
                    };
                    if (changedParams.includes('loop') && swiper.isElement) {
                        if (currentParams.loop && !passedParams.loop) {
                            loopNeedDestroy = true;
                        } else if (!currentParams.loop && passedParams.loop) {
                            loopNeedEnable = true;
                        } else {
                            loopNeedReloop = true;
                        }
                    }
                    updateParams.forEach(key => {
                        if (update_swiper_isObject(currentParams[key]) && update_swiper_isObject(passedParams[key])) {
                            update_swiper_extend(currentParams[key], passedParams[key]);
                            if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {
                                destroyModule(key);
                            }
                        } else {
                            const newValue = passedParams[key];
                            if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
                                if (newValue === false) {
                                    destroyModule(key);
                                }
                            } else {
                                currentParams[key] = passedParams[key];
                            }
                        }
                    });
                    if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
                        swiper.controller.control = currentParams.controller.control;
                    }
                    if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
                        virtual.slides = slides;
                        virtual.update(true);
                    }
                    if (changedParams.includes('children') && slides && currentParams.loop) {
                        loopNeedReloop = true;
                    }
                    if (needThumbsInit) {
                        const initialized = thumbs.init();
                        if (initialized) thumbs.update(true);
                    }
                    if (needControllerInit) {
                        swiper.controller.control = currentParams.controller.control;
                    }
                    if (needPaginationInit) {
                        if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {
                            paginationEl = document.createElement('div');
                            paginationEl.classList.add('swiper-pagination');
                            paginationEl.part.add('pagination');
                            swiper.el.appendChild(paginationEl);
                        }
                        if (paginationEl) currentParams.pagination.el = paginationEl;
                        pagination.init();
                        pagination.render();
                        pagination.update();
                    }
                    if (needScrollbarInit) {
                        if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {
                            scrollbarEl = document.createElement('div');
                            scrollbarEl.classList.add('swiper-scrollbar');
                            scrollbarEl.part.add('scrollbar');
                            swiper.el.appendChild(scrollbarEl);
                        }
                        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
                        scrollbar.init();
                        scrollbar.updateSize();
                        scrollbar.setTranslate();
                    }
                    if (needNavigationInit) {
                        if (swiper.isElement) {
                            if (!nextEl || typeof nextEl === 'string') {
                                nextEl = document.createElement('div');
                                nextEl.classList.add('swiper-button-next');
                                nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;
                                nextEl.part.add('button-next');
                                swiper.el.appendChild(nextEl);
                            }
                            if (!prevEl || typeof prevEl === 'string') {
                                prevEl = document.createElement('div');
                                prevEl.classList.add('swiper-button-prev');
                                prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;
                                prevEl.part.add('button-prev');
                                swiper.el.appendChild(prevEl);
                            }
                        }
                        if (nextEl) currentParams.navigation.nextEl = nextEl;
                        if (prevEl) currentParams.navigation.prevEl = prevEl;
                        navigation.init();
                        navigation.update();
                    }
                    if (changedParams.includes('allowSlideNext')) {
                        swiper.allowSlideNext = passedParams.allowSlideNext;
                    }
                    if (changedParams.includes('allowSlidePrev')) {
                        swiper.allowSlidePrev = passedParams.allowSlidePrev;
                    }
                    if (changedParams.includes('direction')) {
                        swiper.changeDirection(passedParams.direction, false);
                    }
                    if (loopNeedDestroy || loopNeedReloop) {
                        swiper.loopDestroy();
                    }
                    if (loopNeedEnable || loopNeedReloop) {
                        swiper.loopCreate();
                    }
                    swiper.update();
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/update-on-virtual-data.mjs



                function getParams(obj, splitEvents) {
                    if (obj === void 0) {
                        obj = {};
                    }
                    if (splitEvents === void 0) {
                        splitEvents = true;
                    }
                    const params = {
                        on: {}
                    };
                    const events = {};
                    const passedParams = {};
                    update_swiper_extend(params, defaults);
                    params._emitClasses = true;
                    params.init = false;
                    const rest = {};
                    const allowedParams = paramsList.map(key => key.replace(/_/, ''));
                    const plainObj = Object.assign({}, obj);
                    Object.keys(plainObj).forEach(key => {
                        if (typeof obj[key] === 'undefined') return;
                        if (allowedParams.indexOf(key) >= 0) {
                            if (update_swiper_isObject(obj[key])) {
                                params[key] = {};
                                passedParams[key] = {};
                                update_swiper_extend(params[key], obj[key]);
                                update_swiper_extend(passedParams[key], obj[key]);
                            } else {
                                params[key] = obj[key];
                                passedParams[key] = obj[key];
                            }
                        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
                            if (splitEvents) {
                                events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
                            } else {
                                params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
                            }
                        } else {
                            rest[key] = obj[key];
                        }
                    });
                    ['navigation', 'pagination', 'scrollbar'].forEach(key => {
                        if (params[key] === true) params[key] = {};
                        if (params[key] === false) delete params[key];
                    });
                    return {
                        params,
                        passedParams,
                        rest,
                        events
                    };
                }

                function mountSwiper(_ref, swiperParams) {
                    let {
                        el,
                        nextEl,
                        prevEl,
                        paginationEl,
                        scrollbarEl,
                        swiper
                    } = _ref;
                    if (needsNavigation(swiperParams) && nextEl && prevEl) {
                        swiper.params.navigation.nextEl = nextEl;
                        swiper.originalParams.navigation.nextEl = nextEl;
                        swiper.params.navigation.prevEl = prevEl;
                        swiper.originalParams.navigation.prevEl = prevEl;
                    }
                    if (needsPagination(swiperParams) && paginationEl) {
                        swiper.params.pagination.el = paginationEl;
                        swiper.originalParams.pagination.el = paginationEl;
                    }
                    if (needsScrollbar(swiperParams) && scrollbarEl) {
                        swiper.params.scrollbar.el = scrollbarEl;
                        swiper.originalParams.scrollbar.el = scrollbarEl;
                    }
                    swiper.init(el);
                }

                function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
                    const keys = [];
                    if (!oldParams) return keys;
                    const addKey = key => {
                        if (keys.indexOf(key) < 0) keys.push(key);
                    };
                    if (children && oldChildren) {
                        const oldChildrenKeys = oldChildren.map(getKey);
                        const childrenKeys = children.map(getKey);
                        if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
                        if (oldChildren.length !== children.length) addKey('children');
                    }
                    const watchParams = paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));
                    watchParams.forEach(key => {
                        if (key in swiperParams && key in oldParams) {
                            if (update_swiper_isObject(swiperParams[key]) && update_swiper_isObject(oldParams[key])) {
                                const newKeys = Object.keys(swiperParams[key]);
                                const oldKeys = Object.keys(oldParams[key]);
                                if (newKeys.length !== oldKeys.length) {
                                    addKey(key);
                                } else {
                                    newKeys.forEach(newKey => {
                                        if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
                                            addKey(key);
                                        }
                                    });
                                    oldKeys.forEach(oldKey => {
                                        if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
                                    });
                                }
                            } else if (swiperParams[key] !== oldParams[key]) {
                                addKey(key);
                            }
                        }
                    });
                    return keys;
                }

                const updateOnVirtualData = swiper => {
                    if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
                    swiper.updateSlides();
                    swiper.updateProgress();
                    swiper.updateSlidesClasses();
                    if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
                        swiper.parallax.setTranslate();
                    }
                };



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/swiper-react.mjs
                /**
                 * Swiper React 10.3.1
                 * Most modern mobile touch slider and framework with hardware accelerated transitions
                 * https://swiperjs.com
                 *
                 * Copyright 2014-2023 Vladimir Kharlampidi
                 *
                 * Released under the MIT License
                 *
                 * Released on: September 28, 2023
                 */






                function _extends() {
                    _extends = Object.assign ? Object.assign.bind() : function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    return _extends.apply(this, arguments);
                }

                function isChildSwiperSlide(child) {
                    return child.type && child.type.displayName && child.type.displayName.includes('SwiperSlide');
                }

                function processChildren(c) {
                    const slides = [];
                    external_React_.Children.toArray(c).forEach(child => {
                        if (isChildSwiperSlide(child)) {
                            slides.push(child);
                        } else if (child.props && child.props.children) {
                            processChildren(child.props.children).forEach(slide => slides.push(slide));
                        }
                    });
                    return slides;
                }

                function getChildren(c) {
                    const slides = [];
                    const slots = {
                        'container-start': [],
                        'container-end': [],
                        'wrapper-start': [],
                        'wrapper-end': []
                    };
                    external_React_.Children.toArray(c).forEach(child => {
                        if (isChildSwiperSlide(child)) {
                            slides.push(child);
                        } else if (child.props && child.props.slot && slots[child.props.slot]) {
                            slots[child.props.slot].push(child);
                        } else if (child.props && child.props.children) {
                            const foundSlides = processChildren(child.props.children);
                            if (foundSlides.length > 0) {
                                foundSlides.forEach(slide => slides.push(slide));
                            } else {
                                slots['container-end'].push(child);
                            }
                        } else {
                            slots['container-end'].push(child);
                        }
                    });
                    return {
                        slides,
                        slots
                    };
                }

                function renderVirtual(swiper, slides, virtualData) {
                    if (!virtualData) return null;
                    const getSlideIndex = index => {
                        let slideIndex = index;
                        if (index < 0) {
                            slideIndex = slides.length + index;
                        } else if (slideIndex >= slides.length) {
                            // eslint-disable-next-line
                            slideIndex = slideIndex - slides.length;
                        }
                        return slideIndex;
                    };
                    const style = swiper.isHorizontal() ? {
                        [swiper.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
                    } : {
                        top: `${virtualData.offset}px`
                    };
                    const {
                        from,
                        to
                    } = virtualData;
                    const loopFrom = swiper.params.loop ? -slides.length : 0;
                    const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
                    const slidesToRender = [];
                    for (let i = loopFrom; i < loopTo; i += 1) {
                        if (i >= from && i <= to) {
                            slidesToRender.push(slides[getSlideIndex(i)]);
                        }
                    }
                    return slidesToRender.map((child, index) => {
                        return /*#__PURE__*/ external_React_.cloneElement(child, {
                            swiper,
                            style,
                            key: `slide-${index}`
                        });
                    });
                }

                function useIsomorphicLayoutEffect(callback, deps) {
                    // eslint-disable-next-line
                    if (false) {}
                    return (0, external_React_.useLayoutEffect)(callback, deps);
                }

                const SwiperSlideContext = /*#__PURE__*/ (0, external_React_.createContext)(null);
                const useSwiperSlide = () => {
                    return useContext(SwiperSlideContext);
                };
                const SwiperContext = /*#__PURE__*/ (0, external_React_.createContext)(null);
                const useSwiper = () => {
                    return useContext(SwiperContext);
                };

                const swiper_react_Swiper = /*#__PURE__*/ (0, external_React_.forwardRef)(function(_temp, externalElRef) {
                    let {
                        className,
                        tag: Tag = 'div',
                        wrapperTag: WrapperTag = 'div',
                        children,
                        onSwiper,
                        ...rest
                    } = _temp === void 0 ? {} : _temp;
                    let eventsAssigned = false;
                    const [containerClasses, setContainerClasses] = (0, external_React_.useState)('swiper');
                    const [virtualData, setVirtualData] = (0, external_React_.useState)(null);
                    const [breakpointChanged, setBreakpointChanged] = (0, external_React_.useState)(false);
                    const initializedRef = (0, external_React_.useRef)(false);
                    const swiperElRef = (0, external_React_.useRef)(null);
                    const swiperRef = (0, external_React_.useRef)(null);
                    const oldPassedParamsRef = (0, external_React_.useRef)(null);
                    const oldSlides = (0, external_React_.useRef)(null);
                    const nextElRef = (0, external_React_.useRef)(null);
                    const prevElRef = (0, external_React_.useRef)(null);
                    const paginationElRef = (0, external_React_.useRef)(null);
                    const scrollbarElRef = (0, external_React_.useRef)(null);
                    const {
                        params: swiperParams,
                        passedParams,
                        rest: restProps,
                        events
                    } = getParams(rest);
                    const {
                        slides,
                        slots
                    } = getChildren(children);
                    const onBeforeBreakpoint = () => {
                        setBreakpointChanged(!breakpointChanged);
                    };
                    Object.assign(swiperParams.on, {
                        _containerClasses(swiper, classes) {
                            setContainerClasses(classes);
                        }
                    });
                    const initSwiper = () => {
                        // init swiper
                        Object.assign(swiperParams.on, events);
                        eventsAssigned = true;
                        const passParams = {
                            ...swiperParams
                        };
                        delete passParams.wrapperClass;
                        swiperRef.current = new Swiper(passParams);
                        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
                            swiperRef.current.virtual.slides = slides;
                            const extendWith = {
                                cache: false,
                                slides,
                                renderExternal: setVirtualData,
                                renderExternalUpdate: false
                            };
                            update_swiper_extend(swiperRef.current.params.virtual, extendWith);
                            update_swiper_extend(swiperRef.current.originalParams.virtual, extendWith);
                        }
                    };
                    if (!swiperElRef.current) {
                        initSwiper();
                    }

                    // Listen for breakpoints change
                    if (swiperRef.current) {
                        swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
                    }
                    const attachEvents = () => {
                        if (eventsAssigned || !events || !swiperRef.current) return;
                        Object.keys(events).forEach(eventName => {
                            swiperRef.current.on(eventName, events[eventName]);
                        });
                    };
                    const detachEvents = () => {
                        if (!events || !swiperRef.current) return;
                        Object.keys(events).forEach(eventName => {
                            swiperRef.current.off(eventName, events[eventName]);
                        });
                    };
                    (0, external_React_.useEffect)(() => {
                        return () => {
                            if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
                        };
                    });

                    // set initialized flag
                    (0, external_React_.useEffect)(() => {
                        if (!initializedRef.current && swiperRef.current) {
                            swiperRef.current.emitSlidesClasses();
                            initializedRef.current = true;
                        }
                    });

                    // mount swiper
                    useIsomorphicLayoutEffect(() => {
                        if (externalElRef) {
                            externalElRef.current = swiperElRef.current;
                        }
                        if (!swiperElRef.current) return;
                        if (swiperRef.current.destroyed) {
                            initSwiper();
                        }
                        mountSwiper({
                            el: swiperElRef.current,
                            nextEl: nextElRef.current,
                            prevEl: prevElRef.current,
                            paginationEl: paginationElRef.current,
                            scrollbarEl: scrollbarElRef.current,
                            swiper: swiperRef.current
                        }, swiperParams);
                        if (onSwiper) onSwiper(swiperRef.current);
                        // eslint-disable-next-line
                        return () => {
                            if (swiperRef.current && !swiperRef.current.destroyed) {
                                swiperRef.current.destroy(true, false);
                            }
                        };
                    }, []);

                    // watch for params change
                    useIsomorphicLayoutEffect(() => {
                        attachEvents();
                        const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, c => c.key);
                        oldPassedParamsRef.current = passedParams;
                        oldSlides.current = slides;
                        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
                            updateSwiper({
                                swiper: swiperRef.current,
                                slides,
                                passedParams,
                                changedParams,
                                nextEl: nextElRef.current,
                                prevEl: prevElRef.current,
                                scrollbarEl: scrollbarElRef.current,
                                paginationEl: paginationElRef.current
                            });
                        }
                        return () => {
                            detachEvents();
                        };
                    });

                    // update on virtual update
                    useIsomorphicLayoutEffect(() => {
                        updateOnVirtualData(swiperRef.current);
                    }, [virtualData]);

                    // bypass swiper instance to slides
                    function renderSlides() {
                        if (swiperParams.virtual) {
                            return renderVirtual(swiperRef.current, slides, virtualData);
                        }
                        return slides.map((child, index) => {
                            return /*#__PURE__*/ external_React_.cloneElement(child, {
                                swiper: swiperRef.current,
                                swiperSlideIndex: index
                            });
                        });
                    }
                    return /*#__PURE__*/ external_React_.createElement(Tag, _extends({
                        ref: swiperElRef,
                        className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)
                    }, restProps), /*#__PURE__*/ external_React_.createElement(SwiperContext.Provider, {
                        value: swiperRef.current
                    }, slots['container-start'], /*#__PURE__*/ external_React_.createElement(WrapperTag, {
                        className: wrapperClass(swiperParams.wrapperClass)
                    }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), needsNavigation(swiperParams) && /*#__PURE__*/ external_React_.createElement(external_React_.Fragment, null, /*#__PURE__*/ external_React_.createElement("div", {
                        ref: prevElRef,
                        className: "swiper-button-prev"
                    }), /*#__PURE__*/ external_React_.createElement("div", {
                        ref: nextElRef,
                        className: "swiper-button-next"
                    })), needsScrollbar(swiperParams) && /*#__PURE__*/ external_React_.createElement("div", {
                        ref: scrollbarElRef,
                        className: "swiper-scrollbar"
                    }), needsPagination(swiperParams) && /*#__PURE__*/ external_React_.createElement("div", {
                        ref: paginationElRef,
                        className: "swiper-pagination"
                    }), slots['container-end']));
                });
                swiper_react_Swiper.displayName = 'Swiper';

                const SwiperSlide = /*#__PURE__*/ (0, external_React_.forwardRef)(function(_temp, externalRef) {
                    let {
                        tag: Tag = 'div',
                        children,
                        className = '',
                        swiper,
                        zoom,
                        lazy,
                        virtualIndex,
                        swiperSlideIndex,
                        ...rest
                    } = _temp === void 0 ? {} : _temp;
                    const slideElRef = (0, external_React_.useRef)(null);
                    const [slideClasses, setSlideClasses] = (0, external_React_.useState)('swiper-slide');
                    const [lazyLoaded, setLazyLoaded] = (0, external_React_.useState)(false);

                    function updateClasses(_s, el, classNames) {
                        if (el === slideElRef.current) {
                            setSlideClasses(classNames);
                        }
                    }
                    useIsomorphicLayoutEffect(() => {
                        if (typeof swiperSlideIndex !== 'undefined') {
                            slideElRef.current.swiperSlideIndex = swiperSlideIndex;
                        }
                        if (externalRef) {
                            externalRef.current = slideElRef.current;
                        }
                        if (!slideElRef.current || !swiper) {
                            return;
                        }
                        if (swiper.destroyed) {
                            if (slideClasses !== 'swiper-slide') {
                                setSlideClasses('swiper-slide');
                            }
                            return;
                        }
                        swiper.on('_slideClass', updateClasses);
                        // eslint-disable-next-line
                        return () => {
                            if (!swiper) return;
                            swiper.off('_slideClass', updateClasses);
                        };
                    });
                    useIsomorphicLayoutEffect(() => {
                        if (swiper && slideElRef.current && !swiper.destroyed) {
                            setSlideClasses(swiper.getSlideClasses(slideElRef.current));
                        }
                    }, [swiper]);
                    const slideData = {
                        isActive: slideClasses.indexOf('swiper-slide-active') >= 0,
                        isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,
                        isPrev: slideClasses.indexOf('swiper-slide-prev') >= 0,
                        isNext: slideClasses.indexOf('swiper-slide-next') >= 0
                    };
                    const renderChildren = () => {
                        return typeof children === 'function' ? children(slideData) : children;
                    };
                    const onLoad = () => {
                        setLazyLoaded(true);
                    };
                    return /*#__PURE__*/ external_React_.createElement(Tag, _extends({
                        ref: slideElRef,
                        className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ''}`),
                        "data-swiper-slide-index": virtualIndex,
                        onLoad: onLoad
                    }, rest), zoom && /*#__PURE__*/ external_React_.createElement(SwiperSlideContext.Provider, {
                        value: slideData
                    }, /*#__PURE__*/ external_React_.createElement("div", {
                        className: "swiper-zoom-container",
                        "data-swiper-zoom": typeof zoom === 'number' ? zoom : undefined
                    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ external_React_.createElement("div", {
                        className: "swiper-lazy-preloader"
                    }))), !zoom && /*#__PURE__*/ external_React_.createElement(SwiperSlideContext.Provider, {
                        value: slideData
                    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ external_React_.createElement("div", {
                        className: "swiper-lazy-preloader"
                    })));
                });
                SwiperSlide.displayName = 'SwiperSlide';



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/virtual.mjs



                function Virtual(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    extendParams({
                        virtual: {
                            enabled: false,
                            slides: [],
                            cache: true,
                            renderSlide: null,
                            renderExternal: null,
                            renderExternalUpdate: true,
                            addSlidesBefore: 0,
                            addSlidesAfter: 0
                        }
                    });
                    let cssModeTimeout;
                    const document = getDocument();
                    swiper.virtual = {
                        cache: {},
                        from: undefined,
                        to: undefined,
                        slides: [],
                        offset: 0,
                        slidesGrid: []
                    };
                    const tempDOM = document.createElement('div');

                    function renderSlide(slide, index) {
                        const params = swiper.params.virtual;
                        if (params.cache && swiper.virtual.cache[index]) {
                            return swiper.virtual.cache[index];
                        }
                        // eslint-disable-next-line
                        let slideEl;
                        if (params.renderSlide) {
                            slideEl = params.renderSlide.call(swiper, slide, index);
                            if (typeof slideEl === 'string') {
                                tempDOM.innerHTML = slideEl;
                                slideEl = tempDOM.children[0];
                            }
                        } else if (swiper.isElement) {
                            slideEl = createElement('swiper-slide');
                        } else {
                            slideEl = createElement('div', swiper.params.slideClass);
                        }
                        slideEl.setAttribute('data-swiper-slide-index', index);
                        if (!params.renderSlide) {
                            slideEl.innerHTML = slide;
                        }
                        if (params.cache) {
                            swiper.virtual.cache[index] = slideEl;
                        }
                        return slideEl;
                    }

                    function update(force) {
                        const {
                            slidesPerView,
                            slidesPerGroup,
                            centeredSlides,
                            loop: isLoop
                        } = swiper.params;
                        const {
                            addSlidesBefore,
                            addSlidesAfter
                        } = swiper.params.virtual;
                        const {
                            from: previousFrom,
                            to: previousTo,
                            slides,
                            slidesGrid: previousSlidesGrid,
                            offset: previousOffset
                        } = swiper.virtual;
                        if (!swiper.params.cssMode) {
                            swiper.updateActiveIndex();
                        }
                        const activeIndex = swiper.activeIndex || 0;
                        let offsetProp;
                        if (swiper.rtlTranslate) offsetProp = 'right';
                        else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
                        let slidesAfter;
                        let slidesBefore;
                        if (centeredSlides) {
                            slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
                            slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
                        } else {
                            slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
                            slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
                        }
                        let from = activeIndex - slidesBefore;
                        let to = activeIndex + slidesAfter;
                        if (!isLoop) {
                            from = Math.max(from, 0);
                            to = Math.min(to, slides.length - 1);
                        }
                        let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
                        if (isLoop && activeIndex >= slidesBefore) {
                            from -= slidesBefore;
                            if (!centeredSlides) offset += swiper.slidesGrid[0];
                        } else if (isLoop && activeIndex < slidesBefore) {
                            from = -slidesBefore;
                            if (centeredSlides) offset += swiper.slidesGrid[0];
                        }
                        Object.assign(swiper.virtual, {
                            from,
                            to,
                            offset,
                            slidesGrid: swiper.slidesGrid,
                            slidesBefore,
                            slidesAfter
                        });

                        function onRendered() {
                            swiper.updateSlides();
                            swiper.updateProgress();
                            swiper.updateSlidesClasses();
                            emit('virtualUpdate');
                        }
                        if (previousFrom === from && previousTo === to && !force) {
                            if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                                swiper.slides.forEach(slideEl => {
                                    slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
                                });
                            }
                            swiper.updateProgress();
                            emit('virtualUpdate');
                            return;
                        }
                        if (swiper.params.virtual.renderExternal) {
                            swiper.params.virtual.renderExternal.call(swiper, {
                                offset,
                                from,
                                to,
                                slides: function getSlides() {
                                    const slidesToRender = [];
                                    for (let i = from; i <= to; i += 1) {
                                        slidesToRender.push(slides[i]);
                                    }
                                    return slidesToRender;
                                }()
                            });
                            if (swiper.params.virtual.renderExternalUpdate) {
                                onRendered();
                            } else {
                                emit('virtualUpdate');
                            }
                            return;
                        }
                        const prependIndexes = [];
                        const appendIndexes = [];
                        const getSlideIndex = index => {
                            let slideIndex = index;
                            if (index < 0) {
                                slideIndex = slides.length + index;
                            } else if (slideIndex >= slides.length) {
                                // eslint-disable-next-line
                                slideIndex = slideIndex - slides.length;
                            }
                            return slideIndex;
                        };
                        if (force) {
                            swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {
                                slideEl.remove();
                            });
                        } else {
                            for (let i = previousFrom; i <= previousTo; i += 1) {
                                if (i < from || i > to) {
                                    const slideIndex = getSlideIndex(i);
                                    swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach(slideEl => {
                                        slideEl.remove();
                                    });
                                }
                            }
                        }
                        const loopFrom = isLoop ? -slides.length : 0;
                        const loopTo = isLoop ? slides.length * 2 : slides.length;
                        for (let i = loopFrom; i < loopTo; i += 1) {
                            if (i >= from && i <= to) {
                                const slideIndex = getSlideIndex(i);
                                if (typeof previousTo === 'undefined' || force) {
                                    appendIndexes.push(slideIndex);
                                } else {
                                    if (i > previousTo) appendIndexes.push(slideIndex);
                                    if (i < previousFrom) prependIndexes.push(slideIndex);
                                }
                            }
                        }
                        appendIndexes.forEach(index => {
                            swiper.slidesEl.append(renderSlide(slides[index], index));
                        });
                        if (isLoop) {
                            for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
                                const index = prependIndexes[i];
                                swiper.slidesEl.prepend(renderSlide(slides[index], index));
                            }
                        } else {
                            prependIndexes.sort((a, b) => b - a);
                            prependIndexes.forEach(index => {
                                swiper.slidesEl.prepend(renderSlide(slides[index], index));
                            });
                        }
                        elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {
                            slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
                        });
                        onRendered();
                    }

                    function appendSlide(slides) {
                        if (typeof slides === 'object' && 'length' in slides) {
                            for (let i = 0; i < slides.length; i += 1) {
                                if (slides[i]) swiper.virtual.slides.push(slides[i]);
                            }
                        } else {
                            swiper.virtual.slides.push(slides);
                        }
                        update(true);
                    }

                    function prependSlide(slides) {
                        const activeIndex = swiper.activeIndex;
                        let newActiveIndex = activeIndex + 1;
                        let numberOfNewSlides = 1;
                        if (Array.isArray(slides)) {
                            for (let i = 0; i < slides.length; i += 1) {
                                if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
                            }
                            newActiveIndex = activeIndex + slides.length;
                            numberOfNewSlides = slides.length;
                        } else {
                            swiper.virtual.slides.unshift(slides);
                        }
                        if (swiper.params.virtual.cache) {
                            const cache = swiper.virtual.cache;
                            const newCache = {};
                            Object.keys(cache).forEach(cachedIndex => {
                                const cachedEl = cache[cachedIndex];
                                const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');
                                if (cachedElIndex) {
                                    cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
                                }
                                newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
                            });
                            swiper.virtual.cache = newCache;
                        }
                        update(true);
                        swiper.slideTo(newActiveIndex, 0);
                    }

                    function removeSlide(slidesIndexes) {
                        if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
                        let activeIndex = swiper.activeIndex;
                        if (Array.isArray(slidesIndexes)) {
                            for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                                if (swiper.params.virtual.cache) {
                                    delete swiper.virtual.cache[slidesIndexes[i]];
                                    // shift cache indexes
                                    Object.keys(swiper.virtual.cache).forEach(key => {
                                        if (key > slidesIndexes) {
                                            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                                            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
                                            delete swiper.virtual.cache[key];
                                        }
                                    });
                                }
                                swiper.virtual.slides.splice(slidesIndexes[i], 1);
                                if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                                activeIndex = Math.max(activeIndex, 0);
                            }
                        } else {
                            if (swiper.params.virtual.cache) {
                                delete swiper.virtual.cache[slidesIndexes];
                                // shift cache indexes
                                Object.keys(swiper.virtual.cache).forEach(key => {
                                    if (key > slidesIndexes) {
                                        swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                                        swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
                                        delete swiper.virtual.cache[key];
                                    }
                                });
                            }
                            swiper.virtual.slides.splice(slidesIndexes, 1);
                            if (slidesIndexes < activeIndex) activeIndex -= 1;
                            activeIndex = Math.max(activeIndex, 0);
                        }
                        update(true);
                        swiper.slideTo(activeIndex, 0);
                    }

                    function removeAllSlides() {
                        swiper.virtual.slides = [];
                        if (swiper.params.virtual.cache) {
                            swiper.virtual.cache = {};
                        }
                        update(true);
                        swiper.slideTo(0, 0);
                    }
                    on('beforeInit', () => {
                        if (!swiper.params.virtual.enabled) return;
                        let domSlidesAssigned;
                        if (typeof swiper.passedParams.virtual.slides === 'undefined') {
                            const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
                            if (slides && slides.length) {
                                swiper.virtual.slides = [...slides];
                                domSlidesAssigned = true;
                                slides.forEach((slideEl, slideIndex) => {
                                    slideEl.setAttribute('data-swiper-slide-index', slideIndex);
                                    swiper.virtual.cache[slideIndex] = slideEl;
                                    slideEl.remove();
                                });
                            }
                        }
                        if (!domSlidesAssigned) {
                            swiper.virtual.slides = swiper.params.virtual.slides;
                        }
                        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
                        swiper.params.watchSlidesProgress = true;
                        swiper.originalParams.watchSlidesProgress = true;
                        update();
                    });
                    on('setTranslate', () => {
                        if (!swiper.params.virtual.enabled) return;
                        if (swiper.params.cssMode && !swiper._immediateVirtual) {
                            clearTimeout(cssModeTimeout);
                            cssModeTimeout = setTimeout(() => {
                                update();
                            }, 100);
                        } else {
                            update();
                        }
                    });
                    on('init update resize', () => {
                        if (!swiper.params.virtual.enabled) return;
                        if (swiper.params.cssMode) {
                            setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
                        }
                    });
                    Object.assign(swiper.virtual, {
                        appendSlide,
                        prependSlide,
                        removeSlide,
                        removeAllSlides,
                        update
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/keyboard.mjs



                /* eslint-disable consistent-return */
                function Keyboard(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    const document = getDocument();
                    const window = getWindow();
                    swiper.keyboard = {
                        enabled: false
                    };
                    extendParams({
                        keyboard: {
                            enabled: false,
                            onlyInViewport: true,
                            pageUpDown: true
                        }
                    });

                    function handle(event) {
                        if (!swiper.enabled) return;
                        const {
                            rtlTranslate: rtl
                        } = swiper;
                        let e = event;
                        if (e.originalEvent) e = e.originalEvent; // jquery fix
                        const kc = e.keyCode || e.charCode;
                        const pageUpDown = swiper.params.keyboard.pageUpDown;
                        const isPageUp = pageUpDown && kc === 33;
                        const isPageDown = pageUpDown && kc === 34;
                        const isArrowLeft = kc === 37;
                        const isArrowRight = kc === 39;
                        const isArrowUp = kc === 38;
                        const isArrowDown = kc === 40;
                        // Directions locks
                        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
                            return false;
                        }
                        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
                            return false;
                        }
                        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                            return undefined;
                        }
                        if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                            return undefined;
                        }
                        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
                            let inView = false;
                            // Check that swiper should be inside of visible area of window
                            if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
                                return undefined;
                            }
                            const el = swiper.el;
                            const swiperWidth = el.clientWidth;
                            const swiperHeight = el.clientHeight;
                            const windowWidth = window.innerWidth;
                            const windowHeight = window.innerHeight;
                            const swiperOffset = elementOffset(el);
                            if (rtl) swiperOffset.left -= el.scrollLeft;
                            const swiperCoord = [
                                [swiperOffset.left, swiperOffset.top],
                                [swiperOffset.left + swiperWidth, swiperOffset.top],
                                [swiperOffset.left, swiperOffset.top + swiperHeight],
                                [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]
                            ];
                            for (let i = 0; i < swiperCoord.length; i += 1) {
                                const point = swiperCoord[i];
                                if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                                    if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
                                    inView = true;
                                }
                            }
                            if (!inView) return undefined;
                        }
                        if (swiper.isHorizontal()) {
                            if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                                if (e.preventDefault) e.preventDefault();
                                else e.returnValue = false;
                            }
                            if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
                            if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
                        } else {
                            if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                                if (e.preventDefault) e.preventDefault();
                                else e.returnValue = false;
                            }
                            if (isPageDown || isArrowDown) swiper.slideNext();
                            if (isPageUp || isArrowUp) swiper.slidePrev();
                        }
                        emit('keyPress', kc);
                        return undefined;
                    }

                    function enable() {
                        if (swiper.keyboard.enabled) return;
                        document.addEventListener('keydown', handle);
                        swiper.keyboard.enabled = true;
                    }

                    function disable() {
                        if (!swiper.keyboard.enabled) return;
                        document.removeEventListener('keydown', handle);
                        swiper.keyboard.enabled = false;
                    }
                    on('init', () => {
                        if (swiper.params.keyboard.enabled) {
                            enable();
                        }
                    });
                    on('destroy', () => {
                        if (swiper.keyboard.enabled) {
                            disable();
                        }
                    });
                    Object.assign(swiper.keyboard, {
                        enable,
                        disable
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/mousewheel.mjs



                /* eslint-disable consistent-return */
                function Mousewheel(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    const window = getWindow();
                    extendParams({
                        mousewheel: {
                            enabled: false,
                            releaseOnEdges: false,
                            invert: false,
                            forceToAxis: false,
                            sensitivity: 1,
                            eventsTarget: 'container',
                            thresholdDelta: null,
                            thresholdTime: null,
                            noMousewheelClass: 'swiper-no-mousewheel'
                        }
                    });
                    swiper.mousewheel = {
                        enabled: false
                    };
                    let timeout;
                    let lastScrollTime = now();
                    let lastEventBeforeSnap;
                    const recentWheelEvents = [];

                    function normalize(e) {
                        // Reasonable defaults
                        const PIXEL_STEP = 10;
                        const LINE_HEIGHT = 40;
                        const PAGE_HEIGHT = 800;
                        let sX = 0;
                        let sY = 0; // spinX, spinY
                        let pX = 0;
                        let pY = 0; // pixelX, pixelY

                        // Legacy
                        if ('detail' in e) {
                            sY = e.detail;
                        }
                        if ('wheelDelta' in e) {
                            sY = -e.wheelDelta / 120;
                        }
                        if ('wheelDeltaY' in e) {
                            sY = -e.wheelDeltaY / 120;
                        }
                        if ('wheelDeltaX' in e) {
                            sX = -e.wheelDeltaX / 120;
                        }

                        // side scrolling on FF with DOMMouseScroll
                        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
                            sX = sY;
                            sY = 0;
                        }
                        pX = sX * PIXEL_STEP;
                        pY = sY * PIXEL_STEP;
                        if ('deltaY' in e) {
                            pY = e.deltaY;
                        }
                        if ('deltaX' in e) {
                            pX = e.deltaX;
                        }
                        if (e.shiftKey && !pX) {
                            // if user scrolls with shift he wants horizontal scroll
                            pX = pY;
                            pY = 0;
                        }
                        if ((pX || pY) && e.deltaMode) {
                            if (e.deltaMode === 1) {
                                // delta in LINE units
                                pX *= LINE_HEIGHT;
                                pY *= LINE_HEIGHT;
                            } else {
                                // delta in PAGE units
                                pX *= PAGE_HEIGHT;
                                pY *= PAGE_HEIGHT;
                            }
                        }

                        // Fall-back if spin cannot be determined
                        if (pX && !sX) {
                            sX = pX < 1 ? -1 : 1;
                        }
                        if (pY && !sY) {
                            sY = pY < 1 ? -1 : 1;
                        }
                        return {
                            spinX: sX,
                            spinY: sY,
                            pixelX: pX,
                            pixelY: pY
                        };
                    }

                    function handleMouseEnter() {
                        if (!swiper.enabled) return;
                        swiper.mouseEntered = true;
                    }

                    function handleMouseLeave() {
                        if (!swiper.enabled) return;
                        swiper.mouseEntered = false;
                    }

                    function animateSlider(newEvent) {
                        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
                            // Prevent if delta of wheel scroll delta is below configured threshold
                            return false;
                        }
                        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
                            // Prevent if time between scrolls is below configured threshold
                            return false;
                        }

                        // If the movement is NOT big enough and
                        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
                        //   Don't go any further (avoid insignificant scroll movement).
                        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
                            // Return false as a default
                            return true;
                        }
                        // If user is scrolling towards the end:
                        //   If the slider hasn't hit the latest slide or
                        //   if the slider is a loop and
                        //   if the slider isn't moving right now:
                        //     Go to next slide and
                        //     emit a scroll event.
                        // Else (the user is scrolling towards the beginning) and
                        // if the slider hasn't hit the first slide or
                        // if the slider is a loop and
                        // if the slider isn't moving right now:
                        //   Go to prev slide and
                        //   emit a scroll event.
                        if (newEvent.direction < 0) {
                            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                                swiper.slideNext();
                                emit('scroll', newEvent.raw);
                            }
                        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                            swiper.slidePrev();
                            emit('scroll', newEvent.raw);
                        }
                        // If you got here is because an animation has been triggered so store the current time
                        lastScrollTime = new window.Date().getTime();
                        // Return false as a default
                        return false;
                    }

                    function releaseScroll(newEvent) {
                        const params = swiper.params.mousewheel;
                        if (newEvent.direction < 0) {
                            if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                                // Return true to animate scroll on edges
                                return true;
                            }
                        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
                            // Return true to animate scroll on edges
                            return true;
                        }
                        return false;
                    }

                    function handle(event) {
                        let e = event;
                        let disableParentSwiper = true;
                        if (!swiper.enabled) return;

                        // Ignore event if the target or its parents have the swiper-no-mousewheel class
                        if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
                        const params = swiper.params.mousewheel;
                        if (swiper.params.cssMode) {
                            e.preventDefault();
                        }
                        let targetEl = swiper.el;
                        if (swiper.params.mousewheel.eventsTarget !== 'container') {
                            targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
                        }
                        const targetElContainsTarget = targetEl && targetEl.contains(e.target);
                        if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
                        if (e.originalEvent) e = e.originalEvent; // jquery fix
                        let delta = 0;
                        const rtlFactor = swiper.rtlTranslate ? -1 : 1;
                        const data = normalize(e);
                        if (params.forceToAxis) {
                            if (swiper.isHorizontal()) {
                                if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
                                else return true;
                            } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
                            else return true;
                        } else {
                            delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
                        }
                        if (delta === 0) return true;
                        if (params.invert) delta = -delta;

                        // Get the scroll positions
                        let positions = swiper.getTranslate() + delta * params.sensitivity;
                        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
                        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();

                        // When loop is true:
                        //     the disableParentSwiper will be true.
                        // When loop is false:
                        //     if the scroll positions is not on edge,
                        //     then the disableParentSwiper will be true.
                        //     if the scroll on edge positions,
                        //     then the disableParentSwiper will be false.
                        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
                        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
                        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                            // Register the new event in a variable which stores the relevant data
                            const newEvent = {
                                time: now(),
                                delta: Math.abs(delta),
                                direction: Math.sign(delta),
                                raw: event
                            };

                            // Keep the most recent events
                            if (recentWheelEvents.length >= 2) {
                                recentWheelEvents.shift(); // only store the last N events
                            }

                            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                            recentWheelEvents.push(newEvent);

                            // If there is at least one previous recorded event:
                            //   If direction has changed or
                            //   if the scroll is quicker than the previous one:
                            //     Animate the slider.
                            // Else (this is the first time the wheel is moved):
                            //     Animate the slider.
                            if (prevEvent) {
                                if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                                    animateSlider(newEvent);
                                }
                            } else {
                                animateSlider(newEvent);
                            }

                            // If it's time to release the scroll:
                            //   Return now so you don't hit the preventDefault.
                            if (releaseScroll(newEvent)) {
                                return true;
                            }
                        } else {
                            // Freemode or scrollContainer:

                            // If we recently snapped after a momentum scroll, then ignore wheel events
                            // to give time for the deceleration to finish. Stop ignoring after 500 msecs
                            // or if it's a new scroll (larger delta or inverse sign as last event before
                            // an end-of-momentum snap).
                            const newEvent = {
                                time: now(),
                                delta: Math.abs(delta),
                                direction: Math.sign(delta)
                            };
                            const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                            if (!ignoreWheelEvents) {
                                lastEventBeforeSnap = undefined;
                                let position = swiper.getTranslate() + delta * params.sensitivity;
                                const wasBeginning = swiper.isBeginning;
                                const wasEnd = swiper.isEnd;
                                if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                                if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                                swiper.setTransition(0);
                                swiper.setTranslate(position);
                                swiper.updateProgress();
                                swiper.updateActiveIndex();
                                swiper.updateSlidesClasses();
                                if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                                    swiper.updateSlidesClasses();
                                }
                                if (swiper.params.loop) {
                                    swiper.loopFix({
                                        direction: newEvent.direction < 0 ? 'next' : 'prev',
                                        byMousewheel: true
                                    });
                                }
                                if (swiper.params.freeMode.sticky) {
                                    // When wheel scrolling starts with sticky (aka snap) enabled, then detect
                                    // the end of a momentum scroll by storing recent (N=15?) wheel events.
                                    // 1. do all N events have decreasing or same (absolute value) delta?
                                    // 2. did all N events arrive in the last M (M=500?) msecs?
                                    // 3. does the earliest event have an (absolute value) delta that's
                                    //    at least P (P=1?) larger than the most recent event's delta?
                                    // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
                                    // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
                                    // Snap immediately and ignore remaining wheel events in this scroll.
                                    // See comment above for "remaining wheel events in this scroll" determination.
                                    // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
                                    clearTimeout(timeout);
                                    timeout = undefined;
                                    if (recentWheelEvents.length >= 15) {
                                        recentWheelEvents.shift(); // only store the last N events
                                    }

                                    const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                                    const firstEvent = recentWheelEvents[0];
                                    recentWheelEvents.push(newEvent);
                                    if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                                        // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                                        recentWheelEvents.splice(0);
                                    } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                                        // We're at the end of the deceleration of a momentum scroll, so there's no need
                                        // to wait for more events. Snap ASAP on the next tick.
                                        // Also, because there's some remaining momentum we'll bias the snap in the
                                        // direction of the ongoing scroll because it's better UX for the scroll to snap
                                        // in the same direction as the scroll instead of reversing to snap.  Therefore,
                                        // if it's already scrolled more than 20% in the current direction, keep going.
                                        const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                                        lastEventBeforeSnap = newEvent;
                                        recentWheelEvents.splice(0);
                                        timeout = nextTick(() => {
                                            swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                                        }, 0); // no delay; move on next tick
                                    }

                                    if (!timeout) {
                                        // if we get here, then we haven't detected the end of a momentum scroll, so
                                        // we'll consider a scroll "complete" when there haven't been any wheel events
                                        // for 500ms.
                                        timeout = nextTick(() => {
                                            const snapToThreshold = 0.5;
                                            lastEventBeforeSnap = newEvent;
                                            recentWheelEvents.splice(0);
                                            swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                                        }, 500);
                                    }
                                }

                                // Emit event
                                if (!ignoreWheelEvents) emit('scroll', e);

                                // Stop autoplay
                                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                                // Return page scroll on edge positions
                                if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
                                    return true;
                                }
                            }
                        }
                        if (e.preventDefault) e.preventDefault();
                        else e.returnValue = false;
                        return false;
                    }

                    function events(method) {
                        let targetEl = swiper.el;
                        if (swiper.params.mousewheel.eventsTarget !== 'container') {
                            targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
                        }
                        targetEl[method]('mouseenter', handleMouseEnter);
                        targetEl[method]('mouseleave', handleMouseLeave);
                        targetEl[method]('wheel', handle);
                    }

                    function enable() {
                        if (swiper.params.cssMode) {
                            swiper.wrapperEl.removeEventListener('wheel', handle);
                            return true;
                        }
                        if (swiper.mousewheel.enabled) return false;
                        events('addEventListener');
                        swiper.mousewheel.enabled = true;
                        return true;
                    }

                    function disable() {
                        if (swiper.params.cssMode) {
                            swiper.wrapperEl.addEventListener(event, handle);
                            return true;
                        }
                        if (!swiper.mousewheel.enabled) return false;
                        events('removeEventListener');
                        swiper.mousewheel.enabled = false;
                        return true;
                    }
                    on('init', () => {
                        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                            disable();
                        }
                        if (swiper.params.mousewheel.enabled) enable();
                    });
                    on('destroy', () => {
                        if (swiper.params.cssMode) {
                            enable();
                        }
                        if (swiper.mousewheel.enabled) disable();
                    });
                    Object.assign(swiper.mousewheel, {
                        enable,
                        disable
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/create-element-if-not-defined.mjs


                function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
                    if (swiper.params.createElements) {
                        Object.keys(checkProps).forEach(key => {
                            if (!params[key] && params.auto === true) {
                                let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                                if (!element) {
                                    element = utils_createElement('div', checkProps[key]);
                                    element.className = checkProps[key];
                                    swiper.el.append(element);
                                }
                                params[key] = element;
                                originalParams[key] = element;
                            }
                        });
                    }
                    return params;
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/navigation.mjs


                function Navigation(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    extendParams({
                        navigation: {
                            nextEl: null,
                            prevEl: null,
                            hideOnClick: false,
                            disabledClass: 'swiper-button-disabled',
                            hiddenClass: 'swiper-button-hidden',
                            lockClass: 'swiper-button-lock',
                            navigationDisabledClass: 'swiper-navigation-disabled'
                        }
                    });
                    swiper.navigation = {
                        nextEl: null,
                        prevEl: null
                    };
                    const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);

                    function getEl(el) {
                        let res;
                        if (el && typeof el === 'string' && swiper.isElement) {
                            res = swiper.el.querySelector(el);
                            if (res) return res;
                        }
                        if (el) {
                            if (typeof el === 'string') res = [...document.querySelectorAll(el)];
                            if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
                                res = swiper.el.querySelector(el);
                            }
                        }
                        if (el && !res) return el;
                        // if (Array.isArray(res) && res.length === 1) res = res[0];
                        return res;
                    }

                    function toggleEl(el, disabled) {
                        const params = swiper.params.navigation;
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            if (subEl) {
                                subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
                                if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
                                if (swiper.params.watchOverflow && swiper.enabled) {
                                    subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
                                }
                            }
                        });
                    }

                    function update() {
                        // Update Navigation Buttons
                        const {
                            nextEl,
                            prevEl
                        } = swiper.navigation;
                        if (swiper.params.loop) {
                            toggleEl(prevEl, false);
                            toggleEl(nextEl, false);
                            return;
                        }
                        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
                    }

                    function onPrevClick(e) {
                        e.preventDefault();
                        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                        swiper.slidePrev();
                        emit('navigationPrev');
                    }

                    function onNextClick(e) {
                        e.preventDefault();
                        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                        swiper.slideNext();
                        emit('navigationNext');
                    }

                    function init() {
                        const params = swiper.params.navigation;
                        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                            nextEl: 'swiper-button-next',
                            prevEl: 'swiper-button-prev'
                        });
                        if (!(params.nextEl || params.prevEl)) return;
                        let nextEl = getEl(params.nextEl);
                        let prevEl = getEl(params.prevEl);
                        Object.assign(swiper.navigation, {
                            nextEl,
                            prevEl
                        });
                        nextEl = makeElementsArray(nextEl);
                        prevEl = makeElementsArray(prevEl);
                        const initButton = (el, dir) => {
                            if (el) {
                                el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
                            }
                            if (!swiper.enabled && el) {
                                el.classList.add(...params.lockClass.split(' '));
                            }
                        };
                        nextEl.forEach(el => initButton(el, 'next'));
                        prevEl.forEach(el => initButton(el, 'prev'));
                    }

                    function destroy() {
                        let {
                            nextEl,
                            prevEl
                        } = swiper.navigation;
                        nextEl = makeElementsArray(nextEl);
                        prevEl = makeElementsArray(prevEl);
                        const destroyButton = (el, dir) => {
                            el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
                            el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
                        };
                        nextEl.forEach(el => destroyButton(el, 'next'));
                        prevEl.forEach(el => destroyButton(el, 'prev'));
                    }
                    on('init', () => {
                        if (swiper.params.navigation.enabled === false) {
                            // eslint-disable-next-line
                            disable();
                        } else {
                            init();
                            update();
                        }
                    });
                    on('toEdge fromEdge lock unlock', () => {
                        update();
                    });
                    on('destroy', () => {
                        destroy();
                    });
                    on('enable disable', () => {
                        let {
                            nextEl,
                            prevEl
                        } = swiper.navigation;
                        nextEl = makeElementsArray(nextEl);
                        prevEl = makeElementsArray(prevEl);
                        if (swiper.enabled) {
                            update();
                            return;
                        }
                        [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));
                    });
                    on('click', (_s, e) => {
                        let {
                            nextEl,
                            prevEl
                        } = swiper.navigation;
                        nextEl = makeElementsArray(nextEl);
                        prevEl = makeElementsArray(prevEl);
                        const targetEl = e.target;
                        if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
                            if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                            let isHidden;
                            if (nextEl.length) {
                                isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                            } else if (prevEl.length) {
                                isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                            }
                            if (isHidden === true) {
                                emit('navigationShow');
                            } else {
                                emit('navigationHide');
                            }
                            [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
                        }
                    });
                    const enable = () => {
                        swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
                        init();
                        update();
                    };
                    const disable = () => {
                        swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
                        destroy();
                    };
                    Object.assign(swiper.navigation, {
                        enable,
                        disable,
                        update,
                        init,
                        destroy
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/classes-to-selector.mjs
                function classes_to_selector_classesToSelector(classes) {
                    if (classes === void 0) {
                        classes = '';
                    }
                    return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/pagination.mjs




                function Pagination(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    const pfx = 'swiper-pagination';
                    extendParams({
                        pagination: {
                            el: null,
                            bulletElement: 'span',
                            clickable: false,
                            hideOnClick: false,
                            renderBullet: null,
                            renderProgressbar: null,
                            renderFraction: null,
                            renderCustom: null,
                            progressbarOpposite: false,
                            type: 'bullets',
                            // 'bullets' or 'progressbar' or 'fraction' or 'custom'
                            dynamicBullets: false,
                            dynamicMainBullets: 1,
                            formatFractionCurrent: number => number,
                            formatFractionTotal: number => number,
                            bulletClass: `${pfx}-bullet`,
                            bulletActiveClass: `${pfx}-bullet-active`,
                            modifierClass: `${pfx}-`,
                            currentClass: `${pfx}-current`,
                            totalClass: `${pfx}-total`,
                            hiddenClass: `${pfx}-hidden`,
                            progressbarFillClass: `${pfx}-progressbar-fill`,
                            progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                            clickableClass: `${pfx}-clickable`,
                            lockClass: `${pfx}-lock`,
                            horizontalClass: `${pfx}-horizontal`,
                            verticalClass: `${pfx}-vertical`,
                            paginationDisabledClass: `${pfx}-disabled`
                        }
                    });
                    swiper.pagination = {
                        el: null,
                        bullets: []
                    };
                    let bulletSize;
                    let dynamicBulletIndex = 0;
                    const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);

                    function isPaginationDisabled() {
                        return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
                    }

                    function setSideBullets(bulletEl, position) {
                        const {
                            bulletActiveClass
                        } = swiper.params.pagination;
                        if (!bulletEl) return;
                        bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
                        if (bulletEl) {
                            bulletEl.classList.add(`${bulletActiveClass}-${position}`);
                            bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
                            if (bulletEl) {
                                bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
                            }
                        }
                    }

                    function onBulletClick(e) {
                        const bulletEl = e.target.closest(classes_to_selector_classesToSelector(swiper.params.pagination.bulletClass));
                        if (!bulletEl) {
                            return;
                        }
                        e.preventDefault();
                        const index = utils_elementIndex(bulletEl) * swiper.params.slidesPerGroup;
                        if (swiper.params.loop) {
                            if (swiper.realIndex === index) return;
                            const realIndex = swiper.realIndex;
                            const newSlideIndex = swiper.getSlideIndexByData(index);
                            const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);
                            const loopFix = dir => {
                                const indexBeforeLoopFix = swiper.activeIndex;
                                swiper.loopFix({
                                    direction: dir,
                                    activeSlideIndex: newSlideIndex,
                                    slideTo: false
                                });
                                const indexAfterFix = swiper.activeIndex;
                                if (indexBeforeLoopFix === indexAfterFix) {
                                    swiper.slideToLoop(realIndex, 0, false, true);
                                }
                            };
                            if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {
                                loopFix(newSlideIndex > currentSlideIndex ? 'next' : 'prev');
                            } else if (swiper.params.centeredSlides) {
                                const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                                if (newSlideIndex < Math.floor(slidesPerView / 2)) {
                                    loopFix('prev');
                                }
                            }
                            swiper.slideToLoop(index);
                        } else {
                            swiper.slideTo(index);
                        }
                    }

                    function update() {
                        // Render || Update Pagination bullets/items
                        const rtl = swiper.rtl;
                        const params = swiper.params.pagination;
                        if (isPaginationDisabled()) return;
                        let el = swiper.pagination.el;
                        el = makeElementsArray(el);
                        // Current/Total
                        let current;
                        let previousIndex;
                        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                        const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                        if (swiper.params.loop) {
                            previousIndex = swiper.previousRealIndex || 0;
                            current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
                        } else if (typeof swiper.snapIndex !== 'undefined') {
                            current = swiper.snapIndex;
                            previousIndex = swiper.previousSnapIndex;
                        } else {
                            previousIndex = swiper.previousIndex || 0;
                            current = swiper.activeIndex || 0;
                        }
                        // Types
                        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                            const bullets = swiper.pagination.bullets;
                            let firstIndex;
                            let lastIndex;
                            let midIndex;
                            if (params.dynamicBullets) {
                                bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
                                el.forEach(subEl => {
                                    subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                                });
                                if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
                                    dynamicBulletIndex += current - (previousIndex || 0);
                                    if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                                        dynamicBulletIndex = params.dynamicMainBullets - 1;
                                    } else if (dynamicBulletIndex < 0) {
                                        dynamicBulletIndex = 0;
                                    }
                                }
                                firstIndex = Math.max(current - dynamicBulletIndex, 0);
                                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                                midIndex = (lastIndex + firstIndex) / 2;
                            }
                            bullets.forEach(bulletEl => {
                                const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
                                bulletEl.classList.remove(...classesToRemove);
                            });
                            if (el.length > 1) {
                                bullets.forEach(bullet => {
                                    const bulletIndex = utils_elementIndex(bullet);
                                    if (bulletIndex === current) {
                                        bullet.classList.add(...params.bulletActiveClass.split(' '));
                                    } else if (swiper.isElement) {
                                        bullet.setAttribute('part', 'bullet');
                                    }
                                    if (params.dynamicBullets) {
                                        if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                            bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
                                        }
                                        if (bulletIndex === firstIndex) {
                                            setSideBullets(bullet, 'prev');
                                        }
                                        if (bulletIndex === lastIndex) {
                                            setSideBullets(bullet, 'next');
                                        }
                                    }
                                });
                            } else {
                                const bullet = bullets[current];
                                if (bullet) {
                                    bullet.classList.add(...params.bulletActiveClass.split(' '));
                                }
                                if (swiper.isElement) {
                                    bullets.forEach((bulletEl, bulletIndex) => {
                                        bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
                                    });
                                }
                                if (params.dynamicBullets) {
                                    const firstDisplayedBullet = bullets[firstIndex];
                                    const lastDisplayedBullet = bullets[lastIndex];
                                    for (let i = firstIndex; i <= lastIndex; i += 1) {
                                        if (bullets[i]) {
                                            bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
                                        }
                                    }
                                    setSideBullets(firstDisplayedBullet, 'prev');
                                    setSideBullets(lastDisplayedBullet, 'next');
                                }
                            }
                            if (params.dynamicBullets) {
                                const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                                const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                                const offsetProp = rtl ? 'right' : 'left';
                                bullets.forEach(bullet => {
                                    bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
                                });
                            }
                        }
                        el.forEach((subEl, subElIndex) => {
                            if (params.type === 'fraction') {
                                subEl.querySelectorAll(classes_to_selector_classesToSelector(params.currentClass)).forEach(fractionEl => {
                                    fractionEl.textContent = params.formatFractionCurrent(current + 1);
                                });
                                subEl.querySelectorAll(classes_to_selector_classesToSelector(params.totalClass)).forEach(totalEl => {
                                    totalEl.textContent = params.formatFractionTotal(total);
                                });
                            }
                            if (params.type === 'progressbar') {
                                let progressbarDirection;
                                if (params.progressbarOpposite) {
                                    progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                                } else {
                                    progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                                }
                                const scale = (current + 1) / total;
                                let scaleX = 1;
                                let scaleY = 1;
                                if (progressbarDirection === 'horizontal') {
                                    scaleX = scale;
                                } else {
                                    scaleY = scale;
                                }
                                subEl.querySelectorAll(classes_to_selector_classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
                                    progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                                    progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                                });
                            }
                            if (params.type === 'custom' && params.renderCustom) {
                                subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                                if (subElIndex === 0) emit('paginationRender', subEl);
                            } else {
                                if (subElIndex === 0) emit('paginationRender', subEl);
                                emit('paginationUpdate', subEl);
                            }
                            if (swiper.params.watchOverflow && swiper.enabled) {
                                subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
                            }
                        });
                    }

                    function render() {
                        // Render Container
                        const params = swiper.params.pagination;
                        if (isPaginationDisabled()) return;
                        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                        let el = swiper.pagination.el;
                        el = makeElementsArray(el);
                        let paginationHTML = '';
                        if (params.type === 'bullets') {
                            let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                            if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
                                numberOfBullets = slidesLength;
                            }
                            for (let i = 0; i < numberOfBullets; i += 1) {
                                if (params.renderBullet) {
                                    paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                                } else {
                                    // prettier-ignore
                                    paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
                                }
                            }
                        }
                        if (params.type === 'fraction') {
                            if (params.renderFraction) {
                                paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                            } else {
                                paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
                            }
                        }
                        if (params.type === 'progressbar') {
                            if (params.renderProgressbar) {
                                paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                            } else {
                                paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                            }
                        }
                        swiper.pagination.bullets = [];
                        el.forEach(subEl => {
                            if (params.type !== 'custom') {
                                subEl.innerHTML = paginationHTML || '';
                            }
                            if (params.type === 'bullets') {
                                swiper.pagination.bullets.push(...subEl.querySelectorAll(classes_to_selector_classesToSelector(params.bulletClass)));
                            }
                        });
                        if (params.type !== 'custom') {
                            emit('paginationRender', el[0]);
                        }
                    }

                    function init() {
                        swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                            el: 'swiper-pagination'
                        });
                        const params = swiper.params.pagination;
                        if (!params.el) return;
                        let el;
                        if (typeof params.el === 'string' && swiper.isElement) {
                            el = swiper.el.querySelector(params.el);
                        }
                        if (!el && typeof params.el === 'string') {
                            el = [...document.querySelectorAll(params.el)];
                        }
                        if (!el) {
                            el = params.el;
                        }
                        if (!el || el.length === 0) return;
                        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
                            el = [...swiper.el.querySelectorAll(params.el)];
                            // check if it belongs to another nested Swiper
                            if (el.length > 1) {
                                el = el.filter(subEl => {
                                    if (utils_elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
                                    return true;
                                })[0];
                            }
                        }
                        if (Array.isArray(el) && el.length === 1) el = el[0];
                        Object.assign(swiper.pagination, {
                            el
                        });
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            if (params.type === 'bullets' && params.clickable) {
                                subEl.classList.add(...(params.clickableClass || '').split(' '));
                            }
                            subEl.classList.add(params.modifierClass + params.type);
                            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                            if (params.type === 'bullets' && params.dynamicBullets) {
                                subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                                dynamicBulletIndex = 0;
                                if (params.dynamicMainBullets < 1) {
                                    params.dynamicMainBullets = 1;
                                }
                            }
                            if (params.type === 'progressbar' && params.progressbarOpposite) {
                                subEl.classList.add(params.progressbarOppositeClass);
                            }
                            if (params.clickable) {
                                subEl.addEventListener('click', onBulletClick);
                            }
                            if (!swiper.enabled) {
                                subEl.classList.add(params.lockClass);
                            }
                        });
                    }

                    function destroy() {
                        const params = swiper.params.pagination;
                        if (isPaginationDisabled()) return;
                        let el = swiper.pagination.el;
                        if (el) {
                            el = makeElementsArray(el);
                            el.forEach(subEl => {
                                subEl.classList.remove(params.hiddenClass);
                                subEl.classList.remove(params.modifierClass + params.type);
                                subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                                if (params.clickable) {
                                    subEl.classList.remove(...(params.clickableClass || '').split(' '));
                                    subEl.removeEventListener('click', onBulletClick);
                                }
                            });
                        }
                        if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
                    }
                    on('changeDirection', () => {
                        if (!swiper.pagination || !swiper.pagination.el) return;
                        const params = swiper.params.pagination;
                        let {
                            el
                        } = swiper.pagination;
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.classList.remove(params.horizontalClass, params.verticalClass);
                            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        });
                    });
                    on('init', () => {
                        if (swiper.params.pagination.enabled === false) {
                            // eslint-disable-next-line
                            disable();
                        } else {
                            init();
                            render();
                            update();
                        }
                    });
                    on('activeIndexChange', () => {
                        if (typeof swiper.snapIndex === 'undefined') {
                            update();
                        }
                    });
                    on('snapIndexChange', () => {
                        update();
                    });
                    on('snapGridLengthChange', () => {
                        render();
                        update();
                    });
                    on('destroy', () => {
                        destroy();
                    });
                    on('enable disable', () => {
                        let {
                            el
                        } = swiper.pagination;
                        if (el) {
                            el = makeElementsArray(el);
                            el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
                        }
                    });
                    on('lock unlock', () => {
                        update();
                    });
                    on('click', (_s, e) => {
                        const targetEl = e.target;
                        const el = makeElementsArray(swiper.pagination.el);
                        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
                            if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                            const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
                            if (isHidden === true) {
                                emit('paginationShow');
                            } else {
                                emit('paginationHide');
                            }
                            el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
                        }
                    });
                    const enable = () => {
                        swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
                        let {
                            el
                        } = swiper.pagination;
                        if (el) {
                            el = makeElementsArray(el);
                            el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
                        }
                        init();
                        render();
                        update();
                    };
                    const disable = () => {
                        swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
                        let {
                            el
                        } = swiper.pagination;
                        if (el) {
                            el = makeElementsArray(el);
                            el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
                        }
                        destroy();
                    };
                    Object.assign(swiper.pagination, {
                        enable,
                        disable,
                        render,
                        update,
                        init,
                        destroy
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/scrollbar.mjs




                function Scrollbar(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    const document = getDocument();
                    let isTouched = false;
                    let timeout = null;
                    let dragTimeout = null;
                    let dragStartPos;
                    let dragSize;
                    let trackSize;
                    let divider;
                    extendParams({
                        scrollbar: {
                            el: null,
                            dragSize: 'auto',
                            hide: false,
                            draggable: false,
                            snapOnRelease: true,
                            lockClass: 'swiper-scrollbar-lock',
                            dragClass: 'swiper-scrollbar-drag',
                            scrollbarDisabledClass: 'swiper-scrollbar-disabled',
                            horizontalClass: `swiper-scrollbar-horizontal`,
                            verticalClass: `swiper-scrollbar-vertical`
                        }
                    });
                    swiper.scrollbar = {
                        el: null,
                        dragEl: null
                    };

                    function setTranslate() {
                        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                        const {
                            scrollbar,
                            rtlTranslate: rtl
                        } = swiper;
                        const {
                            dragEl,
                            el
                        } = scrollbar;
                        const params = swiper.params.scrollbar;
                        const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
                        let newSize = dragSize;
                        let newPos = (trackSize - dragSize) * progress;
                        if (rtl) {
                            newPos = -newPos;
                            if (newPos > 0) {
                                newSize = dragSize - newPos;
                                newPos = 0;
                            } else if (-newPos + dragSize > trackSize) {
                                newSize = trackSize + newPos;
                            }
                        } else if (newPos < 0) {
                            newSize = dragSize + newPos;
                            newPos = 0;
                        } else if (newPos + dragSize > trackSize) {
                            newSize = trackSize - newPos;
                        }
                        if (swiper.isHorizontal()) {
                            dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
                            dragEl.style.width = `${newSize}px`;
                        } else {
                            dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
                            dragEl.style.height = `${newSize}px`;
                        }
                        if (params.hide) {
                            clearTimeout(timeout);
                            el.style.opacity = 1;
                            timeout = setTimeout(() => {
                                el.style.opacity = 0;
                                el.style.transitionDuration = '400ms';
                            }, 1000);
                        }
                    }

                    function setTransition(duration) {
                        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
                    }

                    function updateSize() {
                        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                        const {
                            scrollbar
                        } = swiper;
                        const {
                            dragEl,
                            el
                        } = scrollbar;
                        dragEl.style.width = '';
                        dragEl.style.height = '';
                        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
                        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
                        if (swiper.params.scrollbar.dragSize === 'auto') {
                            dragSize = trackSize * divider;
                        } else {
                            dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
                        }
                        if (swiper.isHorizontal()) {
                            dragEl.style.width = `${dragSize}px`;
                        } else {
                            dragEl.style.height = `${dragSize}px`;
                        }
                        if (divider >= 1) {
                            el.style.display = 'none';
                        } else {
                            el.style.display = '';
                        }
                        if (swiper.params.scrollbar.hide) {
                            el.style.opacity = 0;
                        }
                        if (swiper.params.watchOverflow && swiper.enabled) {
                            scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
                        }
                    }

                    function getPointerPosition(e) {
                        return swiper.isHorizontal() ? e.clientX : e.clientY;
                    }

                    function setDragPosition(e) {
                        const {
                            scrollbar,
                            rtlTranslate: rtl
                        } = swiper;
                        const {
                            el
                        } = scrollbar;
                        let positionRatio;
                        positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
                        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
                        if (rtl) {
                            positionRatio = 1 - positionRatio;
                        }
                        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
                        swiper.updateProgress(position);
                        swiper.setTranslate(position);
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                    }

                    function onDragStart(e) {
                        const params = swiper.params.scrollbar;
                        const {
                            scrollbar,
                            wrapperEl
                        } = swiper;
                        const {
                            el,
                            dragEl
                        } = scrollbar;
                        isTouched = true;
                        dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
                        e.preventDefault();
                        e.stopPropagation();
                        wrapperEl.style.transitionDuration = '100ms';
                        dragEl.style.transitionDuration = '100ms';
                        setDragPosition(e);
                        clearTimeout(dragTimeout);
                        el.style.transitionDuration = '0ms';
                        if (params.hide) {
                            el.style.opacity = 1;
                        }
                        if (swiper.params.cssMode) {
                            swiper.wrapperEl.style['scroll-snap-type'] = 'none';
                        }
                        emit('scrollbarDragStart', e);
                    }

                    function onDragMove(e) {
                        const {
                            scrollbar,
                            wrapperEl
                        } = swiper;
                        const {
                            el,
                            dragEl
                        } = scrollbar;
                        if (!isTouched) return;
                        if (e.preventDefault) e.preventDefault();
                        else e.returnValue = false;
                        setDragPosition(e);
                        wrapperEl.style.transitionDuration = '0ms';
                        el.style.transitionDuration = '0ms';
                        dragEl.style.transitionDuration = '0ms';
                        emit('scrollbarDragMove', e);
                    }

                    function onDragEnd(e) {
                        const params = swiper.params.scrollbar;
                        const {
                            scrollbar,
                            wrapperEl
                        } = swiper;
                        const {
                            el
                        } = scrollbar;
                        if (!isTouched) return;
                        isTouched = false;
                        if (swiper.params.cssMode) {
                            swiper.wrapperEl.style['scroll-snap-type'] = '';
                            wrapperEl.style.transitionDuration = '';
                        }
                        if (params.hide) {
                            clearTimeout(dragTimeout);
                            dragTimeout = nextTick(() => {
                                el.style.opacity = 0;
                                el.style.transitionDuration = '400ms';
                            }, 1000);
                        }
                        emit('scrollbarDragEnd', e);
                        if (params.snapOnRelease) {
                            swiper.slideToClosest();
                        }
                    }

                    function events(method) {
                        const {
                            scrollbar,
                            params
                        } = swiper;
                        const el = scrollbar.el;
                        if (!el) return;
                        const target = el;
                        const activeListener = params.passiveListeners ? {
                            passive: false,
                            capture: false
                        } : false;
                        const passiveListener = params.passiveListeners ? {
                            passive: true,
                            capture: false
                        } : false;
                        if (!target) return;
                        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
                        target[eventMethod]('pointerdown', onDragStart, activeListener);
                        document[eventMethod]('pointermove', onDragMove, activeListener);
                        document[eventMethod]('pointerup', onDragEnd, passiveListener);
                    }

                    function enableDraggable() {
                        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                        events('on');
                    }

                    function disableDraggable() {
                        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                        events('off');
                    }

                    function init() {
                        const {
                            scrollbar,
                            el: swiperEl
                        } = swiper;
                        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
                            el: 'swiper-scrollbar'
                        });
                        const params = swiper.params.scrollbar;
                        if (!params.el) return;
                        let el;
                        if (typeof params.el === 'string' && swiper.isElement) {
                            el = swiper.el.querySelector(params.el);
                        }
                        if (!el && typeof params.el === 'string') {
                            el = document.querySelectorAll(params.el);
                        } else if (!el) {
                            el = params.el;
                        }
                        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
                            el = swiperEl.querySelector(params.el);
                        }
                        if (el.length > 0) el = el[0];
                        el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        let dragEl;
                        if (el) {
                            dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);
                            if (!dragEl) {
                                dragEl = createElement('div', swiper.params.scrollbar.dragClass);
                                el.append(dragEl);
                            }
                        }
                        Object.assign(scrollbar, {
                            el,
                            dragEl
                        });
                        if (params.draggable) {
                            enableDraggable();
                        }
                        if (el) {
                            el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
                        }
                    }

                    function destroy() {
                        const params = swiper.params.scrollbar;
                        const el = swiper.scrollbar.el;
                        if (el) {
                            el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        }
                        disableDraggable();
                    }
                    on('init', () => {
                        if (swiper.params.scrollbar.enabled === false) {
                            // eslint-disable-next-line
                            disable();
                        } else {
                            init();
                            updateSize();
                            setTranslate();
                        }
                    });
                    on('update resize observerUpdate lock unlock', () => {
                        updateSize();
                    });
                    on('setTranslate', () => {
                        setTranslate();
                    });
                    on('setTransition', (_s, duration) => {
                        setTransition(duration);
                    });
                    on('enable disable', () => {
                        const {
                            el
                        } = swiper.scrollbar;
                        if (el) {
                            el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
                        }
                    });
                    on('destroy', () => {
                        destroy();
                    });
                    const enable = () => {
                        swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
                        if (swiper.scrollbar.el) {
                            swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
                        }
                        init();
                        updateSize();
                        setTranslate();
                    };
                    const disable = () => {
                        swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
                        if (swiper.scrollbar.el) {
                            swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
                        }
                        destroy();
                    };
                    Object.assign(swiper.scrollbar, {
                        enable,
                        disable,
                        updateSize,
                        setTranslate,
                        init,
                        destroy
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/parallax.mjs


                function Parallax(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        parallax: {
                            enabled: false
                        }
                    });
                    const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';
                    const setTransform = (el, progress) => {
                        const {
                            rtl
                        } = swiper;
                        const rtlFactor = rtl ? -1 : 1;
                        const p = el.getAttribute('data-swiper-parallax') || '0';
                        let x = el.getAttribute('data-swiper-parallax-x');
                        let y = el.getAttribute('data-swiper-parallax-y');
                        const scale = el.getAttribute('data-swiper-parallax-scale');
                        const opacity = el.getAttribute('data-swiper-parallax-opacity');
                        const rotate = el.getAttribute('data-swiper-parallax-rotate');
                        if (x || y) {
                            x = x || '0';
                            y = y || '0';
                        } else if (swiper.isHorizontal()) {
                            x = p;
                            y = '0';
                        } else {
                            y = p;
                            x = '0';
                        }
                        if (x.indexOf('%') >= 0) {
                            x = `${parseInt(x, 10) * progress * rtlFactor}%`;
                        } else {
                            x = `${x * progress * rtlFactor}px`;
                        }
                        if (y.indexOf('%') >= 0) {
                            y = `${parseInt(y, 10) * progress}%`;
                        } else {
                            y = `${y * progress}px`;
                        }
                        if (typeof opacity !== 'undefined' && opacity !== null) {
                            const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
                            el.style.opacity = currentOpacity;
                        }
                        let transform = `translate3d(${x}, ${y}, 0px)`;
                        if (typeof scale !== 'undefined' && scale !== null) {
                            const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
                            transform += ` scale(${currentScale})`;
                        }
                        if (rotate && typeof rotate !== 'undefined' && rotate !== null) {
                            const currentRotate = rotate * progress * -1;
                            transform += ` rotate(${currentRotate}deg)`;
                        }
                        el.style.transform = transform;
                    };
                    const setTranslate = () => {
                        const {
                            el,
                            slides,
                            progress,
                            snapGrid,
                            isElement
                        } = swiper;
                        const elements = elementChildren(el, elementsSelector);
                        if (swiper.isElement) {
                            elements.push(...elementChildren(swiper.hostEl, elementsSelector));
                        }
                        elements.forEach(subEl => {
                            setTransform(subEl, progress);
                        });
                        slides.forEach((slideEl, slideIndex) => {
                            let slideProgress = slideEl.progress;
                            if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                                slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
                            }
                            slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                            slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {
                                setTransform(subEl, slideProgress);
                            });
                        });
                    };
                    const setTransition = function(duration) {
                        if (duration === void 0) {
                            duration = swiper.params.speed;
                        }
                        const {
                            el,
                            hostEl
                        } = swiper;
                        const elements = [...el.querySelectorAll(elementsSelector)];
                        if (swiper.isElement) {
                            elements.push(...hostEl.querySelectorAll(elementsSelector));
                        }
                        elements.forEach(parallaxEl => {
                            let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;
                            if (duration === 0) parallaxDuration = 0;
                            parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
                        });
                    };
                    on('beforeInit', () => {
                        if (!swiper.params.parallax.enabled) return;
                        swiper.params.watchSlidesProgress = true;
                        swiper.originalParams.watchSlidesProgress = true;
                    });
                    on('init', () => {
                        if (!swiper.params.parallax.enabled) return;
                        setTranslate();
                    });
                    on('setTranslate', () => {
                        if (!swiper.params.parallax.enabled) return;
                        setTranslate();
                    });
                    on('setTransition', (_swiper, duration) => {
                        if (!swiper.params.parallax.enabled) return;
                        setTransition(duration);
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/zoom.mjs



                function Zoom(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit
                    } = _ref;
                    const window = getWindow();
                    extendParams({
                        zoom: {
                            enabled: false,
                            maxRatio: 3,
                            minRatio: 1,
                            toggle: true,
                            containerClass: 'swiper-zoom-container',
                            zoomedSlideClass: 'swiper-slide-zoomed'
                        }
                    });
                    swiper.zoom = {
                        enabled: false
                    };
                    let currentScale = 1;
                    let isScaling = false;
                    let fakeGestureTouched;
                    let fakeGestureMoved;
                    const evCache = [];
                    const gesture = {
                        originX: 0,
                        originY: 0,
                        slideEl: undefined,
                        slideWidth: undefined,
                        slideHeight: undefined,
                        imageEl: undefined,
                        imageWrapEl: undefined,
                        maxRatio: 3
                    };
                    const image = {
                        isTouched: undefined,
                        isMoved: undefined,
                        currentX: undefined,
                        currentY: undefined,
                        minX: undefined,
                        minY: undefined,
                        maxX: undefined,
                        maxY: undefined,
                        width: undefined,
                        height: undefined,
                        startX: undefined,
                        startY: undefined,
                        touchesStart: {},
                        touchesCurrent: {}
                    };
                    const velocity = {
                        x: undefined,
                        y: undefined,
                        prevPositionX: undefined,
                        prevPositionY: undefined,
                        prevTime: undefined
                    };
                    let scale = 1;
                    Object.defineProperty(swiper.zoom, 'scale', {
                        get() {
                            return scale;
                        },
                        set(value) {
                            if (scale !== value) {
                                const imageEl = gesture.imageEl;
                                const slideEl = gesture.slideEl;
                                emit('zoomChange', value, imageEl, slideEl);
                            }
                            scale = value;
                        }
                    });

                    function getDistanceBetweenTouches() {
                        if (evCache.length < 2) return 1;
                        const x1 = evCache[0].pageX;
                        const y1 = evCache[0].pageY;
                        const x2 = evCache[1].pageX;
                        const y2 = evCache[1].pageY;
                        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                        return distance;
                    }

                    function getScaleOrigin() {
                        if (evCache.length < 2) return {
                            x: null,
                            y: null
                        };
                        const box = gesture.imageEl.getBoundingClientRect();
                        return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];
                    }

                    function getSlideSelector() {
                        return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
                    }

                    function eventWithinSlide(e) {
                        const slideSelector = getSlideSelector();
                        if (e.target.matches(slideSelector)) return true;
                        if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
                        return false;
                    }

                    function eventWithinZoomContainer(e) {
                        const selector = `.${swiper.params.zoom.containerClass}`;
                        if (e.target.matches(selector)) return true;
                        if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
                        return false;
                    }

                    // Events
                    function onGestureStart(e) {
                        if (e.pointerType === 'mouse') {
                            evCache.splice(0, evCache.length);
                        }
                        if (!eventWithinSlide(e)) return;
                        const params = swiper.params.zoom;
                        fakeGestureTouched = false;
                        fakeGestureMoved = false;
                        evCache.push(e);
                        if (evCache.length < 2) {
                            return;
                        }
                        fakeGestureTouched = true;
                        gesture.scaleStart = getDistanceBetweenTouches();
                        if (!gesture.slideEl) {
                            gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
                            if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
                            let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
                            if (imageEl) {
                                imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
                            }
                            gesture.imageEl = imageEl;
                            if (imageEl) {
                                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
                            } else {
                                gesture.imageWrapEl = undefined;
                            }
                            if (!gesture.imageWrapEl) {
                                gesture.imageEl = undefined;
                                return;
                            }
                            gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
                        }
                        if (gesture.imageEl) {
                            const [originX, originY] = getScaleOrigin();
                            gesture.originX = originX;
                            gesture.originY = originY;
                            gesture.imageEl.style.transitionDuration = '0ms';
                        }
                        isScaling = true;
                    }

                    function onGestureChange(e) {
                        if (!eventWithinSlide(e)) return;
                        const params = swiper.params.zoom;
                        const zoom = swiper.zoom;
                        const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
                        if (pointerIndex >= 0) evCache[pointerIndex] = e;
                        if (evCache.length < 2) {
                            return;
                        }
                        fakeGestureMoved = true;
                        gesture.scaleMove = getDistanceBetweenTouches();
                        if (!gesture.imageEl) {
                            return;
                        }
                        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
                        if (zoom.scale > gesture.maxRatio) {
                            zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
                        }
                        if (zoom.scale < params.minRatio) {
                            zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
                        }
                        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
                    }

                    function onGestureEnd(e) {
                        if (!eventWithinSlide(e)) return;
                        if (e.pointerType === 'mouse' && e.type === 'pointerout') return;
                        const params = swiper.params.zoom;
                        const zoom = swiper.zoom;
                        const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
                        if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
                        if (!fakeGestureTouched || !fakeGestureMoved) {
                            return;
                        }
                        fakeGestureTouched = false;
                        fakeGestureMoved = false;
                        if (!gesture.imageEl) return;
                        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
                        gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
                        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
                        currentScale = zoom.scale;
                        isScaling = false;
                        if (zoom.scale > 1 && gesture.slideEl) {
                            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
                        } else if (zoom.scale <= 1 && gesture.slideEl) {
                            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
                        }
                        if (zoom.scale === 1) {
                            gesture.originX = 0;
                            gesture.originY = 0;
                            gesture.slideEl = undefined;
                        }
                    }

                    function onTouchStart(e) {
                        const device = swiper.device;
                        if (!gesture.imageEl) return;
                        if (image.isTouched) return;
                        if (device.android && e.cancelable) e.preventDefault();
                        image.isTouched = true;
                        const event = evCache.length > 0 ? evCache[0] : e;
                        image.touchesStart.x = event.pageX;
                        image.touchesStart.y = event.pageY;
                    }

                    function onTouchMove(e) {
                        if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;
                        const zoom = swiper.zoom;
                        if (!gesture.imageEl) return;
                        if (!image.isTouched || !gesture.slideEl) return;
                        if (!image.isMoved) {
                            image.width = gesture.imageEl.offsetWidth;
                            image.height = gesture.imageEl.offsetHeight;
                            image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;
                            image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;
                            gesture.slideWidth = gesture.slideEl.offsetWidth;
                            gesture.slideHeight = gesture.slideEl.offsetHeight;
                            gesture.imageWrapEl.style.transitionDuration = '0ms';
                        }
                        // Define if we need image drag
                        const scaledWidth = image.width * zoom.scale;
                        const scaledHeight = image.height * zoom.scale;
                        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
                        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
                        image.maxX = -image.minX;
                        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
                        image.maxY = -image.minY;
                        image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
                        image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
                        const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
                        if (touchesDiff > 5) {
                            swiper.allowClick = false;
                        }
                        if (!image.isMoved && !isScaling) {
                            if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                                image.isTouched = false;
                                return;
                            }
                            if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                                image.isTouched = false;
                                return;
                            }
                        }
                        if (e.cancelable) {
                            e.preventDefault();
                        }
                        e.stopPropagation();
                        image.isMoved = true;
                        const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
                        const {
                            originX,
                            originY
                        } = gesture;
                        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
                        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
                        if (image.currentX < image.minX) {
                            image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
                        }
                        if (image.currentX > image.maxX) {
                            image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
                        }
                        if (image.currentY < image.minY) {
                            image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
                        }
                        if (image.currentY > image.maxY) {
                            image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
                        }

                        // Velocity
                        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
                        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
                        if (!velocity.prevTime) velocity.prevTime = Date.now();
                        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
                        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
                        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
                        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
                        velocity.prevPositionX = image.touchesCurrent.x;
                        velocity.prevPositionY = image.touchesCurrent.y;
                        velocity.prevTime = Date.now();
                        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
                    }

                    function onTouchEnd() {
                        const zoom = swiper.zoom;
                        if (!gesture.imageEl) return;
                        if (!image.isTouched || !image.isMoved) {
                            image.isTouched = false;
                            image.isMoved = false;
                            return;
                        }
                        image.isTouched = false;
                        image.isMoved = false;
                        let momentumDurationX = 300;
                        let momentumDurationY = 300;
                        const momentumDistanceX = velocity.x * momentumDurationX;
                        const newPositionX = image.currentX + momentumDistanceX;
                        const momentumDistanceY = velocity.y * momentumDurationY;
                        const newPositionY = image.currentY + momentumDistanceY;

                        // Fix duration
                        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
                        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
                        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
                        image.currentX = newPositionX;
                        image.currentY = newPositionY;
                        // Define if we need image drag
                        const scaledWidth = image.width * zoom.scale;
                        const scaledHeight = image.height * zoom.scale;
                        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
                        image.maxX = -image.minX;
                        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
                        image.maxY = -image.minY;
                        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
                        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
                        gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
                        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
                    }

                    function onTransitionEnd() {
                        const zoom = swiper.zoom;
                        if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
                            if (gesture.imageEl) {
                                gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
                            }
                            if (gesture.imageWrapEl) {
                                gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
                            }
                            gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
                            zoom.scale = 1;
                            currentScale = 1;
                            gesture.slideEl = undefined;
                            gesture.imageEl = undefined;
                            gesture.imageWrapEl = undefined;
                            gesture.originX = 0;
                            gesture.originY = 0;
                        }
                    }

                    function zoomIn(e) {
                        const zoom = swiper.zoom;
                        const params = swiper.params.zoom;
                        if (!gesture.slideEl) {
                            if (e && e.target) {
                                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
                            }
                            if (!gesture.slideEl) {
                                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                                    gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
                                } else {
                                    gesture.slideEl = swiper.slides[swiper.activeIndex];
                                }
                            }
                            let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
                            if (imageEl) {
                                imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
                            }
                            gesture.imageEl = imageEl;
                            if (imageEl) {
                                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
                            } else {
                                gesture.imageWrapEl = undefined;
                            }
                        }
                        if (!gesture.imageEl || !gesture.imageWrapEl) return;
                        if (swiper.params.cssMode) {
                            swiper.wrapperEl.style.overflow = 'hidden';
                            swiper.wrapperEl.style.touchAction = 'none';
                        }
                        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
                        let touchX;
                        let touchY;
                        let offsetX;
                        let offsetY;
                        let diffX;
                        let diffY;
                        let translateX;
                        let translateY;
                        let imageWidth;
                        let imageHeight;
                        let scaledWidth;
                        let scaledHeight;
                        let translateMinX;
                        let translateMinY;
                        let translateMaxX;
                        let translateMaxY;
                        let slideWidth;
                        let slideHeight;
                        if (typeof image.touchesStart.x === 'undefined' && e) {
                            touchX = e.pageX;
                            touchY = e.pageY;
                        } else {
                            touchX = image.touchesStart.x;
                            touchY = image.touchesStart.y;
                        }
                        const forceZoomRatio = typeof e === 'number' ? e : null;
                        if (currentScale === 1 && forceZoomRatio) {
                            touchX = undefined;
                            touchY = undefined;
                        }
                        zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
                        currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
                        if (e && !(currentScale === 1 && forceZoomRatio)) {
                            slideWidth = gesture.slideEl.offsetWidth;
                            slideHeight = gesture.slideEl.offsetHeight;
                            offsetX = elementOffset(gesture.slideEl).left + window.scrollX;
                            offsetY = elementOffset(gesture.slideEl).top + window.scrollY;
                            diffX = offsetX + slideWidth / 2 - touchX;
                            diffY = offsetY + slideHeight / 2 - touchY;
                            imageWidth = gesture.imageEl.offsetWidth;
                            imageHeight = gesture.imageEl.offsetHeight;
                            scaledWidth = imageWidth * zoom.scale;
                            scaledHeight = imageHeight * zoom.scale;
                            translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                            translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                            translateMaxX = -translateMinX;
                            translateMaxY = -translateMinY;
                            translateX = diffX * zoom.scale;
                            translateY = diffY * zoom.scale;
                            if (translateX < translateMinX) {
                                translateX = translateMinX;
                            }
                            if (translateX > translateMaxX) {
                                translateX = translateMaxX;
                            }
                            if (translateY < translateMinY) {
                                translateY = translateMinY;
                            }
                            if (translateY > translateMaxY) {
                                translateY = translateMaxY;
                            }
                        } else {
                            translateX = 0;
                            translateY = 0;
                        }
                        if (forceZoomRatio && zoom.scale === 1) {
                            gesture.originX = 0;
                            gesture.originY = 0;
                        }
                        gesture.imageWrapEl.style.transitionDuration = '300ms';
                        gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
                        gesture.imageEl.style.transitionDuration = '300ms';
                        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
                    }

                    function zoomOut() {
                        const zoom = swiper.zoom;
                        const params = swiper.params.zoom;
                        if (!gesture.slideEl) {
                            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                                gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
                            } else {
                                gesture.slideEl = swiper.slides[swiper.activeIndex];
                            }
                            let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
                            if (imageEl) {
                                imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
                            }
                            gesture.imageEl = imageEl;
                            if (imageEl) {
                                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
                            } else {
                                gesture.imageWrapEl = undefined;
                            }
                        }
                        if (!gesture.imageEl || !gesture.imageWrapEl) return;
                        if (swiper.params.cssMode) {
                            swiper.wrapperEl.style.overflow = '';
                            swiper.wrapperEl.style.touchAction = '';
                        }
                        zoom.scale = 1;
                        currentScale = 1;
                        gesture.imageWrapEl.style.transitionDuration = '300ms';
                        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
                        gesture.imageEl.style.transitionDuration = '300ms';
                        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
                        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
                        gesture.slideEl = undefined;
                        gesture.originX = 0;
                        gesture.originY = 0;
                    }

                    // Toggle Zoom
                    function zoomToggle(e) {
                        const zoom = swiper.zoom;
                        if (zoom.scale && zoom.scale !== 1) {
                            // Zoom Out
                            zoomOut();
                        } else {
                            // Zoom In
                            zoomIn(e);
                        }
                    }

                    function getListeners() {
                        const passiveListener = swiper.params.passiveListeners ? {
                            passive: true,
                            capture: false
                        } : false;
                        const activeListenerWithCapture = swiper.params.passiveListeners ? {
                            passive: false,
                            capture: true
                        } : true;
                        return {
                            passiveListener,
                            activeListenerWithCapture
                        };
                    }

                    // Attach/Detach Events
                    function enable() {
                        const zoom = swiper.zoom;
                        if (zoom.enabled) return;
                        zoom.enabled = true;
                        const {
                            passiveListener,
                            activeListenerWithCapture
                        } = getListeners();

                        // Scale image
                        swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
                        swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
                        ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
                            swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
                        });

                        // Move image
                        swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);
                    }

                    function disable() {
                        const zoom = swiper.zoom;
                        if (!zoom.enabled) return;
                        zoom.enabled = false;
                        const {
                            passiveListener,
                            activeListenerWithCapture
                        } = getListeners();

                        // Scale image
                        swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
                        swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
                        ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
                            swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
                        });

                        // Move image
                        swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);
                    }
                    on('init', () => {
                        if (swiper.params.zoom.enabled) {
                            enable();
                        }
                    });
                    on('destroy', () => {
                        disable();
                    });
                    on('touchStart', (_s, e) => {
                        if (!swiper.zoom.enabled) return;
                        onTouchStart(e);
                    });
                    on('touchEnd', (_s, e) => {
                        if (!swiper.zoom.enabled) return;
                        onTouchEnd();
                    });
                    on('doubleTap', (_s, e) => {
                        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                            zoomToggle(e);
                        }
                    });
                    on('transitionEnd', () => {
                        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                            onTransitionEnd();
                        }
                    });
                    on('slideChange', () => {
                        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                            onTransitionEnd();
                        }
                    });
                    Object.assign(swiper.zoom, {
                        enable,
                        disable,
                        in: zoomIn,
                        out: zoomOut,
                        toggle: zoomToggle
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/controller.mjs


                /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
                function Controller(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        controller: {
                            control: undefined,
                            inverse: false,
                            by: 'slide' // or 'container'
                        }
                    });

                    swiper.controller = {
                        control: undefined
                    };

                    function LinearSpline(x, y) {
                        const binarySearch = function search() {
                            let maxIndex;
                            let minIndex;
                            let guess;
                            return (array, val) => {
                                minIndex = -1;
                                maxIndex = array.length;
                                while (maxIndex - minIndex > 1) {
                                    guess = maxIndex + minIndex >> 1;
                                    if (array[guess] <= val) {
                                        minIndex = guess;
                                    } else {
                                        maxIndex = guess;
                                    }
                                }
                                return maxIndex;
                            };
                        }();
                        this.x = x;
                        this.y = y;
                        this.lastIndex = x.length - 1;
                        // Given an x value (x2), return the expected y2 value:
                        // (x1,y1) is the known point before given value,
                        // (x3,y3) is the known point after given value.
                        let i1;
                        let i3;
                        this.interpolate = function interpolate(x2) {
                            if (!x2) return 0;

                            // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                            i3 = binarySearch(this.x, x2);
                            i1 = i3 - 1;

                            // We have our indexes i1 & i3, so we can calculate already:
                            // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
                            return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
                        };
                        return this;
                    }

                    function getInterpolateFunction(c) {
                        swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
                    }

                    function setTranslate(_t, byController) {
                        const controlled = swiper.controller.control;
                        let multiplier;
                        let controlledTranslate;
                        const Swiper = swiper.constructor;

                        function setControlledTranslate(c) {
                            if (c.destroyed) return;

                            // this will create an Interpolate function based on the snapGrids
                            // x is the Grid of the scrolled scroller and y will be the controlled scroller
                            // it makes sense to create this only once and recall it for the interpolation
                            // the function does a lot of value caching for performance
                            const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                            if (swiper.params.controller.by === 'slide') {
                                getInterpolateFunction(c);
                                // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                                // but it did not work out
                                controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                            }
                            if (!controlledTranslate || swiper.params.controller.by === 'container') {
                                multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                                if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
                                    multiplier = 1;
                                }
                                controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
                            }
                            if (swiper.params.controller.inverse) {
                                controlledTranslate = c.maxTranslate() - controlledTranslate;
                            }
                            c.updateProgress(controlledTranslate);
                            c.setTranslate(controlledTranslate, swiper);
                            c.updateActiveIndex();
                            c.updateSlidesClasses();
                        }
                        if (Array.isArray(controlled)) {
                            for (let i = 0; i < controlled.length; i += 1) {
                                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                                    setControlledTranslate(controlled[i]);
                                }
                            }
                        } else if (controlled instanceof Swiper && byController !== controlled) {
                            setControlledTranslate(controlled);
                        }
                    }

                    function setTransition(duration, byController) {
                        const Swiper = swiper.constructor;
                        const controlled = swiper.controller.control;
                        let i;

                        function setControlledTransition(c) {
                            if (c.destroyed) return;
                            c.setTransition(duration, swiper);
                            if (duration !== 0) {
                                c.transitionStart();
                                if (c.params.autoHeight) {
                                    nextTick(() => {
                                        c.updateAutoHeight();
                                    });
                                }
                                elementTransitionEnd(c.wrapperEl, () => {
                                    if (!controlled) return;
                                    c.transitionEnd();
                                });
                            }
                        }
                        if (Array.isArray(controlled)) {
                            for (i = 0; i < controlled.length; i += 1) {
                                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                                    setControlledTransition(controlled[i]);
                                }
                            }
                        } else if (controlled instanceof Swiper && byController !== controlled) {
                            setControlledTransition(controlled);
                        }
                    }

                    function removeSpline() {
                        if (!swiper.controller.control) return;
                        if (swiper.controller.spline) {
                            swiper.controller.spline = undefined;
                            delete swiper.controller.spline;
                        }
                    }
                    on('beforeInit', () => {
                        if (true && (
                                // eslint-disable-line
                                typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {
                            const controlElement = document.querySelector(swiper.params.controller.control);
                            if (controlElement && controlElement.swiper) {
                                swiper.controller.control = controlElement.swiper;
                            } else if (controlElement) {
                                const onControllerSwiper = e => {
                                    swiper.controller.control = e.detail[0];
                                    swiper.update();
                                    controlElement.removeEventListener('init', onControllerSwiper);
                                };
                                controlElement.addEventListener('init', onControllerSwiper);
                            }
                            return;
                        }
                        swiper.controller.control = swiper.params.controller.control;
                    });
                    on('update', () => {
                        removeSpline();
                    });
                    on('resize', () => {
                        removeSpline();
                    });
                    on('observerUpdate', () => {
                        removeSpline();
                    });
                    on('setTranslate', (_s, translate, byController) => {
                        if (!swiper.controller.control || swiper.controller.control.destroyed) return;
                        swiper.controller.setTranslate(translate, byController);
                    });
                    on('setTransition', (_s, duration, byController) => {
                        if (!swiper.controller.control || swiper.controller.control.destroyed) return;
                        swiper.controller.setTransition(duration, byController);
                    });
                    Object.assign(swiper.controller, {
                        setTranslate,
                        setTransition
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/a11y.mjs



                function A11y(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        a11y: {
                            enabled: true,
                            notificationClass: 'swiper-notification',
                            prevSlideMessage: 'Previous slide',
                            nextSlideMessage: 'Next slide',
                            firstSlideMessage: 'This is the first slide',
                            lastSlideMessage: 'This is the last slide',
                            paginationBulletMessage: 'Go to slide {{index}}',
                            slideLabelMessage: '{{index}} / {{slidesLength}}',
                            containerMessage: null,
                            containerRoleDescriptionMessage: null,
                            itemRoleDescriptionMessage: null,
                            slideRole: 'group',
                            id: null
                        }
                    });
                    swiper.a11y = {
                        clicked: false
                    };
                    let liveRegion = null;

                    function notify(message) {
                        const notification = liveRegion;
                        if (notification.length === 0) return;
                        notification.innerHTML = '';
                        notification.innerHTML = message;
                    }
                    const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);

                    function getRandomNumber(size) {
                        if (size === void 0) {
                            size = 16;
                        }
                        const randomChar = () => Math.round(16 * Math.random()).toString(16);
                        return 'x'.repeat(size).replace(/x/g, randomChar);
                    }

                    function makeElFocusable(el) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('tabIndex', '0');
                        });
                    }

                    function makeElNotFocusable(el) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('tabIndex', '-1');
                        });
                    }

                    function addElRole(el, role) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('role', role);
                        });
                    }

                    function addElRoleDescription(el, description) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('aria-roledescription', description);
                        });
                    }

                    function addElControls(el, controls) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('aria-controls', controls);
                        });
                    }

                    function addElLabel(el, label) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('aria-label', label);
                        });
                    }

                    function addElId(el, id) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('id', id);
                        });
                    }

                    function addElLive(el, live) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('aria-live', live);
                        });
                    }

                    function disableEl(el) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('aria-disabled', true);
                        });
                    }

                    function enableEl(el) {
                        el = makeElementsArray(el);
                        el.forEach(subEl => {
                            subEl.setAttribute('aria-disabled', false);
                        });
                    }

                    function onEnterOrSpaceKey(e) {
                        if (e.keyCode !== 13 && e.keyCode !== 32) return;
                        const params = swiper.params.a11y;
                        const targetEl = e.target;
                        if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
                            if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;
                        }
                        if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {
                            if (!(swiper.isEnd && !swiper.params.loop)) {
                                swiper.slideNext();
                            }
                            if (swiper.isEnd) {
                                notify(params.lastSlideMessage);
                            } else {
                                notify(params.nextSlideMessage);
                            }
                        }
                        if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {
                            if (!(swiper.isBeginning && !swiper.params.loop)) {
                                swiper.slidePrev();
                            }
                            if (swiper.isBeginning) {
                                notify(params.firstSlideMessage);
                            } else {
                                notify(params.prevSlideMessage);
                            }
                        }
                        if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
                            targetEl.click();
                        }
                    }

                    function updateNavigation() {
                        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
                        const {
                            nextEl,
                            prevEl
                        } = swiper.navigation;
                        if (prevEl) {
                            if (swiper.isBeginning) {
                                disableEl(prevEl);
                                makeElNotFocusable(prevEl);
                            } else {
                                enableEl(prevEl);
                                makeElFocusable(prevEl);
                            }
                        }
                        if (nextEl) {
                            if (swiper.isEnd) {
                                disableEl(nextEl);
                                makeElNotFocusable(nextEl);
                            } else {
                                enableEl(nextEl);
                                makeElFocusable(nextEl);
                            }
                        }
                    }

                    function hasPagination() {
                        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
                    }

                    function hasClickablePagination() {
                        return hasPagination() && swiper.params.pagination.clickable;
                    }

                    function updatePagination() {
                        const params = swiper.params.a11y;
                        if (!hasPagination()) return;
                        swiper.pagination.bullets.forEach(bulletEl => {
                            if (swiper.params.pagination.clickable) {
                                makeElFocusable(bulletEl);
                                if (!swiper.params.pagination.renderBullet) {
                                    addElRole(bulletEl, 'button');
                                    addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
                                }
                            }
                            if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
                                bulletEl.setAttribute('aria-current', 'true');
                            } else {
                                bulletEl.removeAttribute('aria-current');
                            }
                        });
                    }
                    const initNavEl = (el, wrapperId, message) => {
                        makeElFocusable(el);
                        if (el.tagName !== 'BUTTON') {
                            addElRole(el, 'button');
                            el.addEventListener('keydown', onEnterOrSpaceKey);
                        }
                        addElLabel(el, message);
                        addElControls(el, wrapperId);
                    };
                    const handlePointerDown = () => {
                        swiper.a11y.clicked = true;
                    };
                    const handlePointerUp = () => {
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                if (!swiper.destroyed) {
                                    swiper.a11y.clicked = false;
                                }
                            });
                        });
                    };
                    const handleFocus = e => {
                        if (swiper.a11y.clicked) return;
                        const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
                        if (!slideEl || !swiper.slides.includes(slideEl)) return;
                        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
                        const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
                        if (isActive || isVisible) return;
                        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
                        if (swiper.isHorizontal()) {
                            swiper.el.scrollLeft = 0;
                        } else {
                            swiper.el.scrollTop = 0;
                        }
                        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
                    };
                    const initSlides = () => {
                        const params = swiper.params.a11y;
                        if (params.itemRoleDescriptionMessage) {
                            addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
                        }
                        if (params.slideRole) {
                            addElRole(swiper.slides, params.slideRole);
                        }
                        const slidesLength = swiper.slides.length;
                        if (params.slideLabelMessage) {
                            swiper.slides.forEach((slideEl, index) => {
                                const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;
                                const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                                addElLabel(slideEl, ariaLabelMessage);
                            });
                        }
                    };
                    const init = () => {
                        const params = swiper.params.a11y;
                        swiper.el.append(liveRegion);

                        // Container
                        const containerEl = swiper.el;
                        if (params.containerRoleDescriptionMessage) {
                            addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
                        }
                        if (params.containerMessage) {
                            addElLabel(containerEl, params.containerMessage);
                        }

                        // Wrapper
                        const wrapperEl = swiper.wrapperEl;
                        const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;
                        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
                        addElId(wrapperEl, wrapperId);
                        addElLive(wrapperEl, live);

                        // Slide
                        initSlides();

                        // Navigation
                        let {
                            nextEl,
                            prevEl
                        } = swiper.navigation ? swiper.navigation : {};
                        nextEl = makeElementsArray(nextEl);
                        prevEl = makeElementsArray(prevEl);
                        if (nextEl) {
                            nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));
                        }
                        if (prevEl) {
                            prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));
                        }

                        // Pagination
                        if (hasClickablePagination()) {
                            const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];
                            paginationEl.forEach(el => {
                                el.addEventListener('keydown', onEnterOrSpaceKey);
                            });
                        }

                        // Tab focus
                        swiper.el.addEventListener('focus', handleFocus, true);
                        swiper.el.addEventListener('pointerdown', handlePointerDown, true);
                        swiper.el.addEventListener('pointerup', handlePointerUp, true);
                    };

                    function destroy() {
                        if (liveRegion) liveRegion.remove();
                        let {
                            nextEl,
                            prevEl
                        } = swiper.navigation ? swiper.navigation : {};
                        nextEl = makeElementsArray(nextEl);
                        prevEl = makeElementsArray(prevEl);
                        if (nextEl) {
                            nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
                        }
                        if (prevEl) {
                            prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
                        }

                        // Pagination
                        if (hasClickablePagination()) {
                            const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];
                            paginationEl.forEach(el => {
                                el.removeEventListener('keydown', onEnterOrSpaceKey);
                            });
                        }

                        // Tab focus
                        swiper.el.removeEventListener('focus', handleFocus, true);
                        swiper.el.removeEventListener('pointerdown', handlePointerDown, true);
                        swiper.el.removeEventListener('pointerup', handlePointerUp, true);
                    }
                    on('beforeInit', () => {
                        liveRegion = createElement('span', swiper.params.a11y.notificationClass);
                        liveRegion.setAttribute('aria-live', 'assertive');
                        liveRegion.setAttribute('aria-atomic', 'true');
                    });
                    on('afterInit', () => {
                        if (!swiper.params.a11y.enabled) return;
                        init();
                    });
                    on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
                        if (!swiper.params.a11y.enabled) return;
                        initSlides();
                    });
                    on('fromEdge toEdge afterInit lock unlock', () => {
                        if (!swiper.params.a11y.enabled) return;
                        updateNavigation();
                    });
                    on('paginationUpdate', () => {
                        if (!swiper.params.a11y.enabled) return;
                        updatePagination();
                    });
                    on('destroy', () => {
                        if (!swiper.params.a11y.enabled) return;
                        destroy();
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/history.mjs


                function History(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        history: {
                            enabled: false,
                            root: '',
                            replaceState: false,
                            key: 'slides',
                            keepQuery: false
                        }
                    });
                    let initialized = false;
                    let paths = {};
                    const slugify = text => {
                        return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
                    };
                    const getPathValues = urlOverride => {
                        const window = getWindow();
                        let location;
                        if (urlOverride) {
                            location = new URL(urlOverride);
                        } else {
                            location = window.location;
                        }
                        const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
                        const total = pathArray.length;
                        const key = pathArray[total - 2];
                        const value = pathArray[total - 1];
                        return {
                            key,
                            value
                        };
                    };
                    const setHistory = (key, index) => {
                        const window = getWindow();
                        if (!initialized || !swiper.params.history.enabled) return;
                        let location;
                        if (swiper.params.url) {
                            location = new URL(swiper.params.url);
                        } else {
                            location = window.location;
                        }
                        const slide = swiper.slides[index];
                        let value = slugify(slide.getAttribute('data-history'));
                        if (swiper.params.history.root.length > 0) {
                            let root = swiper.params.history.root;
                            if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
                            value = `${root}/${key ? `${key}/` : ''}${value}`;
                        } else if (!location.pathname.includes(key)) {
                            value = `${key ? `${key}/` : ''}${value}`;
                        }
                        if (swiper.params.history.keepQuery) {
                            value += location.search;
                        }
                        const currentState = window.history.state;
                        if (currentState && currentState.value === value) {
                            return;
                        }
                        if (swiper.params.history.replaceState) {
                            window.history.replaceState({
                                value
                            }, null, value);
                        } else {
                            window.history.pushState({
                                value
                            }, null, value);
                        }
                    };
                    const scrollToSlide = (speed, value, runCallbacks) => {
                        if (value) {
                            for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                                const slide = swiper.slides[i];
                                const slideHistory = slugify(slide.getAttribute('data-history'));
                                if (slideHistory === value) {
                                    const index = swiper.getSlideIndex(slide);
                                    swiper.slideTo(index, speed, runCallbacks);
                                }
                            }
                        } else {
                            swiper.slideTo(0, speed, runCallbacks);
                        }
                    };
                    const setHistoryPopState = () => {
                        paths = getPathValues(swiper.params.url);
                        scrollToSlide(swiper.params.speed, paths.value, false);
                    };
                    const init = () => {
                        const window = getWindow();
                        if (!swiper.params.history) return;
                        if (!window.history || !window.history.pushState) {
                            swiper.params.history.enabled = false;
                            swiper.params.hashNavigation.enabled = true;
                            return;
                        }
                        initialized = true;
                        paths = getPathValues(swiper.params.url);
                        if (!paths.key && !paths.value) {
                            if (!swiper.params.history.replaceState) {
                                window.addEventListener('popstate', setHistoryPopState);
                            }
                            return;
                        }
                        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
                        if (!swiper.params.history.replaceState) {
                            window.addEventListener('popstate', setHistoryPopState);
                        }
                    };
                    const destroy = () => {
                        const window = getWindow();
                        if (!swiper.params.history.replaceState) {
                            window.removeEventListener('popstate', setHistoryPopState);
                        }
                    };
                    on('init', () => {
                        if (swiper.params.history.enabled) {
                            init();
                        }
                    });
                    on('destroy', () => {
                        if (swiper.params.history.enabled) {
                            destroy();
                        }
                    });
                    on('transitionEnd _freeModeNoMomentumRelease', () => {
                        if (initialized) {
                            setHistory(swiper.params.history.key, swiper.activeIndex);
                        }
                    });
                    on('slideChange', () => {
                        if (initialized && swiper.params.cssMode) {
                            setHistory(swiper.params.history.key, swiper.activeIndex);
                        }
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/hash-navigation.mjs



                function HashNavigation(_ref) {
                    let {
                        swiper,
                        extendParams,
                        emit,
                        on
                    } = _ref;
                    let initialized = false;
                    const document = getDocument();
                    const window = getWindow();
                    extendParams({
                        hashNavigation: {
                            enabled: false,
                            replaceState: false,
                            watchState: false,
                            getSlideIndex(_s, hash) {
                                if (swiper.virtual && swiper.params.virtual.enabled) {
                                    const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];
                                    if (!slideWithHash) return 0;
                                    const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);
                                    return index;
                                }
                                return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
                            }
                        }
                    });
                    const onHashChange = () => {
                        emit('hashChange');
                        const newHash = document.location.hash.replace('#', '');
                        const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
                        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';
                        if (newHash !== activeSlideHash) {
                            const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
                            if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;
                            swiper.slideTo(newIndex);
                        }
                    };
                    const setHash = () => {
                        if (!initialized || !swiper.params.hashNavigation.enabled) return;
                        const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
                        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';
                        if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
                            window.history.replaceState(null, null, `#${activeSlideHash}` || '');
                            emit('hashSet');
                        } else {
                            document.location.hash = activeSlideHash || '';
                            emit('hashSet');
                        }
                    };
                    const init = () => {
                        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
                        initialized = true;
                        const hash = document.location.hash.replace('#', '');
                        if (hash) {
                            const speed = 0;
                            const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
                            swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
                        }
                        if (swiper.params.hashNavigation.watchState) {
                            window.addEventListener('hashchange', onHashChange);
                        }
                    };
                    const destroy = () => {
                        if (swiper.params.hashNavigation.watchState) {
                            window.removeEventListener('hashchange', onHashChange);
                        }
                    };
                    on('init', () => {
                        if (swiper.params.hashNavigation.enabled) {
                            init();
                        }
                    });
                    on('destroy', () => {
                        if (swiper.params.hashNavigation.enabled) {
                            destroy();
                        }
                    });
                    on('transitionEnd _freeModeNoMomentumRelease', () => {
                        if (initialized) {
                            setHash();
                        }
                    });
                    on('slideChange', () => {
                        if (initialized && swiper.params.cssMode) {
                            setHash();
                        }
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/autoplay.mjs


                /* eslint no-underscore-dangle: "off" */
                /* eslint no-use-before-define: "off" */
                function Autoplay(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on,
                        emit,
                        params
                    } = _ref;
                    swiper.autoplay = {
                        running: false,
                        paused: false,
                        timeLeft: 0
                    };
                    extendParams({
                        autoplay: {
                            enabled: false,
                            delay: 3000,
                            waitForTransition: true,
                            disableOnInteraction: true,
                            stopOnLastSlide: false,
                            reverseDirection: false,
                            pauseOnMouseEnter: false
                        }
                    });
                    let timeout;
                    let raf;
                    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
                    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
                    let autoplayTimeLeft;
                    let autoplayStartTime = new Date().getTime;
                    let wasPaused;
                    let isTouched;
                    let pausedByTouch;
                    let touchStartTimeout;
                    let slideChanged;
                    let pausedByInteraction;

                    function onTransitionEnd(e) {
                        if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
                        if (e.target !== swiper.wrapperEl) return;
                        swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
                        resume();
                    }
                    const calcTimeLeft = () => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        if (swiper.autoplay.paused) {
                            wasPaused = true;
                        } else if (wasPaused) {
                            autoplayDelayCurrent = autoplayTimeLeft;
                            wasPaused = false;
                        }
                        const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
                        swiper.autoplay.timeLeft = timeLeft;
                        emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
                        raf = requestAnimationFrame(() => {
                            calcTimeLeft();
                        });
                    };
                    const getSlideDelay = () => {
                        let activeSlideEl;
                        if (swiper.virtual && swiper.params.virtual.enabled) {
                            activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];
                        } else {
                            activeSlideEl = swiper.slides[swiper.activeIndex];
                        }
                        if (!activeSlideEl) return undefined;
                        const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
                        return currentSlideDelay;
                    };
                    const run = delayForce => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        cancelAnimationFrame(raf);
                        calcTimeLeft();
                        let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
                        autoplayDelayTotal = swiper.params.autoplay.delay;
                        autoplayDelayCurrent = swiper.params.autoplay.delay;
                        const currentSlideDelay = getSlideDelay();
                        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
                            delay = currentSlideDelay;
                            autoplayDelayTotal = currentSlideDelay;
                            autoplayDelayCurrent = currentSlideDelay;
                        }
                        autoplayTimeLeft = delay;
                        const speed = swiper.params.speed;
                        const proceed = () => {
                            if (!swiper || swiper.destroyed) return;
                            if (swiper.params.autoplay.reverseDirection) {
                                if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                                    swiper.slidePrev(speed, true, true);
                                    emit('autoplay');
                                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                                    swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                                    emit('autoplay');
                                }
                            } else {
                                if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                                    swiper.slideNext(speed, true, true);
                                    emit('autoplay');
                                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                                    swiper.slideTo(0, speed, true, true);
                                    emit('autoplay');
                                }
                            }
                            if (swiper.params.cssMode) {
                                autoplayStartTime = new Date().getTime();
                                requestAnimationFrame(() => {
                                    run();
                                });
                            }
                        };
                        if (delay > 0) {
                            clearTimeout(timeout);
                            timeout = setTimeout(() => {
                                proceed();
                            }, delay);
                        } else {
                            requestAnimationFrame(() => {
                                proceed();
                            });
                        }

                        // eslint-disable-next-line
                        return delay;
                    };
                    const start = () => {
                        swiper.autoplay.running = true;
                        run();
                        emit('autoplayStart');
                    };
                    const stop = () => {
                        swiper.autoplay.running = false;
                        clearTimeout(timeout);
                        cancelAnimationFrame(raf);
                        emit('autoplayStop');
                    };
                    const pause = (internal, reset) => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        clearTimeout(timeout);
                        if (!internal) {
                            pausedByInteraction = true;
                        }
                        const proceed = () => {
                            emit('autoplayPause');
                            if (swiper.params.autoplay.waitForTransition) {
                                swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
                            } else {
                                resume();
                            }
                        };
                        swiper.autoplay.paused = true;
                        if (reset) {
                            if (slideChanged) {
                                autoplayTimeLeft = swiper.params.autoplay.delay;
                            }
                            slideChanged = false;
                            proceed();
                            return;
                        }
                        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
                        autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
                        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
                        if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
                        proceed();
                    };
                    const resume = () => {
                        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
                        autoplayStartTime = new Date().getTime();
                        if (pausedByInteraction) {
                            pausedByInteraction = false;
                            run(autoplayTimeLeft);
                        } else {
                            run();
                        }
                        swiper.autoplay.paused = false;
                        emit('autoplayResume');
                    };
                    const onVisibilityChange = () => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        const document = getDocument();
                        if (document.visibilityState === 'hidden') {
                            pausedByInteraction = true;
                            pause(true);
                        }
                        if (document.visibilityState === 'visible') {
                            resume();
                        }
                    };
                    const onPointerEnter = e => {
                        if (e.pointerType !== 'mouse') return;
                        pausedByInteraction = true;
                        if (swiper.animating || swiper.autoplay.paused) return;
                        pause(true);
                    };
                    const onPointerLeave = e => {
                        if (e.pointerType !== 'mouse') return;
                        if (swiper.autoplay.paused) {
                            resume();
                        }
                    };
                    const attachMouseEvents = () => {
                        if (swiper.params.autoplay.pauseOnMouseEnter) {
                            swiper.el.addEventListener('pointerenter', onPointerEnter);
                            swiper.el.addEventListener('pointerleave', onPointerLeave);
                        }
                    };
                    const detachMouseEvents = () => {
                        swiper.el.removeEventListener('pointerenter', onPointerEnter);
                        swiper.el.removeEventListener('pointerleave', onPointerLeave);
                    };
                    const attachDocumentEvents = () => {
                        const document = getDocument();
                        document.addEventListener('visibilitychange', onVisibilityChange);
                    };
                    const detachDocumentEvents = () => {
                        const document = getDocument();
                        document.removeEventListener('visibilitychange', onVisibilityChange);
                    };
                    on('init', () => {
                        if (swiper.params.autoplay.enabled) {
                            attachMouseEvents();
                            attachDocumentEvents();
                            autoplayStartTime = new Date().getTime();
                            start();
                        }
                    });
                    on('destroy', () => {
                        detachMouseEvents();
                        detachDocumentEvents();
                        if (swiper.autoplay.running) {
                            stop();
                        }
                    });
                    on('beforeTransitionStart', (_s, speed, internal) => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        if (internal || !swiper.params.autoplay.disableOnInteraction) {
                            pause(true, true);
                        } else {
                            stop();
                        }
                    });
                    on('sliderFirstMove', () => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        if (swiper.params.autoplay.disableOnInteraction) {
                            stop();
                            return;
                        }
                        isTouched = true;
                        pausedByTouch = false;
                        pausedByInteraction = false;
                        touchStartTimeout = setTimeout(() => {
                            pausedByInteraction = true;
                            pausedByTouch = true;
                            pause(true);
                        }, 200);
                    });
                    on('touchEnd', () => {
                        if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
                        clearTimeout(touchStartTimeout);
                        clearTimeout(timeout);
                        if (swiper.params.autoplay.disableOnInteraction) {
                            pausedByTouch = false;
                            isTouched = false;
                            return;
                        }
                        if (pausedByTouch && swiper.params.cssMode) resume();
                        pausedByTouch = false;
                        isTouched = false;
                    });
                    on('slideChange', () => {
                        if (swiper.destroyed || !swiper.autoplay.running) return;
                        slideChanged = true;
                    });
                    Object.assign(swiper.autoplay, {
                        start,
                        stop,
                        pause,
                        resume
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/thumbs.mjs



                function Thumb(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        thumbs: {
                            swiper: null,
                            multipleActiveThumbs: true,
                            autoScrollOffset: 0,
                            slideThumbActiveClass: 'swiper-slide-thumb-active',
                            thumbsContainerClass: 'swiper-thumbs'
                        }
                    });
                    let initialized = false;
                    let swiperCreated = false;
                    swiper.thumbs = {
                        swiper: null
                    };

                    function onThumbClick() {
                        const thumbsSwiper = swiper.thumbs.swiper;
                        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                        const clickedIndex = thumbsSwiper.clickedIndex;
                        const clickedSlide = thumbsSwiper.clickedSlide;
                        if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
                        if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
                        let slideToIndex;
                        if (thumbsSwiper.params.loop) {
                            slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
                        } else {
                            slideToIndex = clickedIndex;
                        }
                        if (swiper.params.loop) {
                            swiper.slideToLoop(slideToIndex);
                        } else {
                            swiper.slideTo(slideToIndex);
                        }
                    }

                    function init() {
                        const {
                            thumbs: thumbsParams
                        } = swiper.params;
                        if (initialized) return false;
                        initialized = true;
                        const SwiperClass = swiper.constructor;
                        if (thumbsParams.swiper instanceof SwiperClass) {
                            swiper.thumbs.swiper = thumbsParams.swiper;
                            Object.assign(swiper.thumbs.swiper.originalParams, {
                                watchSlidesProgress: true,
                                slideToClickedSlide: false
                            });
                            Object.assign(swiper.thumbs.swiper.params, {
                                watchSlidesProgress: true,
                                slideToClickedSlide: false
                            });
                            swiper.thumbs.swiper.update();
                        } else if (isObject(thumbsParams.swiper)) {
                            const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                            Object.assign(thumbsSwiperParams, {
                                watchSlidesProgress: true,
                                slideToClickedSlide: false
                            });
                            swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                            swiperCreated = true;
                        }
                        swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
                        swiper.thumbs.swiper.on('tap', onThumbClick);
                        return true;
                    }

                    function update(initial) {
                        const thumbsSwiper = swiper.thumbs.swiper;
                        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                        const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

                        // Activate thumbs
                        let thumbsToActivate = 1;
                        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
                        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
                            thumbsToActivate = swiper.params.slidesPerView;
                        }
                        if (!swiper.params.thumbs.multipleActiveThumbs) {
                            thumbsToActivate = 1;
                        }
                        thumbsToActivate = Math.floor(thumbsToActivate);
                        thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
                        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
                            for (let i = 0; i < thumbsToActivate; i += 1) {
                                elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach(slideEl => {
                                    slideEl.classList.add(thumbActiveClass);
                                });
                            }
                        } else {
                            for (let i = 0; i < thumbsToActivate; i += 1) {
                                if (thumbsSwiper.slides[swiper.realIndex + i]) {
                                    thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
                                }
                            }
                        }
                        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
                        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
                        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                            const currentThumbsIndex = thumbsSwiper.activeIndex;
                            let newThumbsIndex;
                            let direction;
                            if (thumbsSwiper.params.loop) {
                                const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];
                                newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                                direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
                            } else {
                                newThumbsIndex = swiper.realIndex;
                                direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
                            }
                            if (useOffset) {
                                newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
                            }
                            if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                                if (thumbsSwiper.params.centeredSlides) {
                                    if (newThumbsIndex > currentThumbsIndex) {
                                        newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                                    } else {
                                        newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                                    }
                                } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);
                                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                            }
                        }
                    }
                    on('beforeInit', () => {
                        const {
                            thumbs
                        } = swiper.params;
                        if (!thumbs || !thumbs.swiper) return;
                        if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {
                            const document = getDocument();
                            const getThumbsElementAndInit = () => {
                                const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;
                                if (thumbsElement && thumbsElement.swiper) {
                                    thumbs.swiper = thumbsElement.swiper;
                                    init();
                                    update(true);
                                } else if (thumbsElement) {
                                    const onThumbsSwiper = e => {
                                        thumbs.swiper = e.detail[0];
                                        thumbsElement.removeEventListener('init', onThumbsSwiper);
                                        init();
                                        update(true);
                                        thumbs.swiper.update();
                                        swiper.update();
                                    };
                                    thumbsElement.addEventListener('init', onThumbsSwiper);
                                }
                                return thumbsElement;
                            };
                            const watchForThumbsToAppear = () => {
                                if (swiper.destroyed) return;
                                const thumbsElement = getThumbsElementAndInit();
                                if (!thumbsElement) {
                                    requestAnimationFrame(watchForThumbsToAppear);
                                }
                            };
                            requestAnimationFrame(watchForThumbsToAppear);
                        } else {
                            init();
                            update(true);
                        }
                    });
                    on('slideChange update resize observerUpdate', () => {
                        update();
                    });
                    on('setTransition', (_s, duration) => {
                        const thumbsSwiper = swiper.thumbs.swiper;
                        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                        thumbsSwiper.setTransition(duration);
                    });
                    on('beforeDestroy', () => {
                        const thumbsSwiper = swiper.thumbs.swiper;
                        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                        if (swiperCreated) {
                            thumbsSwiper.destroy();
                        }
                    });
                    Object.assign(swiper.thumbs, {
                        init,
                        update
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/free-mode.mjs


                function freeMode(_ref) {
                    let {
                        swiper,
                        extendParams,
                        emit,
                        once
                    } = _ref;
                    extendParams({
                        freeMode: {
                            enabled: false,
                            momentum: true,
                            momentumRatio: 1,
                            momentumBounce: true,
                            momentumBounceRatio: 1,
                            momentumVelocityRatio: 1,
                            sticky: false,
                            minimumVelocity: 0.02
                        }
                    });

                    function onTouchStart() {
                        if (swiper.params.cssMode) return;
                        const translate = swiper.getTranslate();
                        swiper.setTranslate(translate);
                        swiper.setTransition(0);
                        swiper.touchEventsData.velocities.length = 0;
                        swiper.freeMode.onTouchEnd({
                            currentPos: swiper.rtl ? swiper.translate : -swiper.translate
                        });
                    }

                    function onTouchMove() {
                        if (swiper.params.cssMode) return;
                        const {
                            touchEventsData: data,
                            touches
                        } = swiper;
                        // Velocity
                        if (data.velocities.length === 0) {
                            data.velocities.push({
                                position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                                time: data.touchStartTime
                            });
                        }
                        data.velocities.push({
                            position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
                            time: now()
                        });
                    }

                    function onTouchEnd(_ref2) {
                        let {
                            currentPos
                        } = _ref2;
                        if (swiper.params.cssMode) return;
                        const {
                            params,
                            wrapperEl,
                            rtlTranslate: rtl,
                            snapGrid,
                            touchEventsData: data
                        } = swiper;
                        // Time diff
                        const touchEndTime = now();
                        const timeDiff = touchEndTime - data.touchStartTime;
                        if (currentPos < -swiper.minTranslate()) {
                            swiper.slideTo(swiper.activeIndex);
                            return;
                        }
                        if (currentPos > -swiper.maxTranslate()) {
                            if (swiper.slides.length < snapGrid.length) {
                                swiper.slideTo(snapGrid.length - 1);
                            } else {
                                swiper.slideTo(swiper.slides.length - 1);
                            }
                            return;
                        }
                        if (params.freeMode.momentum) {
                            if (data.velocities.length > 1) {
                                const lastMoveEvent = data.velocities.pop();
                                const velocityEvent = data.velocities.pop();
                                const distance = lastMoveEvent.position - velocityEvent.position;
                                const time = lastMoveEvent.time - velocityEvent.time;
                                swiper.velocity = distance / time;
                                swiper.velocity /= 2;
                                if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                                    swiper.velocity = 0;
                                }
                                // this implies that the user stopped moving a finger then released.
                                // There would be no events with distance zero, so the last event is stale.
                                if (time > 150 || now() - lastMoveEvent.time > 300) {
                                    swiper.velocity = 0;
                                }
                            } else {
                                swiper.velocity = 0;
                            }
                            swiper.velocity *= params.freeMode.momentumVelocityRatio;
                            data.velocities.length = 0;
                            let momentumDuration = 1000 * params.freeMode.momentumRatio;
                            const momentumDistance = swiper.velocity * momentumDuration;
                            let newPosition = swiper.translate + momentumDistance;
                            if (rtl) newPosition = -newPosition;
                            let doBounce = false;
                            let afterBouncePosition;
                            const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
                            let needsLoopFix;
                            if (newPosition < swiper.maxTranslate()) {
                                if (params.freeMode.momentumBounce) {
                                    if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                                        newPosition = swiper.maxTranslate() - bounceAmount;
                                    }
                                    afterBouncePosition = swiper.maxTranslate();
                                    doBounce = true;
                                    data.allowMomentumBounce = true;
                                } else {
                                    newPosition = swiper.maxTranslate();
                                }
                                if (params.loop && params.centeredSlides) needsLoopFix = true;
                            } else if (newPosition > swiper.minTranslate()) {
                                if (params.freeMode.momentumBounce) {
                                    if (newPosition - swiper.minTranslate() > bounceAmount) {
                                        newPosition = swiper.minTranslate() + bounceAmount;
                                    }
                                    afterBouncePosition = swiper.minTranslate();
                                    doBounce = true;
                                    data.allowMomentumBounce = true;
                                } else {
                                    newPosition = swiper.minTranslate();
                                }
                                if (params.loop && params.centeredSlides) needsLoopFix = true;
                            } else if (params.freeMode.sticky) {
                                let nextSlide;
                                for (let j = 0; j < snapGrid.length; j += 1) {
                                    if (snapGrid[j] > -newPosition) {
                                        nextSlide = j;
                                        break;
                                    }
                                }
                                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                                    newPosition = snapGrid[nextSlide];
                                } else {
                                    newPosition = snapGrid[nextSlide - 1];
                                }
                                newPosition = -newPosition;
                            }
                            if (needsLoopFix) {
                                once('transitionEnd', () => {
                                    swiper.loopFix();
                                });
                            }
                            // Fix duration
                            if (swiper.velocity !== 0) {
                                if (rtl) {
                                    momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                                } else {
                                    momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                                }
                                if (params.freeMode.sticky) {
                                    // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
                                    // event, then durations can be 20+ seconds to slide one (or zero!) slides.
                                    // It's easy to see this when simulating touch with mouse events. To fix this,
                                    // limit single-slide swipes to the default slide duration. This also has the
                                    // nice side effect of matching slide speed if the user stopped moving before
                                    // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
                                    // For faster swipes, also apply limits (albeit higher ones).
                                    const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                                    const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                                    if (moveDistance < currentSlideSize) {
                                        momentumDuration = params.speed;
                                    } else if (moveDistance < 2 * currentSlideSize) {
                                        momentumDuration = params.speed * 1.5;
                                    } else {
                                        momentumDuration = params.speed * 2.5;
                                    }
                                }
                            } else if (params.freeMode.sticky) {
                                swiper.slideToClosest();
                                return;
                            }
                            if (params.freeMode.momentumBounce && doBounce) {
                                swiper.updateProgress(afterBouncePosition);
                                swiper.setTransition(momentumDuration);
                                swiper.setTranslate(newPosition);
                                swiper.transitionStart(true, swiper.swipeDirection);
                                swiper.animating = true;
                                elementTransitionEnd(wrapperEl, () => {
                                    if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                                    emit('momentumBounce');
                                    swiper.setTransition(params.speed);
                                    setTimeout(() => {
                                        swiper.setTranslate(afterBouncePosition);
                                        elementTransitionEnd(wrapperEl, () => {
                                            if (!swiper || swiper.destroyed) return;
                                            swiper.transitionEnd();
                                        });
                                    }, 0);
                                });
                            } else if (swiper.velocity) {
                                emit('_freeModeNoMomentumRelease');
                                swiper.updateProgress(newPosition);
                                swiper.setTransition(momentumDuration);
                                swiper.setTranslate(newPosition);
                                swiper.transitionStart(true, swiper.swipeDirection);
                                if (!swiper.animating) {
                                    swiper.animating = true;
                                    elementTransitionEnd(wrapperEl, () => {
                                        if (!swiper || swiper.destroyed) return;
                                        swiper.transitionEnd();
                                    });
                                }
                            } else {
                                swiper.updateProgress(newPosition);
                            }
                            swiper.updateActiveIndex();
                            swiper.updateSlidesClasses();
                        } else if (params.freeMode.sticky) {
                            swiper.slideToClosest();
                            return;
                        } else if (params.freeMode) {
                            emit('_freeModeNoMomentumRelease');
                        }
                        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                            swiper.updateProgress();
                            swiper.updateActiveIndex();
                            swiper.updateSlidesClasses();
                        }
                    }
                    Object.assign(swiper, {
                        freeMode: {
                            onTouchStart,
                            onTouchMove,
                            onTouchEnd
                        }
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/effect-target.mjs


                function effect_target_effectTarget(effectParams, slideEl) {
                    const transformEl = getSlideTransformEl(slideEl);
                    if (transformEl !== slideEl) {
                        transformEl.style.backfaceVisibility = 'hidden';
                        transformEl.style['-webkit-backface-visibility'] = 'hidden';
                    }
                    return transformEl;
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/effect-virtual-transition-end.mjs


                function effect_virtual_transition_end_effectVirtualTransitionEnd(_ref) {
                    let {
                        swiper,
                        duration,
                        transformElements,
                        allSlides
                    } = _ref;
                    const {
                        activeIndex
                    } = swiper;
                    const getSlide = el => {
                        if (!el.parentElement) {
                            // assume shadow root
                            const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
                            return slide;
                        }
                        return el.parentElement;
                    };
                    if (swiper.params.virtualTranslate && duration !== 0) {
                        let eventTriggered = false;
                        let transitionEndTarget;
                        if (allSlides) {
                            transitionEndTarget = transformElements;
                        } else {
                            transitionEndTarget = transformElements.filter(transformEl => {
                                const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
                                return swiper.getSlideIndex(el) === activeIndex;
                            });
                        }
                        transitionEndTarget.forEach(el => {
                            elementTransitionEnd(el, () => {
                                if (eventTriggered) return;
                                if (!swiper || swiper.destroyed) return;
                                eventTriggered = true;
                                swiper.animating = false;
                                const evt = new window.CustomEvent('transitionend', {
                                    bubbles: true,
                                    cancelable: true
                                });
                                swiper.wrapperEl.dispatchEvent(evt);
                            });
                        });
                    }
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/effect-fade.mjs





                function EffectFade(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        fadeEffect: {
                            crossFade: false
                        }
                    });
                    const setTranslate = () => {
                        const {
                            slides
                        } = swiper;
                        const params = swiper.params.fadeEffect;
                        for (let i = 0; i < slides.length; i += 1) {
                            const slideEl = swiper.slides[i];
                            const offset = slideEl.swiperSlideOffset;
                            let tx = -offset;
                            if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                            let ty = 0;
                            if (!swiper.isHorizontal()) {
                                ty = tx;
                                tx = 0;
                            }
                            const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
                            const targetEl = effectTarget(params, slideEl);
                            targetEl.style.opacity = slideOpacity;
                            targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
                        }
                    };
                    const setTransition = duration => {
                        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
                        transformElements.forEach(el => {
                            el.style.transitionDuration = `${duration}ms`;
                        });
                        effectVirtualTransitionEnd({
                            swiper,
                            duration,
                            transformElements,
                            allSlides: true
                        });
                    };
                    effectInit({
                        effect: 'fade',
                        swiper,
                        on,
                        setTranslate,
                        setTransition,
                        overwriteParams: () => ({
                            slidesPerView: 1,
                            slidesPerGroup: 1,
                            watchSlidesProgress: true,
                            spaceBetween: 0,
                            virtualTranslate: !swiper.params.cssMode
                        })
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/effect-cube.mjs



                function EffectCube(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        cubeEffect: {
                            slideShadows: true,
                            shadow: true,
                            shadowOffset: 20,
                            shadowScale: 0.94
                        }
                    });
                    const createSlideShadows = (slideEl, progress, isHorizontal) => {
                        let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
                        let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
                        if (!shadowBefore) {
                            shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));
                            slideEl.append(shadowBefore);
                        }
                        if (!shadowAfter) {
                            shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));
                            slideEl.append(shadowAfter);
                        }
                        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
                        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
                    };
                    const recreateShadows = () => {
                        // create new ones
                        const isHorizontal = swiper.isHorizontal();
                        swiper.slides.forEach(slideEl => {
                            const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                            createSlideShadows(slideEl, progress, isHorizontal);
                        });
                    };
                    const setTranslate = () => {
                        const {
                            el,
                            wrapperEl,
                            slides,
                            width: swiperWidth,
                            height: swiperHeight,
                            rtlTranslate: rtl,
                            size: swiperSize,
                            browser
                        } = swiper;
                        const params = swiper.params.cubeEffect;
                        const isHorizontal = swiper.isHorizontal();
                        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                        let wrapperRotate = 0;
                        let cubeShadowEl;
                        if (params.shadow) {
                            if (isHorizontal) {
                                cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');
                                if (!cubeShadowEl) {
                                    cubeShadowEl = createElement('div', 'swiper-cube-shadow');
                                    swiper.wrapperEl.append(cubeShadowEl);
                                }
                                cubeShadowEl.style.height = `${swiperWidth}px`;
                            } else {
                                cubeShadowEl = el.querySelector('.swiper-cube-shadow');
                                if (!cubeShadowEl) {
                                    cubeShadowEl = createElement('div', 'swiper-cube-shadow');
                                    el.append(cubeShadowEl);
                                }
                            }
                        }
                        for (let i = 0; i < slides.length; i += 1) {
                            const slideEl = slides[i];
                            let slideIndex = i;
                            if (isVirtual) {
                                slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
                            }
                            let slideAngle = slideIndex * 90;
                            let round = Math.floor(slideAngle / 360);
                            if (rtl) {
                                slideAngle = -slideAngle;
                                round = Math.floor(-slideAngle / 360);
                            }
                            const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                            let tx = 0;
                            let ty = 0;
                            let tz = 0;
                            if (slideIndex % 4 === 0) {
                                tx = -round * 4 * swiperSize;
                                tz = 0;
                            } else if ((slideIndex - 1) % 4 === 0) {
                                tx = 0;
                                tz = -round * 4 * swiperSize;
                            } else if ((slideIndex - 2) % 4 === 0) {
                                tx = swiperSize + round * 4 * swiperSize;
                                tz = swiperSize;
                            } else if ((slideIndex - 3) % 4 === 0) {
                                tx = -swiperSize;
                                tz = 3 * swiperSize + swiperSize * 4 * round;
                            }
                            if (rtl) {
                                tx = -tx;
                            }
                            if (!isHorizontal) {
                                ty = tx;
                                tx = 0;
                            }
                            const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
                            if (progress <= 1 && progress > -1) {
                                wrapperRotate = slideIndex * 90 + progress * 90;
                                if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
                            }
                            slideEl.style.transform = transform;
                            if (params.slideShadows) {
                                createSlideShadows(slideEl, progress, isHorizontal);
                            }
                        }
                        wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
                        wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
                        if (params.shadow) {
                            if (isHorizontal) {
                                cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;
                            } else {
                                const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                                const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                                const scale1 = params.shadowScale;
                                const scale2 = params.shadowScale / multiplier;
                                const offset = params.shadowOffset;
                                cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;
                            }
                        }
                        const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
                        wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;
                        wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
                    };
                    const setTransition = duration => {
                        const {
                            el,
                            slides
                        } = swiper;
                        slides.forEach(slideEl => {
                            slideEl.style.transitionDuration = `${duration}ms`;
                            slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {
                                subEl.style.transitionDuration = `${duration}ms`;
                            });
                        });
                        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                            const shadowEl = el.querySelector('.swiper-cube-shadow');
                            if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
                        }
                    };
                    effectInit({
                        effect: 'cube',
                        swiper,
                        on,
                        setTranslate,
                        setTransition,
                        recreateShadows,
                        getEffectParams: () => swiper.params.cubeEffect,
                        perspective: () => true,
                        overwriteParams: () => ({
                            slidesPerView: 1,
                            slidesPerGroup: 1,
                            watchSlidesProgress: true,
                            resistanceRatio: 0,
                            spaceBetween: 0,
                            centeredSlides: false,
                            virtualTranslate: true
                        })
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/shared/create-shadow.mjs


                function create_shadow_createShadow(suffix, slideEl, side) {
                    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;
                    const shadowContainer = getSlideTransformEl(slideEl);
                    let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);
                    if (!shadowEl) {
                        shadowEl = createElement('div', shadowClass.split(' '));
                        shadowContainer.append(shadowEl);
                    }
                    return shadowEl;
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/effect-flip.mjs






                function EffectFlip(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        flipEffect: {
                            slideShadows: true,
                            limitRotation: true
                        }
                    });
                    const createSlideShadows = (slideEl, progress) => {
                        let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
                        let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
                        if (!shadowBefore) {
                            shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');
                        }
                        if (!shadowAfter) {
                            shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
                        }
                        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
                        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
                    };
                    const recreateShadows = () => {
                        // Set shadows
                        swiper.params.flipEffect;
                        swiper.slides.forEach(slideEl => {
                            let progress = slideEl.progress;
                            if (swiper.params.flipEffect.limitRotation) {
                                progress = Math.max(Math.min(slideEl.progress, 1), -1);
                            }
                            createSlideShadows(slideEl, progress);
                        });
                    };
                    const setTranslate = () => {
                        const {
                            slides,
                            rtlTranslate: rtl
                        } = swiper;
                        const params = swiper.params.flipEffect;
                        for (let i = 0; i < slides.length; i += 1) {
                            const slideEl = slides[i];
                            let progress = slideEl.progress;
                            if (swiper.params.flipEffect.limitRotation) {
                                progress = Math.max(Math.min(slideEl.progress, 1), -1);
                            }
                            const offset = slideEl.swiperSlideOffset;
                            const rotate = -180 * progress;
                            let rotateY = rotate;
                            let rotateX = 0;
                            let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                            let ty = 0;
                            if (!swiper.isHorizontal()) {
                                ty = tx;
                                tx = 0;
                                rotateX = -rotateY;
                                rotateY = 0;
                            } else if (rtl) {
                                rotateY = -rotateY;
                            }
                            slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
                            if (params.slideShadows) {
                                createSlideShadows(slideEl, progress);
                            }
                            const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                            const targetEl = effectTarget(params, slideEl);
                            targetEl.style.transform = transform;
                        }
                    };
                    const setTransition = duration => {
                        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
                        transformElements.forEach(el => {
                            el.style.transitionDuration = `${duration}ms`;
                            el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
                                shadowEl.style.transitionDuration = `${duration}ms`;
                            });
                        });
                        effectVirtualTransitionEnd({
                            swiper,
                            duration,
                            transformElements
                        });
                    };
                    effectInit({
                        effect: 'flip',
                        swiper,
                        on,
                        setTranslate,
                        setTransition,
                        recreateShadows,
                        getEffectParams: () => swiper.params.flipEffect,
                        perspective: () => true,
                        overwriteParams: () => ({
                            slidesPerView: 1,
                            slidesPerGroup: 1,
                            watchSlidesProgress: true,
                            spaceBetween: 0,
                            virtualTranslate: !swiper.params.cssMode
                        })
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/effect-coverflow.mjs





                function EffectCoverflow(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        coverflowEffect: {
                            rotate: 50,
                            stretch: 0,
                            depth: 100,
                            scale: 1,
                            modifier: 1,
                            slideShadows: true
                        }
                    });
                    const setTranslate = () => {
                        const {
                            width: swiperWidth,
                            height: swiperHeight,
                            slides,
                            slidesSizesGrid
                        } = swiper;
                        const params = swiper.params.coverflowEffect;
                        const isHorizontal = swiper.isHorizontal();
                        const transform = swiper.translate;
                        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
                        const rotate = isHorizontal ? params.rotate : -params.rotate;
                        const translate = params.depth;
                        // Each slide offset from center
                        for (let i = 0, length = slides.length; i < length; i += 1) {
                            const slideEl = slides[i];
                            const slideSize = slidesSizesGrid[i];
                            const slideOffset = slideEl.swiperSlideOffset;
                            const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
                            const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
                            let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                            let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
                            // var rotateZ = 0
                            let translateZ = -translate * Math.abs(offsetMultiplier);
                            let stretch = params.stretch;
                            // Allow percentage to make a relative stretch for responsive sliders
                            if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
                                stretch = parseFloat(params.stretch) / 100 * slideSize;
                            }
                            let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
                            let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
                            let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

                            // Fix for ultra small values
                            if (Math.abs(translateX) < 0.001) translateX = 0;
                            if (Math.abs(translateY) < 0.001) translateY = 0;
                            if (Math.abs(translateZ) < 0.001) translateZ = 0;
                            if (Math.abs(rotateY) < 0.001) rotateY = 0;
                            if (Math.abs(rotateX) < 0.001) rotateX = 0;
                            if (Math.abs(scale) < 0.001) scale = 0;
                            const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
                            const targetEl = effectTarget(params, slideEl);
                            targetEl.style.transform = slideTransform;
                            slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                            if (params.slideShadows) {
                                // Set shadows
                                let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
                                let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
                                if (!shadowBeforeEl) {
                                    shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');
                                }
                                if (!shadowAfterEl) {
                                    shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');
                                }
                                if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                                if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                            }
                        }
                    };
                    const setTransition = duration => {
                        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
                        transformElements.forEach(el => {
                            el.style.transitionDuration = `${duration}ms`;
                            el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
                                shadowEl.style.transitionDuration = `${duration}ms`;
                            });
                        });
                    };
                    effectInit({
                        effect: 'coverflow',
                        swiper,
                        on,
                        setTranslate,
                        setTransition,
                        perspective: () => true,
                        overwriteParams: () => ({
                            watchSlidesProgress: true
                        })
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/effect-creative.mjs






                function EffectCreative(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        creativeEffect: {
                            limitProgress: 1,
                            shadowPerProgress: false,
                            progressMultiplier: 1,
                            perspective: true,
                            prev: {
                                translate: [0, 0, 0],
                                rotate: [0, 0, 0],
                                opacity: 1,
                                scale: 1
                            },
                            next: {
                                translate: [0, 0, 0],
                                rotate: [0, 0, 0],
                                opacity: 1,
                                scale: 1
                            }
                        }
                    });
                    const getTranslateValue = value => {
                        if (typeof value === 'string') return value;
                        return `${value}px`;
                    };
                    const setTranslate = () => {
                        const {
                            slides,
                            wrapperEl,
                            slidesSizesGrid
                        } = swiper;
                        const params = swiper.params.creativeEffect;
                        const {
                            progressMultiplier: multiplier
                        } = params;
                        const isCenteredSlides = swiper.params.centeredSlides;
                        if (isCenteredSlides) {
                            const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                            wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
                        }
                        for (let i = 0; i < slides.length; i += 1) {
                            const slideEl = slides[i];
                            const slideProgress = slideEl.progress;
                            const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
                            let originalProgress = progress;
                            if (!isCenteredSlides) {
                                originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
                            }
                            const offset = slideEl.swiperSlideOffset;
                            const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
                            const r = [0, 0, 0];
                            let custom = false;
                            if (!swiper.isHorizontal()) {
                                t[1] = t[0];
                                t[0] = 0;
                            }
                            let data = {
                                translate: [0, 0, 0],
                                rotate: [0, 0, 0],
                                scale: 1,
                                opacity: 1
                            };
                            if (progress < 0) {
                                data = params.next;
                                custom = true;
                            } else if (progress > 0) {
                                data = params.prev;
                                custom = true;
                            }
                            // set translate
                            t.forEach((value, index) => {
                                t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
                            });
                            // set rotates
                            r.forEach((value, index) => {
                                r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                            });
                            slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                            const translateString = t.join(', ');
                            const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
                            const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
                            const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
                            const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

                            // Set shadows
                            if (custom && data.shadow || !custom) {
                                let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
                                if (!shadowEl && data.shadow) {
                                    shadowEl = createShadow('creative', slideEl);
                                }
                                if (shadowEl) {
                                    const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                                    shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                                }
                            }
                            const targetEl = effectTarget(params, slideEl);
                            targetEl.style.transform = transform;
                            targetEl.style.opacity = opacityString;
                            if (data.origin) {
                                targetEl.style.transformOrigin = data.origin;
                            }
                        }
                    };
                    const setTransition = duration => {
                        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
                        transformElements.forEach(el => {
                            el.style.transitionDuration = `${duration}ms`;
                            el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
                                shadowEl.style.transitionDuration = `${duration}ms`;
                            });
                        });
                        effectVirtualTransitionEnd({
                            swiper,
                            duration,
                            transformElements,
                            allSlides: true
                        });
                    };
                    effectInit({
                        effect: 'creative',
                        swiper,
                        on,
                        setTranslate,
                        setTransition,
                        perspective: () => swiper.params.creativeEffect.perspective,
                        overwriteParams: () => ({
                            watchSlidesProgress: true,
                            virtualTranslate: !swiper.params.cssMode
                        })
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/effect-cards.mjs






                function EffectCards(_ref) {
                    let {
                        swiper,
                        extendParams,
                        on
                    } = _ref;
                    extendParams({
                        cardsEffect: {
                            slideShadows: true,
                            rotate: true,
                            perSlideRotate: 2,
                            perSlideOffset: 8
                        }
                    });
                    const setTranslate = () => {
                        const {
                            slides,
                            activeIndex,
                            rtlTranslate: rtl
                        } = swiper;
                        const params = swiper.params.cardsEffect;
                        const {
                            startTranslate,
                            isTouched
                        } = swiper.touchEventsData;
                        const currentTranslate = rtl ? -swiper.translate : swiper.translate;
                        for (let i = 0; i < slides.length; i += 1) {
                            const slideEl = slides[i];
                            const slideProgress = slideEl.progress;
                            const progress = Math.min(Math.max(slideProgress, -4), 4);
                            let offset = slideEl.swiperSlideOffset;
                            if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                                swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
                            }
                            if (swiper.params.centeredSlides && swiper.params.cssMode) {
                                offset -= slides[0].swiperSlideOffset;
                            }
                            let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                            let tY = 0;
                            const tZ = -100 * Math.abs(progress);
                            let scale = 1;
                            let rotate = -params.perSlideRotate * progress;
                            let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
                            const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
                            const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
                            const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
                            if (isSwipeToNext || isSwipeToPrev) {
                                const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                                rotate += -28 * progress * subProgress;
                                scale += -0.5 * subProgress;
                                tXAdd += 96 * subProgress;
                                tY = `${-25 * subProgress * Math.abs(progress)}%`;
                            }
                            if (progress < 0) {
                                // next
                                tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;
                            } else if (progress > 0) {
                                // prev
                                tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;
                            } else {
                                tX = `${tX}px`;
                            }
                            if (!swiper.isHorizontal()) {
                                const prevY = tY;
                                tY = tX;
                                tX = prevY;
                            }
                            const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;

                            /* eslint-disable */
                            const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
                            /* eslint-enable */

                            if (params.slideShadows) {
                                // Set shadows
                                let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
                                if (!shadowEl) {
                                    shadowEl = createShadow('cards', slideEl);
                                }
                                if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
                            }
                            slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                            const targetEl = effectTarget(params, slideEl);
                            targetEl.style.transform = transform;
                        }
                    };
                    const setTransition = duration => {
                        const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
                        transformElements.forEach(el => {
                            el.style.transitionDuration = `${duration}ms`;
                            el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
                                shadowEl.style.transitionDuration = `${duration}ms`;
                            });
                        });
                        effectVirtualTransitionEnd({
                            swiper,
                            duration,
                            transformElements
                        });
                    };
                    effectInit({
                        effect: 'cards',
                        swiper,
                        on,
                        setTranslate,
                        setTransition,
                        perspective: () => true,
                        overwriteParams: () => ({
                            watchSlidesProgress: true,
                            virtualTranslate: !swiper.params.cssMode
                        })
                    });
                }



                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/index.mjs























                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/swiper.css
                // extracted by mini-css-extract-plugin

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/pagination.css
                // extracted by mini-css-extract-plugin

                // EXTERNAL MODULE: ./src/constants/index.ts + 1 modules
                var constants = __webpack_require__("CW2u");
                // EXTERNAL MODULE: ./src/hooks/index.ts + 4 modules
                var hooks = __webpack_require__("CgVz");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/Section.tsx
                var Section = __webpack_require__("4oCX");
                // EXTERNAL MODULE: ./src/routes/defiwallet/components/FadeInComp.tsx
                var FadeInComp = __webpack_require__("mRbc");
                // EXTERNAL MODULE: ./src/components/Video.tsx
                var Video = __webpack_require__("ZMxh");; // CONCATENATED MODULE: ./src/routes/defiwallet/components/Section4.tsx












                function Section4(param) {
                    var onClick = param.onClick;
                    var t = (0, hooks /* useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                        className: "dark-bg-2 py-20 lg:py-[120px]",
                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Section /* Section */ .$, {
                            className: "!px-0",
                            children: /*#__PURE__*/ (0, jsx_runtime.jsxs)(FadeInComp /* FadeInComp */ .O, {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "px-6 lg:px-0",
                                        children: /*#__PURE__*/ (0, jsx_runtime.jsxs)("h3", {
                                            className: "headline-4 md:headline-3 lg:headline-2 dark-t-primary mb-12 lg:mb-[64px]",
                                            children: [
                                                /*#__PURE__*/
                                                (0, jsx_runtime.jsxs)("div", {
                                                    className: "hidden md:block md:text-center",
                                                    children: [
                                                        /*#__PURE__*/
                                                        (0, jsx_runtime.jsx)("div", {
                                                            children: t("security-title1", {
                                                                defaultValue: "Putting you in control."
                                                            })
                                                        }),
                                                        /*#__PURE__*/
                                                        (0, jsx_runtime.jsx)("div", {
                                                            children: t("security-title2", {
                                                                defaultValue: "Secured at every stage."
                                                            })
                                                        })
                                                    ]
                                                }),
                                                /*#__PURE__*/
                                                (0, jsx_runtime.jsxs)("div", {
                                                    className: "block text-center md:hidden md:text-left",
                                                    children: [
                                                        /*#__PURE__*/
                                                        (0, jsx_runtime.jsx)("span", {
                                                            className: "mr-[4px]",
                                                            children: t("security-title1", {
                                                                defaultValue: "Putting you in control."
                                                            })
                                                        }),
                                                        t("security-title2", {
                                                            defaultValue: "Secured at every stage."
                                                        })
                                                    ]
                                                })
                                            ]
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        className: "block lg:hidden",
                                        children: /*#__PURE__*/ (0, jsx_runtime.jsx)(SwiperCards, {
                                            handleClick: onClick
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        className: "hidden items-center justify-between lg:flex",
                                        children: [
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)(Card1, {}),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)(Card2, {
                                                handleClick: onClick
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)(Card3, {})
                                        ]
                                    })
                                ]
                            })
                        })
                    });
                }

                function SwiperCards(param) {
                    var handleClick = param.handleClick;
                    var pagination = {
                        clickable: true,
                        renderBullet: function renderBullet(index, className) {
                            return '<span class="swiper-pagination-bullet '.concat(className, '"></span>');
                        }
                    };
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(swiper_react_Swiper, {
                        className: "swiper-wrap",
                        pagination: pagination,
                        modules: [
                            Pagination
                        ],
                        breakpoints: {
                            320: {
                                slidesPerView: 1.2,
                                spaceBetween: 12
                            },
                            640: {
                                slidesPerView: 2,
                                spaceBetween: 12
                            }
                        },
                        onSlideChange: function() {
                            return console.log("slide change");
                        },
                        onSwiper: function(swiper) {
                            return console.log(swiper);
                        },
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(SwiperSlide, {
                                className: "md:!w-[327px] pl-6",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Card1, {})
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(SwiperSlide, {
                                className: "md:!w-[327px] md:pl-6",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Card2, {
                                    handleClick: handleClick
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(SwiperSlide, {
                                className: "md:!w-[327px] pr-6 md:px-6",
                                children: /*#__PURE__*/ (0, jsx_runtime.jsx)(Card3, {})
                            })
                        ]
                    });
                }

                function Card(_param) {
                    var className = _param.className,
                        props = (0, _object_without_properties /* default */ .Z)(_param, [
                            "className"
                        ]);
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", (0, _object_spread /* default */ .Z)({
                        className: "dark-bg-1 md:mx-unset relative mx-auto h-[490px] rounded-2xl p-[24px] pb-0 md:w-[327px] lg:h-[520px] lg:w-[340px] lg:p-10 ".concat(className)
                    }, props));
                }

                function CardTitle(param) {
                    var children = param.children;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                        className: "headline-6 dark-t-primary mb-[16px]",
                        children: children
                    });
                }

                function CardBody(param) {
                    var children = param.children;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)("div", {
                        className: "body-2 dark-t-secondary",
                        children: children
                    });
                }

                function CardVideo(param) {
                    var src = param.src,
                        className = param.className;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(Video /* Video */ .n, {
                        style: {
                            outlineOffset: "-2px"
                        },
                        outline: "2px solid #181A20",
                        className: "absolute bottom-[54px] left-0 right-0 mx-auto w-[279px] ".concat(className !== null && className !== void 0 ? className : "", "}"),
                        src: src
                    });
                }

                function Card1() {
                    var t = (0, hooks /* useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(Card, {
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardTitle, {
                                children: t("self-custody-wallet", {
                                    defaultValue: "Self-Custody Wallet"
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardBody, {
                                children: t("self-custody-wallet-text", {
                                    defaultValue: "Funds held in the wallet are exclusively owned and accessible only by the user. You are in complete control over your crypto assets."
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardVideo, {
                                src: "".concat(constants /* IMG_URL */ .bV, "/lock-v2.mp4")
                            })
                        ]
                    });
                }

                function Card2(param) {
                    var handleClick = param.handleClick;
                    var t = (0, hooks /* useTranslation */ .$G)();
                    var t2 = (0, hooks /* useTranslation */ .$G)("");
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(Card, {
                        className: "lg:mx-[24px] lg:h-[580px] lg:w-[472px]",
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardTitle, {
                                children: t("powered-mpc-title", {
                                    defaultValue: "Powered by MPC"
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsxs)(CardBody, {
                                children: [
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsx)("div", {
                                        children: t("powered-mpc-text", {
                                            defaultValue: "No more worry about seed phrases or private keys. Binance Web3 Wallet uses an advanced security technique called Multi-Party Computation (MPC). Instead of keeping your private keys in one place, MPC breaks them into three smaller parts."
                                        })
                                    }),
                                    /*#__PURE__*/
                                    (0, jsx_runtime.jsxs)("div", {
                                        className: "t-primary-hover mt-[8px] flex cursor-pointer items-center",
                                        onClick: handleClick,
                                        children: [
                                            t2("wmp-learn-more", {
                                                defaultValue: "Learn more"
                                            }),
                                            /*#__PURE__*/
                                            (0, jsx_runtime.jsx)("img", {
                                                src: "".concat(constants /* IMG_URL */ .bV, "/chevron-right-f.svg"),
                                                className: "h-6 w-6"
                                            })
                                        ]
                                    })
                                ]
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardVideo, {
                                className: "lg:w-[392px]",
                                src: "".concat(constants /* IMG_URL */ .bV, "/cloud-mpc-v2.mp4")
                            })
                        ]
                    });
                }

                function Card3() {
                    var t = (0, hooks /* useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, jsx_runtime.jsxs)(Card, {
                        children: [
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardTitle, {
                                children: t("risk-controls-title", {
                                    defaultValue: "Built-in risk controls"
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardBody, {
                                children: t("risk-controls-text", {
                                    defaultValue: "Get alerts if a token or blockchain carries security risks, including wrong address protection or malicious contract detection."
                                })
                            }),
                            /*#__PURE__*/
                            (0, jsx_runtime.jsx)(CardVideo, {
                                src: "".concat(constants /* IMG_URL */ .bV, "/risk-v2.mp4")
                            })
                        ]
                    });
                }


                /***/
            }),

        /***/
        "oZ2f":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "u": () => ( /* binding */ Transition)
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread.mjs
                var _object_spread = __webpack_require__("ys0/");
                // EXTERNAL MODULE: ./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js
                var jsx_runtime = __webpack_require__("oUqw");
                // EXTERNAL MODULE: external "React"
                var external_React_ = __webpack_require__("DTvD");
                var external_React_default = /*#__PURE__*/ __webpack_require__.n(external_React_);
                // EXTERNAL MODULE: ./node_modules/.pnpm/lottie-web@5.12.2/node_modules/lottie-web/build/player/lottie.js
                var lottie = __webpack_require__("PJuR");
                var lottie_default = /*#__PURE__*/ __webpack_require__.n(lottie);
                // EXTERNAL MODULE: ./node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/react.js
                var react = __webpack_require__("M6q6");
                var react_default = /*#__PURE__*/ __webpack_require__.n(react);
                // EXTERNAL MODULE: ./node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/default.js
                var rfdc_default = __webpack_require__("7SlD");
                var default_default = /*#__PURE__*/ __webpack_require__.n(rfdc_default);; // CONCATENATED MODULE: ./node_modules/.pnpm/react-lottie-player@1.5.6_react@18.2.0/node_modules/react-lottie-player/dist/LottiePlayer.modern.js





                function _extends() {
                    _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];

                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }

                        return target;
                    };

                    return _extends.apply(this, arguments);
                }

                function _objectWithoutPropertiesLoose(source, excluded) {
                    if (source == null) return {};
                    var target = {};
                    var sourceKeys = Object.keys(source);
                    var key, i;

                    for (i = 0; i < sourceKeys.length; i++) {
                        key = sourceKeys[i];
                        if (excluded.indexOf(key) >= 0) continue;
                        target[key] = source[key];
                    }

                    return target;
                }

                function createCommonjsModule(fn, module) {
                    return module = {
                        exports: {}
                    }, fn(module, module.exports), module.exports;
                }

                /** @license React v16.13.1
                 * react-is.production.min.js
                 *
                 * Copyright (c) Facebook, Inc. and its affiliates.
                 *
                 * This source code is licensed under the MIT license found in the
                 * LICENSE file in the root directory of this source tree.
                 */
                var b = "function" === typeof Symbol && Symbol.for,
                    c = b ? Symbol.for("react.element") : 60103,
                    d = b ? Symbol.for("react.portal") : 60106,
                    e = b ? Symbol.for("react.fragment") : 60107,
                    f = b ? Symbol.for("react.strict_mode") : 60108,
                    g = b ? Symbol.for("react.profiler") : 60114,
                    h = b ? Symbol.for("react.provider") : 60109,
                    k = b ? Symbol.for("react.context") : 60110,
                    l = b ? Symbol.for("react.async_mode") : 60111,
                    m = b ? Symbol.for("react.concurrent_mode") : 60111,
                    n = b ? Symbol.for("react.forward_ref") : 60112,
                    p = b ? Symbol.for("react.suspense") : 60113,
                    q = b ?
                    Symbol.for("react.suspense_list") : 60120,
                    r = b ? Symbol.for("react.memo") : 60115,
                    t = b ? Symbol.for("react.lazy") : 60116,
                    v = b ? Symbol.for("react.block") : 60121,
                    w = b ? Symbol.for("react.fundamental") : 60117,
                    x = b ? Symbol.for("react.responder") : 60118,
                    y = b ? Symbol.for("react.scope") : 60119;

                function z(a) {
                    if ("object" === typeof a && null !== a) {
                        var u = a.$$typeof;
                        switch (u) {
                            case c:
                                switch (a = a.type, a) {
                                    case l:
                                    case m:
                                    case e:
                                    case g:
                                    case f:
                                    case p:
                                        return a;
                                    default:
                                        switch (a = a && a.$$typeof, a) {
                                            case k:
                                            case n:
                                            case t:
                                            case r:
                                            case h:
                                                return a;
                                            default:
                                                return u
                                        }
                                }
                            case d:
                                return u
                        }
                    }
                }

                function A(a) {
                    return z(a) === m
                }
                var AsyncMode = l;
                var ConcurrentMode = m;
                var ContextConsumer = k;
                var ContextProvider = h;
                var Element = c;
                var ForwardRef = n;
                var Fragment = e;
                var Lazy = t;
                var Memo = r;
                var Portal = d;
                var Profiler = g;
                var StrictMode = f;
                var Suspense = p;
                var isAsyncMode = function(a) {
                    return A(a) || z(a) === l
                };
                var isConcurrentMode = A;
                var isContextConsumer = function(a) {
                    return z(a) === k
                };
                var isContextProvider = function(a) {
                    return z(a) === h
                };
                var isElement = function(a) {
                    return "object" === typeof a && null !== a && a.$$typeof === c
                };
                var isForwardRef = function(a) {
                    return z(a) === n
                };
                var isFragment = function(a) {
                    return z(a) === e
                };
                var isLazy = function(a) {
                    return z(a) === t
                };
                var isMemo = function(a) {
                    return z(a) === r
                };
                var isPortal = function(a) {
                    return z(a) === d
                };
                var isProfiler = function(a) {
                    return z(a) === g
                };
                var isStrictMode = function(a) {
                    return z(a) === f
                };
                var isSuspense = function(a) {
                    return z(a) === p
                };
                var isValidElementType = function(a) {
                    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v)
                };
                var typeOf = z;

                var reactIs_production_min = {
                    AsyncMode: AsyncMode,
                    ConcurrentMode: ConcurrentMode,
                    ContextConsumer: ContextConsumer,
                    ContextProvider: ContextProvider,
                    Element: Element,
                    ForwardRef: ForwardRef,
                    Fragment: Fragment,
                    Lazy: Lazy,
                    Memo: Memo,
                    Portal: Portal,
                    Profiler: Profiler,
                    StrictMode: StrictMode,
                    Suspense: Suspense,
                    isAsyncMode: isAsyncMode,
                    isConcurrentMode: isConcurrentMode,
                    isContextConsumer: isContextConsumer,
                    isContextProvider: isContextProvider,
                    isElement: isElement,
                    isForwardRef: isForwardRef,
                    isFragment: isFragment,
                    isLazy: isLazy,
                    isMemo: isMemo,
                    isPortal: isPortal,
                    isProfiler: isProfiler,
                    isStrictMode: isStrictMode,
                    isSuspense: isSuspense,
                    isValidElementType: isValidElementType,
                    typeOf: typeOf
                };

                var reactIs_development = createCommonjsModule(function(module, exports) {



                    if (false) {}
                });

                var reactIs = createCommonjsModule(function(module) {

                    if (true) {
                        module.exports = reactIs_production_min;
                    } else {}
                });

                /*
                object-assign
                (c) Sindre Sorhus
                @license MIT
                */
                /* eslint-disable no-unused-vars */
                var getOwnPropertySymbols = Object.getOwnPropertySymbols;
                var LottiePlayer_modern_hasOwnProperty = Object.prototype.hasOwnProperty;
                var propIsEnumerable = Object.prototype.propertyIsEnumerable;

                function toObject(val) {
                    if (val === null || val === undefined) {
                        throw new TypeError('Object.assign cannot be called with null or undefined');
                    }

                    return Object(val);
                }

                function shouldUseNative() {
                    try {
                        if (!Object.assign) {
                            return false;
                        }

                        // Detect buggy property enumeration order in older V8 versions.

                        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
                        test1[5] = 'de';
                        if (Object.getOwnPropertyNames(test1)[0] === '5') {
                            return false;
                        }

                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                        var test2 = {};
                        for (var i = 0; i < 10; i++) {
                            test2['_' + String.fromCharCode(i)] = i;
                        }
                        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                            return test2[n];
                        });
                        if (order2.join('') !== '0123456789') {
                            return false;
                        }

                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                        var test3 = {};
                        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                            test3[letter] = letter;
                        });
                        if (Object.keys(Object.assign({}, test3)).join('') !==
                            'abcdefghijklmnopqrst') {
                            return false;
                        }

                        return true;
                    } catch (err) {
                        // We don't expect any of the above to throw, but better to be safe.
                        return false;
                    }
                }

                var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
                    var from;
                    var to = toObject(target);
                    var symbols;

                    for (var s = 1; s < arguments.length; s++) {
                        from = Object(arguments[s]);

                        for (var key in from) {
                            if (LottiePlayer_modern_hasOwnProperty.call(from, key)) {
                                to[key] = from[key];
                            }
                        }

                        if (getOwnPropertySymbols) {
                            symbols = getOwnPropertySymbols(from);
                            for (var i = 0; i < symbols.length; i++) {
                                if (propIsEnumerable.call(from, symbols[i])) {
                                    to[symbols[i]] = from[symbols[i]];
                                }
                            }
                        }
                    }

                    return to;
                };

                /**
                 * Copyright (c) 2013-present, Facebook, Inc.
                 *
                 * This source code is licensed under the MIT license found in the
                 * LICENSE file in the root directory of this source tree.
                 */

                var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

                var ReactPropTypesSecret_1 = ReactPropTypesSecret;

                var has = Function.call.bind(Object.prototype.hasOwnProperty);

                var printWarning = function() {};

                if (false) {
                    var has$1, loggedTypeFailures, ReactPropTypesSecret$1;
                }

                /**
                 * Assert that the values match with the type specs.
                 * Error messages are memorized and will only be shown once.
                 *
                 * @param {object} typeSpecs Map of name to a ReactPropType
                 * @param {object} values Runtime values that need to be type-checked
                 * @param {string} location e.g. "prop", "context", "child context"
                 * @param {string} componentName Name of the component for error messages.
                 * @param {?Function} getStack Returns the component stack.
                 * @private
                 */
                function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
                    if (false) {
                        var stack, err, error, typeSpecName;
                    }
                }

                /**
                 * Resets warning cache when testing.
                 *
                 * @private
                 */
                checkPropTypes.resetWarningCache = function() {
                    if (false) {}
                };

                var checkPropTypes_1 = ( /* unused pure expression or super */ null && (checkPropTypes));

                var printWarning$1 = function() {};

                if (false) {}

                function emptyFunctionThatReturnsNull() {
                    return null;
                }

                var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
                    /* global Symbol */
                    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
                    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

                    /**
                     * Returns the iterator method function contained on the iterable object.
                     *
                     * Be sure to invoke the function with the iterable as context:
                     *
                     *     var iteratorFn = getIteratorFn(myIterable);
                     *     if (iteratorFn) {
                     *       var iterator = iteratorFn.call(myIterable);
                     *       ...
                     *     }
                     *
                     * @param {?object} maybeIterable
                     * @return {?function}
                     */
                    function getIteratorFn(maybeIterable) {
                        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                        if (typeof iteratorFn === 'function') {
                            return iteratorFn;
                        }
                    }

                    /**
                     * Collection of methods that allow declaration and validation of props that are
                     * supplied to React components. Example usage:
                     *
                     *   var Props = require('ReactPropTypes');
                     *   var MyArticle = React.createClass({
                     *     propTypes: {
                     *       // An optional string prop named "description".
                     *       description: Props.string,
                     *
                     *       // A required enum prop named "category".
                     *       category: Props.oneOf(['News','Photos']).isRequired,
                     *
                     *       // A prop named "dialog" that requires an instance of Dialog.
                     *       dialog: Props.instanceOf(Dialog).isRequired
                     *     },
                     *     render: function() { ... }
                     *   });
                     *
                     * A more formal specification of how these methods are used:
                     *
                     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
                     *   decl := ReactPropTypes.{type}(.isRequired)?
                     *
                     * Each and every declaration produces a function with the same signature. This
                     * allows the creation of custom validation functions. For example:
                     *
                     *  var MyLink = React.createClass({
                     *    propTypes: {
                     *      // An optional string or URI prop named "href".
                     *      href: function(props, propName, componentName) {
                     *        var propValue = props[propName];
                     *        if (propValue != null && typeof propValue !== 'string' &&
                     *            !(propValue instanceof URI)) {
                     *          return new Error(
                     *            'Expected a string or an URI for ' + propName + ' in ' +
                     *            componentName
                     *          );
                     *        }
                     *      }
                     *    },
                     *    render: function() {...}
                     *  });
                     *
                     * @internal
                     */

                    var ANONYMOUS = '<<anonymous>>';

                    // Important!
                    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
                    var ReactPropTypes = {
                        array: createPrimitiveTypeChecker('array'),
                        bigint: createPrimitiveTypeChecker('bigint'),
                        bool: createPrimitiveTypeChecker('boolean'),
                        func: createPrimitiveTypeChecker('function'),
                        number: createPrimitiveTypeChecker('number'),
                        object: createPrimitiveTypeChecker('object'),
                        string: createPrimitiveTypeChecker('string'),
                        symbol: createPrimitiveTypeChecker('symbol'),

                        any: createAnyTypeChecker(),
                        arrayOf: createArrayOfTypeChecker,
                        element: createElementTypeChecker(),
                        elementType: createElementTypeTypeChecker(),
                        instanceOf: createInstanceTypeChecker,
                        node: createNodeChecker(),
                        objectOf: createObjectOfTypeChecker,
                        oneOf: createEnumTypeChecker,
                        oneOfType: createUnionTypeChecker,
                        shape: createShapeTypeChecker,
                        exact: createStrictShapeTypeChecker,
                    };

                    /**
                     * inlined Object.is polyfill to avoid requiring consumers ship their own
                     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
                     */
                    /*eslint-disable no-self-compare*/
                    function is(x, y) {
                        // SameValue algorithm
                        if (x === y) {
                            // Steps 1-5, 7-10
                            // Steps 6.b-6.e: +0 != -0
                            return x !== 0 || 1 / x === 1 / y;
                        } else {
                            // Step 6.a: NaN == NaN
                            return x !== x && y !== y;
                        }
                    }
                    /*eslint-enable no-self-compare*/

                    /**
                     * We use an Error-like object for backward compatibility as people may call
                     * PropTypes directly and inspect their output. However, we don't use real
                     * Errors anymore. We don't inspect their stack anyway, and creating them
                     * is prohibitively expensive if they are created too often, such as what
                     * happens in oneOfType() for any type before the one that matched.
                     */
                    function PropTypeError(message, data) {
                        this.message = message;
                        this.data = data && typeof data === 'object' ? data : {};
                        this.stack = '';
                    }
                    // Make `instanceof Error` still work for returned errors.
                    PropTypeError.prototype = Error.prototype;

                    function createChainableTypeChecker(validate) {
                        if (false) {
                            var manualPropTypeWarningCount, manualPropTypeCallCache;
                        }

                        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                            componentName = componentName || ANONYMOUS;
                            propFullName = propFullName || propName;

                            if (secret !== ReactPropTypesSecret_1) {
                                if (throwOnDirectAccess) {
                                    // New behavior only for users of `prop-types` package
                                    var err = new Error(
                                        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                                        'Use `PropTypes.checkPropTypes()` to call them. ' +
                                        'Read more at http://fb.me/use-check-prop-types'
                                    );
                                    err.name = 'Invariant Violation';
                                    throw err;
                                } else if (false) {
                                    var cacheKey;
                                }
                            }
                            if (props[propName] == null) {
                                if (isRequired) {
                                    if (props[propName] === null) {
                                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                                    }
                                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                                }
                                return null;
                            } else {
                                return validate(props, propName, componentName, location, propFullName);
                            }
                        }

                        var chainedCheckType = checkType.bind(null, false);
                        chainedCheckType.isRequired = checkType.bind(null, true);

                        return chainedCheckType;
                    }

                    function createPrimitiveTypeChecker(expectedType) {
                        function validate(props, propName, componentName, location, propFullName, secret) {
                            var propValue = props[propName];
                            var propType = getPropType(propValue);
                            if (propType !== expectedType) {
                                // `propValue` being instance of, say, date/regexp, pass the 'object'
                                // check, but we can offer a more precise error message here rather than
                                // 'of type `object`'.
                                var preciseType = getPreciseType(propValue);

                                return new PropTypeError(
                                    'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
                                        expectedType: expectedType
                                    }
                                );
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createAnyTypeChecker() {
                        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
                    }

                    function createArrayOfTypeChecker(typeChecker) {
                        function validate(props, propName, componentName, location, propFullName) {
                            if (typeof typeChecker !== 'function') {
                                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
                            }
                            var propValue = props[propName];
                            if (!Array.isArray(propValue)) {
                                var propType = getPropType(propValue);
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
                            }
                            for (var i = 0; i < propValue.length; i++) {
                                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
                                if (error instanceof Error) {
                                    return error;
                                }
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createElementTypeChecker() {
                        function validate(props, propName, componentName, location, propFullName) {
                            var propValue = props[propName];
                            if (!isValidElement(propValue)) {
                                var propType = getPropType(propValue);
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createElementTypeTypeChecker() {
                        function validate(props, propName, componentName, location, propFullName) {
                            var propValue = props[propName];
                            if (!reactIs.isValidElementType(propValue)) {
                                var propType = getPropType(propValue);
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createInstanceTypeChecker(expectedClass) {
                        function validate(props, propName, componentName, location, propFullName) {
                            if (!(props[propName] instanceof expectedClass)) {
                                var expectedClassName = expectedClass.name || ANONYMOUS;
                                var actualClassName = getClassName(props[propName]);
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createEnumTypeChecker(expectedValues) {
                        if (!Array.isArray(expectedValues)) {
                            if (false) {}
                            return emptyFunctionThatReturnsNull;
                        }

                        function validate(props, propName, componentName, location, propFullName) {
                            var propValue = props[propName];
                            for (var i = 0; i < expectedValues.length; i++) {
                                if (is(propValue, expectedValues[i])) {
                                    return null;
                                }
                            }

                            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                                var type = getPreciseType(value);
                                if (type === 'symbol') {
                                    return String(value);
                                }
                                return value;
                            });
                            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createObjectOfTypeChecker(typeChecker) {
                        function validate(props, propName, componentName, location, propFullName) {
                            if (typeof typeChecker !== 'function') {
                                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
                            }
                            var propValue = props[propName];
                            var propType = getPropType(propValue);
                            if (propType !== 'object') {
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
                            }
                            for (var key in propValue) {
                                if (has(propValue, key)) {
                                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
                                    if (error instanceof Error) {
                                        return error;
                                    }
                                }
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createUnionTypeChecker(arrayOfTypeCheckers) {
                        if (!Array.isArray(arrayOfTypeCheckers)) {
                            false ? 0 : void 0;
                            return emptyFunctionThatReturnsNull;
                        }

                        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                            var checker = arrayOfTypeCheckers[i];
                            if (typeof checker !== 'function') {
                                printWarning$1(
                                    'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
                                    'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
                                );
                                return emptyFunctionThatReturnsNull;
                            }
                        }

                        function validate(props, propName, componentName, location, propFullName) {
                            var expectedTypes = [];
                            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                                var checker = arrayOfTypeCheckers[i];
                                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1);
                                if (checkerResult == null) {
                                    return null;
                                }
                                if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
                                    expectedTypes.push(checkerResult.data.expectedType);
                                }
                            }
                            var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
                            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createNodeChecker() {
                        function validate(props, propName, componentName, location, propFullName) {
                            if (!isNode(props[propName])) {
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function invalidValidatorError(componentName, location, propFullName, key, type) {
                        return new PropTypeError(
                            (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
                            'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
                        );
                    }

                    function createShapeTypeChecker(shapeTypes) {
                        function validate(props, propName, componentName, location, propFullName) {
                            var propValue = props[propName];
                            var propType = getPropType(propValue);
                            if (propType !== 'object') {
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
                            }
                            for (var key in shapeTypes) {
                                var checker = shapeTypes[key];
                                if (typeof checker !== 'function') {
                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                                }
                                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
                                if (error) {
                                    return error;
                                }
                            }
                            return null;
                        }
                        return createChainableTypeChecker(validate);
                    }

                    function createStrictShapeTypeChecker(shapeTypes) {
                        function validate(props, propName, componentName, location, propFullName) {
                            var propValue = props[propName];
                            var propType = getPropType(propValue);
                            if (propType !== 'object') {
                                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
                            }
                            // We need to check all keys in case some are required but missing from props.
                            var allKeys = objectAssign({}, props[propName], shapeTypes);
                            for (var key in allKeys) {
                                var checker = shapeTypes[key];
                                if (has(shapeTypes, key) && typeof checker !== 'function') {
                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                                }
                                if (!checker) {
                                    return new PropTypeError(
                                        'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
                                        '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
                                        '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
                                    );
                                }
                                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
                                if (error) {
                                    return error;
                                }
                            }
                            return null;
                        }

                        return createChainableTypeChecker(validate);
                    }

                    function isNode(propValue) {
                        switch (typeof propValue) {
                            case 'number':
                            case 'string':
                            case 'undefined':
                                return true;
                            case 'boolean':
                                return !propValue;
                            case 'object':
                                if (Array.isArray(propValue)) {
                                    return propValue.every(isNode);
                                }
                                if (propValue === null || isValidElement(propValue)) {
                                    return true;
                                }

                                var iteratorFn = getIteratorFn(propValue);
                                if (iteratorFn) {
                                    var iterator = iteratorFn.call(propValue);
                                    var step;
                                    if (iteratorFn !== propValue.entries) {
                                        while (!(step = iterator.next()).done) {
                                            if (!isNode(step.value)) {
                                                return false;
                                            }
                                        }
                                    } else {
                                        // Iterator will provide entry [k,v] tuples rather than values.
                                        while (!(step = iterator.next()).done) {
                                            var entry = step.value;
                                            if (entry) {
                                                if (!isNode(entry[1])) {
                                                    return false;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    return false;
                                }

                                return true;
                            default:
                                return false;
                        }
                    }

                    function isSymbol(propType, propValue) {
                        // Native Symbol.
                        if (propType === 'symbol') {
                            return true;
                        }

                        // falsy value can't be a Symbol
                        if (!propValue) {
                            return false;
                        }

                        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
                        if (propValue['@@toStringTag'] === 'Symbol') {
                            return true;
                        }

                        // Fallback for non-spec compliant Symbols which are polyfilled.
                        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
                            return true;
                        }

                        return false;
                    }

                    // Equivalent of `typeof` but with special handling for array and regexp.
                    function getPropType(propValue) {
                        var propType = typeof propValue;
                        if (Array.isArray(propValue)) {
                            return 'array';
                        }
                        if (propValue instanceof RegExp) {
                            // Old webkits (at least until Android 4.0) return 'function' rather than
                            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
                            // passes PropTypes.object.
                            return 'object';
                        }
                        if (isSymbol(propType, propValue)) {
                            return 'symbol';
                        }
                        return propType;
                    }

                    // This handles more types than `getPropType`. Only used for error messages.
                    // See `createPrimitiveTypeChecker`.
                    function getPreciseType(propValue) {
                        if (typeof propValue === 'undefined' || propValue === null) {
                            return '' + propValue;
                        }
                        var propType = getPropType(propValue);
                        if (propType === 'object') {
                            if (propValue instanceof Date) {
                                return 'date';
                            } else if (propValue instanceof RegExp) {
                                return 'regexp';
                            }
                        }
                        return propType;
                    }

                    // Returns a string that is postfixed to a warning about an invalid type.
                    // For example, "undefined" or "of type array"
                    function getPostfixForTypeWarning(value) {
                        var type = getPreciseType(value);
                        switch (type) {
                            case 'array':
                            case 'object':
                                return 'an ' + type;
                            case 'boolean':
                            case 'date':
                            case 'regexp':
                                return 'a ' + type;
                            default:
                                return type;
                        }
                    }

                    // Returns class name of the object, if any.
                    function getClassName(propValue) {
                        if (!propValue.constructor || !propValue.constructor.name) {
                            return ANONYMOUS;
                        }
                        return propValue.constructor.name;
                    }

                    ReactPropTypes.checkPropTypes = checkPropTypes_1;
                    ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
                    ReactPropTypes.PropTypes = ReactPropTypes;

                    return ReactPropTypes;
                };

                function emptyFunction() {}

                function emptyFunctionWithReset() {}
                emptyFunctionWithReset.resetWarningCache = emptyFunction;

                var factoryWithThrowingShims = function() {
                    function shim(props, propName, componentName, location, propFullName, secret) {
                        if (secret === ReactPropTypesSecret_1) {
                            // It is still safe when called from React.
                            return;
                        }
                        var err = new Error(
                            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                            'Use PropTypes.checkPropTypes() to call them. ' +
                            'Read more at http://fb.me/use-check-prop-types'
                        );
                        err.name = 'Invariant Violation';
                        throw err;
                    }
                    shim.isRequired = shim;

                    function getShim() {
                        return shim;
                    } // Important!
                    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
                    var ReactPropTypes = {
                        array: shim,
                        bigint: shim,
                        bool: shim,
                        func: shim,
                        number: shim,
                        object: shim,
                        string: shim,
                        symbol: shim,

                        any: shim,
                        arrayOf: getShim,
                        element: shim,
                        elementType: shim,
                        instanceOf: getShim,
                        node: shim,
                        objectOf: getShim,
                        oneOf: getShim,
                        oneOfType: getShim,
                        shape: getShim,
                        exact: getShim,

                        checkPropTypes: emptyFunctionWithReset,
                        resetWarningCache: emptyFunction
                    };

                    ReactPropTypes.PropTypes = ReactPropTypes;

                    return ReactPropTypes;
                };

                var propTypes = createCommonjsModule(function(module) {
                    /**
                     * Copyright (c) 2013-present, Facebook, Inc.
                     *
                     * This source code is licensed under the MIT license found in the
                     * LICENSE file in the root directory of this source tree.
                     */

                    if (false) {
                        var throwOnDirectAccess, ReactIs;
                    } else {
                        // By explicitly using `prop-types` you are opting into new production behavior.
                        // http://fb.me/prop-types-in-prod
                        module.exports = factoryWithThrowingShims();
                    }
                });

                var propTypes$1 = {
                    animationData: propTypes.object,
                    path: propTypes.string,
                    play: propTypes.bool,
                    goTo: propTypes.number,
                    speed: propTypes.number,
                    direction: propTypes.number,
                    loop: propTypes.oneOfType([propTypes.number, propTypes.bool]),
                    useSubframes: propTypes.bool,
                    segments: propTypes.oneOfType([propTypes.arrayOf(propTypes.number), propTypes.bool]),
                    rendererSettings: propTypes.object,
                    renderer: propTypes.string,
                    audioFactory: propTypes.func,
                    onComplete: propTypes.func,
                    onLoopComplete: propTypes.func,
                    onEnterFrame: propTypes.func,
                    onSegmentStart: propTypes.func
                };

                var emptyObject = {};

                var noOp = function noOp() {};

                var makeLottiePlayer = function makeLottiePlayer(_ref) {
                    var loadAnimation = _ref.loadAnimation;
                    var Lottie = (0, external_React_.memo)((0, external_React_.forwardRef)(function(params, forwardedRef) {
                        var _params$animationData = params.animationData,
                            animationData = _params$animationData === void 0 ? null : _params$animationData,
                            _params$path = params.path,
                            path = _params$path === void 0 ? null : _params$path,
                            _params$play = params.play,
                            play = _params$play === void 0 ? null : _params$play,
                            _params$speed = params.speed,
                            speed = _params$speed === void 0 ? 1 : _params$speed,
                            _params$direction = params.direction,
                            direction = _params$direction === void 0 ? 1 : _params$direction,
                            _params$segments = params.segments,
                            segmentsIn = _params$segments === void 0 ? null : _params$segments,
                            _params$goTo = params.goTo,
                            goTo = _params$goTo === void 0 ? null : _params$goTo,
                            _params$useSubframes = params.useSubframes,
                            useSubframes = _params$useSubframes === void 0 ? true : _params$useSubframes,
                            _params$renderer = params.renderer,
                            renderer = _params$renderer === void 0 ? 'svg' : _params$renderer,
                            _params$loop = params.loop,
                            loop = _params$loop === void 0 ? true : _params$loop,
                            _params$rendererSetti = params.rendererSettings,
                            rendererSettingsIn = _params$rendererSetti === void 0 ? emptyObject : _params$rendererSetti,
                            _params$audioFactory = params.audioFactory,
                            audioFactory = _params$audioFactory === void 0 ? null : _params$audioFactory,
                            _params$onLoad = params.onLoad,
                            onLoad = _params$onLoad === void 0 ? noOp : _params$onLoad,
                            _params$onComplete = params.onComplete,
                            onComplete = _params$onComplete === void 0 ? noOp : _params$onComplete,
                            _params$onLoopComplet = params.onLoopComplete,
                            onLoopComplete = _params$onLoopComplet === void 0 ? noOp : _params$onLoopComplet,
                            _params$onEnterFrame = params.onEnterFrame,
                            onEnterFrame = _params$onEnterFrame === void 0 ? noOp : _params$onEnterFrame,
                            _params$onSegmentStar = params.onSegmentStart,
                            onSegmentStart = _params$onSegmentStar === void 0 ? noOp : _params$onSegmentStar,
                            props = _objectWithoutPropertiesLoose(params, ["animationData", "path", "play", "speed", "direction", "segments", "goTo", "useSubframes", "renderer", "loop", "rendererSettings", "audioFactory", "onLoad", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart"]);

                        var animElementRef = (0, external_React_.useRef)();
                        var animRef = (0, external_React_.useRef)();

                        var _useState = (0, external_React_.useState)(false),
                            ready = _useState[0],
                            setReady = _useState[1];

                        var _useState2 = (0, external_React_.useState)(segmentsIn),
                            segments = _useState2[0],
                            setSegments = _useState2[1];

                        (0, external_React_.useEffect)(function() {
                            if (!react_default()(segments, segmentsIn)) setSegments(segmentsIn);
                        }, [segmentsIn, segments]);

                        var _useState3 = (0, external_React_.useState)(rendererSettingsIn),
                            rendererSettings = _useState3[0],
                            setRendererSettings = _useState3[1];

                        (0, external_React_.useEffect)(function() {
                            if (!react_default()(rendererSettings, rendererSettingsIn)) setRendererSettings(rendererSettingsIn);
                        }, [rendererSettingsIn, rendererSettings]);
                        (0, external_React_.useEffect)(function() {
                            return function() {
                                return animRef.current.removeEventListener('complete', onComplete);
                            };
                        }, [onComplete]);
                        (0, external_React_.useEffect)(function() {
                            return function() {
                                return animRef.current.removeEventListener('loopComplete', onLoopComplete);
                            };
                        }, [onLoopComplete]);
                        (0, external_React_.useEffect)(function() {
                            return function() {
                                return animRef.current.removeEventListener('enterFrame', onEnterFrame);
                            };
                        }, [onEnterFrame]);
                        (0, external_React_.useEffect)(function() {
                            return function() {
                                return animRef.current.removeEventListener('segmentStart', onSegmentStart);
                            };
                        }, [onSegmentStart]);
                        (0, external_React_.useEffect)(function() {
                            return function() {
                                return animRef.current.removeEventListener('DOMLoaded', onLoad);
                            };
                        }, [onLoad]);
                        var setLottieRefs = (0, external_React_.useCallback)(function(newRef) {
                            animRef.current = newRef;

                            if (typeof forwardedRef === 'function') {
                                forwardedRef(newRef);
                            } else if (forwardedRef !== undefined && forwardedRef !== null) {
                                forwardedRef.current = newRef;
                            }
                        }, [forwardedRef]);
                        (0, external_React_.useEffect)(function() {
                            function parseAnimationData() {
                                if (animationData == null || typeof animationData !== 'object') return animationData;

                                if (typeof animationData["default"] === 'object') {
                                    return default_default()(animationData["default"]);
                                }

                                return default_default()(animationData);
                            }

                            var lottie = loadAnimation({
                                animationData: parseAnimationData(),
                                path: path,
                                container: animElementRef.current,
                                renderer: renderer,
                                loop: false,
                                autoplay: false,
                                rendererSettings: rendererSettings,
                                audioFactory: audioFactory
                            });
                            setLottieRefs(lottie);

                            var onDomLoaded = function onDomLoaded() {
                                return setReady(true);
                            };

                            animRef.current.addEventListener('DOMLoaded', onDomLoaded);
                            return function() {
                                animRef.current.removeEventListener('DOMLoaded', onDomLoaded);
                                setReady(false);
                                animRef.current.destroy();
                                setLottieRefs(undefined);
                            };
                        }, [loop, renderer, rendererSettings, animationData, path, audioFactory, setLottieRefs]);
                        (0, external_React_.useEffect)(function() {
                            animRef.current.addEventListener('DOMLoaded', onLoad);
                        }, [onLoad]);
                        (0, external_React_.useEffect)(function() {
                            animRef.current.addEventListener('complete', onComplete);
                        }, [onComplete]);
                        (0, external_React_.useEffect)(function() {
                            animRef.current.addEventListener('loopComplete', onLoopComplete);
                        }, [onLoopComplete]);
                        (0, external_React_.useEffect)(function() {
                            animRef.current.addEventListener('enterFrame', onEnterFrame);
                        }, [onEnterFrame]);
                        (0, external_React_.useEffect)(function() {
                            animRef.current.addEventListener('segmentStart', onSegmentStart);
                        }, [onSegmentStart]);
                        (0, external_React_.useEffect)(function() {
                            if (!ready) return;
                            animRef.current.loop = loop;
                        }, [ready, loop]);
                        var wasPlayingSegmentsRef = (0, external_React_.useRef)(false);
                        (0, external_React_.useEffect)(function() {
                            if (!ready) return;

                            function playReverse(lastFrame) {
                                animRef.current.goToAndPlay(lastFrame, true);
                                animRef.current.setDirection(direction);
                            }

                            if (play === true) {
                                var force = true;

                                if (segments) {
                                    animRef.current.playSegments(segments, force);
                                    wasPlayingSegmentsRef.current = true;

                                    if (direction === -1) {
                                        var lastFrame = segments[1];
                                        playReverse(lastFrame);
                                    }
                                } else {
                                    if (wasPlayingSegmentsRef.current) animRef.current.resetSegments(force);
                                    wasPlayingSegmentsRef.current = false;

                                    if (direction === -1) {
                                        var _lastFrame = animRef.current.getDuration(true);

                                        playReverse(_lastFrame);
                                    } else {
                                        animRef.current.play();
                                    }
                                }
                            } else if (play === false) {
                                animRef.current.pause();
                            }
                        }, [play, segments, ready, direction]);
                        (0, external_React_.useEffect)(function() {
                            if (!ready) return;
                            if (Number.isNaN(speed)) return;
                            animRef.current.setSpeed(speed);
                        }, [speed, ready]);
                        (0, external_React_.useEffect)(function() {
                            if (!ready) return;
                            animRef.current.setDirection(direction);
                        }, [direction, ready]);
                        (0, external_React_.useEffect)(function() {
                            if (!ready) return;
                            if (goTo == null) return;
                            var isFrame = true;
                            if (play) animRef.current.goToAndPlay(goTo, isFrame);
                            else animRef.current.goToAndStop(goTo, isFrame);
                        }, [goTo, play, ready]);
                        (0, external_React_.useEffect)(function() {
                            if (animRef.current.setSubframe) animRef.current.setSubframe(useSubframes);
                        }, [useSubframes]);
                        return /*#__PURE__*/ external_React_default().createElement("div", _extends({}, props, {
                            ref: animElementRef
                        }));
                    }));
                    Lottie.propTypes = propTypes$1;
                    return Lottie;
                };

                var LottiePlayer = makeLottiePlayer((lottie_default()));

                /* harmony default export */
                const LottiePlayer_modern = (LottiePlayer);

                ; // CONCATENATED MODULE: ./src/routes/defiwallet/lottie/animate.json
                const animate_namespaceObject = JSON.parse('{"v":"4.8.0","meta":{"g":"LottieFiles AE 3.4.5","a":"","k":"","d":"","tc":""},"fr":25,"ip":0,"op":151,"w":1970,"h":1970,"nm":"Coinstorm__Mobile_01","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Eth classic","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-35]},{"t":150,"s":[153.879]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[617.5,783,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[1531.5,1275,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[167.697,167.697,100]},{"t":150,"s":[156.268,156.268,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.915,-23.783],[10.825,-43.077],[31.464,-12.809]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[10.916,-23.783],[-9.8,-12.874],[10.826,-43.077],[31.465,-12.809]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.003921568859,0.784313738346,0.32549020648,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[6.913,-10.181]],"o":[[0,0],[-7.441,11.058],[0,0]],"v":[[10.919,4.357],[31.472,-6.67],[10.919,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[-7.441,11.058],[0,0]],"v":[[10.919,4.357],[31.472,-6.67],[10.919,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[6.153,9.066],[-5.868,-3.127],[0,0],[6.913,-10.181]],"o":[[7.274,3.858],[0,0],[-7.441,11.058],[-6.921,-10.159]],"v":[[-9.804,-6.673],[10.918,4.357],[31.471,-6.669],[10.918,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.003921568859,0.784313738346,0.32549020648,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[6.153,9.066],[-5.868,-3.127],[0,0],[6.913,-10.181]],"o":[[7.274,3.858],[0,0],[-7.441,11.058],[-6.921,-10.159]],"v":[[-9.804,-6.673],[10.918,4.357],[31.471,-6.669],[10.918,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[10.966,-7.92],[-9.8,-9.62],[10.949,1.391],[10.966,-7.92]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[10.966,-7.92],[31.464,-9.7],[10.984,1.392],[10.966,-7.92]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.470588237047,0.192156866193,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.966,-20.702],[31.464,-9.7],[10.984,1.391]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-9.8,-9.62],[10.967,-20.702],[31.465,-9.7],[10.984,1.391]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.003921568859,0.784313738346,0.32549020648,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":2,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-9.8,-9.62],[10.967,-20.702],[31.465,-9.7],[10.984,1.391]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":2,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,-26.51],[26.51,0],[0,26.51]],"o":[[26.51,0],[0,26.51],[-26.51,0],[0,-26.51]],"v":[[11.321,-57.477],[59.321,-9.477],[11.321,38.523],[-36.679,-9.477]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019610882,0.949019610882,0.949019610882,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 12","np":2,"cix":2,"bm":0,"ix":12,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Venus","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[47.698]},{"t":150,"s":[36.016]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1553,1781,0],"to":[-845.167,11,0],"ti":[0,0,0]},{"t":150,"s":[466,1031,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[222.904,222.904,100]},{"t":150,"s":[124.395,124.395,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.044,-0.603],[0.487,-1.246],[-0.905,-1.165],[-1.81,-0.723],[-2.227,0],[-1.81,0.723],[-0.835,1.206],[0.418,1.286],[1.601,0.924],[1.392,0.322],[1.462,-0.04],[1.392,-0.322]],"o":[[-1.601,0.924],[-0.418,1.286],[0.835,1.206],[1.81,0.723],[2.227,0],[1.81,-0.723],[0.835,-1.206],[-0.418,-1.286],[-1.044,-0.603],[-1.392,-0.322],[-1.531,0],[-1.253,0.322]],"v":[[-40.378,-19.194],[-43.51,-15.859],[-42.814,-12.081],[-38.707,-9.148],[-32.443,-8.023],[-26.179,-9.148],[-22.072,-12.081],[-21.376,-15.859],[-24.508,-19.194],[-28.197,-20.601],[-32.513,-21.083],[-36.828,-20.601]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[1.114,-0.643],[0,0],[0,0],[0,0],[0,0],[-0.07,0.04],[-0.974,0],[-0.835,-0.241],[-0.626,-0.362],[-0.209,-0.522],[0,0],[0.209,-0.523],[0.557,-0.482],[0.835,-0.241],[0.974,-0.08],[0.07,0.04],[0,0],[0.07,-0.04],[0,0],[0,0],[-1.461,0.201],[-1.114,0.643],[-0.417,0.884],[0.348,0.844],[0,0],[1.114,0.643],[1.532,0.241],[1.461,-0.201]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.835,-0.241],[0.974,0],[0.835,0.241],[0.626,0.442],[0,0],[0.279,0.563],[-0.139,0.563],[-0.556,0.482],[-0.836,0.241],[0,0],[0,0],[0,0],[0,0],[0,0],[1.461,0.201],[1.462,-0.201],[1.044,-0.603],[0.418,-0.884],[0,0],[-0.348,-0.844],[-1.044,-0.603],[-1.461,-0.201],[-1.392,0.241]],"v":[[-8.29,-37.72],[-17.548,-32.375],[-17.617,-32.335],[-17.548,-32.295],[-17.478,-32.255],[-17.408,-32.295],[-14.624,-32.616],[-11.91,-32.255],[-9.682,-31.29],[-8.43,-29.844],[1.384,-8.585],[1.454,-6.938],[0.34,-5.411],[-1.817,-4.326],[-4.601,-3.843],[-4.741,-3.843],[-4.81,-3.803],[-4.81,-3.723],[-4.741,-3.683],[8.206,-1.673],[12.66,-1.673],[16.558,-2.959],[18.785,-5.21],[18.785,-7.782],[6.117,-35.51],[3.89,-37.76],[-0.008,-39.046],[-4.462,-39.046]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[-0.696,-1.286],[0,0],[0.627,-1.246],[1.601,-0.924],[2.228,-0.322],[2.158,0.362],[0,0],[0,0],[-0.069,0.04],[0,0],[-0.069,-0.04],[-1.462,0.442],[-1.044,0.763],[-0.279,0.964],[0.418,0.884],[0,0],[1.044,0.764],[1.531,0.402],[1.6,-0.04],[1.461,-0.442],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.227,0.322],[-2.158,-0.362],[-1.601,-0.924]],"o":[[0,0],[0.557,1.286],[-0.557,1.286],[-1.601,0.924],[-2.227,0.321],[0,0],[0,0],[0,0],[0,0],[0,0],[1.671,0],[1.462,-0.442],[1.044,-0.764],[0.348,-0.924],[0,0],[-0.487,-0.924],[-1.114,-0.723],[-1.601,-0.362],[-1.671,0.08],[0,0],[0,0],[0,0],[0,0],[0,0],[1.601,-0.924],[2.227,-0.322],[2.227,0.322],[1.253,1.045]],"v":[[37.23,-48.008],[56.789,-5.853],[56.789,-1.995],[53.448,1.381],[47.601,3.31],[40.919,3.31],[28.182,1.341],[28.112,1.3],[28.112,1.22],[28.182,1.18],[28.321,1.18],[33.124,0.497],[36.952,-1.312],[38.971,-3.924],[38.831,-6.737],[22.405,-42.02],[20.108,-44.552],[16.071,-46.239],[11.199,-46.722],[6.466,-45.918],[6.396,-45.878],[6.326,-45.918],[6.257,-45.958],[6.326,-45.998],[15.792,-51.464],[21.639,-53.393],[28.321,-53.393],[34.168,-51.464]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0,0.271,0.302,0.612,0.25,0.275,0.512,0.765,0.5,0.278,0.722,0.918,0.75,0.394,0.741,0.729,1,0.51,0.761,0.541],"ix":9}},"s":{"a":0,"k":[88.957,-12.992],"ix":5},"e":{"a":0,"k":[-74.671,-15.936],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-18.444,10.649],[0,0],[-18.444,-10.649],[0,0],[18.444,-10.649],[0,0],[18.444,10.649],[0,0]],"o":[[0,0],[18.444,-10.649],[0,0],[18.444,10.649],[0,0],[-18.444,10.649],[0,0],[-18.444,-10.649]],"v":[[-69.644,-36.306],[-22.075,-63.77],[44.718,-63.77],[92.286,-36.306],[92.286,2.257],[44.718,29.721],[-22.075,29.721],[-69.644,2.257]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.075,0.086,0.122,0.5,0.237,0.243,0.261,1,0.4,0.4,0.4],"ix":9}},"s":{"a":0,"k":[-711.337,-1293.708],"ix":5},"e":{"a":0,"k":[-777.364,-1408.069],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-9.389,-5.421],[0,0],[-18.445,10.649],[0,0],[0.121,7.069],[0,0],[0,0],[2.544,1.469],[0,0],[18.444,-10.649],[0,0],[1.842,-1.686],[0,0]],"o":[[-0.17,7.104],[0,0],[18.444,10.649],[0,0],[9.342,-5.394],[0,0],[0,0],[-1.842,-1.686],[0,0],[-18.445,-10.649],[0,0],[-2.544,1.469],[0,0],[0,0]],"v":[[-83.477,-2.308],[-69.648,17.352],[-22.08,44.815],[44.713,44.815],[92.281,17.352],[106.112,-2.202],[106.112,-16.462],[98.86,-16.462],[92.281,-21.211],[44.713,-48.675],[-22.08,-48.675],[-69.648,-21.211],[-76.228,-16.462],[-83.477,-16.462]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0.043,0.412,0.412,0.412,0.309,0.243,0.249,0.267,0.575,0.075,0.086,0.122,0.788,0.237,0.243,0.261,1,0.4,0.4,0.4],"ix":9}},"s":{"a":0,"k":[-520,-556.859],"ix":5},"e":{"a":0,"k":[-781.037,-533.344],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Lido","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-173.362]},{"t":150,"s":[13.909]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1304,703,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[354,301,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[185.552,185.552,100]},{"t":150,"s":[193.796,193.796,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[1.271,-4.778],[5.755,-19.685],[-33.805,-18.58]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.409,1,0.498,0.447,0.704,0.58,0.484,0.692,1,0.161,0.471,0.937,0.409,1,0.704,0.85,1,0.7],"ix":9}},"s":{"a":0,"k":[-35.551,-20.41],"ix":5},"e":{"a":0,"k":[8.314,-14.092],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-33.795,-18.574],[-22.247,2.641],[1.268,-4.777]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.377,1,0.89,0.212,0.689,0.537,0.822,0.463,1,0.075,0.753,0.714,0.377,1,0.689,0.85,1,0.7],"ix":9}},"s":{"a":0,"k":[103.938,-21.058],"ix":5},"e":{"a":0,"k":[-71.586,-164.115],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-15.271,-11.309],[-20.4,6.046],[6.88,-2.549],[12.077,-19.852]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.337,0.949,1,0.5,0.337,0.775,0.963,1,0.337,0.6,0.925],"ix":9}},"s":{"a":0,"k":[-3.806,-7.011],"ix":5},"e":{"a":0,"k":[8.217,-1.744],"ix":6},"t":2,"h":{"a":0,"k":0,"ix":7},"a":{"a":0,"k":0,"ix":8},"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-17.774,-12.272],[-22.247,2.64],[1.269,-4.779],[5.744,-19.678]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.933,1,0.514,0.345,0.635,0.8,0.72,0.69,0.337,0.6,0.925],"ix":9}},"s":{"a":0,"k":[-0.19,24.677],"ix":5},"e":{"a":0,"k":[36.46,-8.739],"ix":6},"t":2,"h":{"a":0,"k":0,"ix":7},"a":{"a":0,"k":0,"ix":8},"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":60,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-14.234,2.224],[1.284,9.714],[14.135,-0.395],[0,0]],"o":[[0,0],[0,0],[4.13,7.582],[16.75,-2.617],[-1.092,-8.255],[0,0],[0,0]],"v":[[6.866,-2.551],[-20.416,6.054],[-20.05,6.726],[11.392,15.9],[39.395,-6.427],[13.324,-19.884],[12.071,-19.849]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.204,0.337,0.949,1,0.602,0.314,0.749,0.959,1,0.29,0.549,0.918],"ix":9}},"s":{"a":0,"k":[37.89,10.987],"ix":5},"e":{"a":0,"k":[4.308,-4.062],"ix":6},"t":2,"h":{"a":0,"k":0,"ix":7},"a":{"a":0,"k":0,"ix":8},"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-7.269,5.796],[0,0],[-8.651,-3.404],[0,0],[7.269,-5.796],[0,0],[8.651,3.404],[0,0]],"o":[[0,0],[7.269,-5.796],[0,0],[8.651,3.404],[0,0],[-7.269,5.796],[0,0],[-8.651,-3.404]],"v":[[-72.176,-3.383],[-21.334,-43.92],[7.491,-48.25],[67.999,-24.442],[70.501,-7.784],[19.659,32.753],[-9.166,37.083],[-69.673,13.274]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,1,1,1,0.5,0.951,0.955,0.959,1,0.902,0.91,0.918],"ix":9}},"s":{"a":0,"k":[-650.476,-1343.406],"ix":5},"e":{"a":0,"k":[-712.001,-1420.57],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-8.65,-3.403],[0,0],[-7.27,5.796],[0,0],[8.65,3.403],[0,0],[0,0],[0,0],[0,0],[7.27,-5.796],[0,0],[0,0],[0,0]],"o":[[-7.27,5.796],[0,0],[8.65,3.403],[0,0],[7.269,-5.796],[0,0],[0,0],[0,0],[0,0],[-8.65,-3.403],[0,0],[0,0],[0,0],[0,0]],"v":[[-70.499,7.798],[-67.999,24.454],[-7.505,48.251],[21.321,43.917],[72.176,3.367],[69.676,-13.289],[69.628,-13.309],[69.27,-15.691],[65.147,-15.071],[9.182,-37.086],[-19.644,-32.752],[-66.671,4.746],[-70.816,5.369],[-70.457,7.764]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.827450990677,0.827450990677,0.827450990677,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"Klaytan","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-220.193]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[323,373,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[1385,1149,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[134,134,100]},{"t":150,"s":[100,100,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-6.303,-6.745],[0,0]],"o":[[0,7.741],[0,0],[0,0]],"v":[[-33.653,-0.166],[-24.586,22.835],[-1.806,-32.013]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-0.591,-1.161],[22.963,-24.715],[1.289,-33.672],[-20.495,18.854]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.296,1.382],[-22.483,24.272],[0.186,33.671],[23.076,24.272]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,8.072],[5.861,6.303]],"o":[[0,0],[6.192,-6.635],[0,-8.625],[0,0]],"v":[[1.953,-0.277],[25.064,22.724],[34.021,-0.277],[24.954,-23.388]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,-26.51],[26.51,0],[0,26.51]],"o":[[26.51,0],[0,26.51],[-26.51,0],[0,-26.51]],"v":[[0,-48],[48,0],[0,48],[-48,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"CFX","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[108.104]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[537,1195,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[585,1365,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[115.98,115.98,100]},{"t":150,"s":[85.632,85.632,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[24.375,-20.784],[-1.16,-46.32],[-26.767,-20.713],[-26.685,-8.744],[-1.268,-34.16],[24.333,-8.558]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.219607844949,0.631372570992,0.858823537827,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[12.311,-8.564],[-1.209,4.956],[-8.733,-2.569],[4.786,-16.088],[-1.226,-22.101],[-20.824,-2.504],[-1.28,17.04],[18.317,-2.558]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.101960785687,0.101960785687,0.101960785687,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,-26.51],[26.51,0],[0,26.51]],"o":[[26.51,0],[0,26.51],[-26.51,0],[0,-26.51]],"v":[[-1.087,-62.64],[46.913,-14.64],[-1.087,33.36],[-49.087,-14.64]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"ACA","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-61.536]},{"t":150,"s":[-13.464]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1004,358,0],"to":[-590.333,671.667,0],"ti":[0,0,0]},{"t":150,"s":[1638,1542,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[198.851,198.851,100]},{"t":150,"s":[139.762,139.762,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-3.165,0],[-0.256,-0.01],[-1.767,-0.327],[0,0],[2.997,0.008],[3.848,-2.065],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[2.851,-0.86],[0.256,0],[1.797,0.043],[0,0],[-2.812,-1.036],[-4.367,-0.015],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-2.265,-19.557],[-10.231,-5.755],[-0.861,-6.999],[-0.092,-6.99],[5.263,-6.434],[7.921,-1.829],[-0.861,-3.407],[-13.378,-0.284],[-13.319,-0.388],[-13.399,-0.25],[-17.56,-0.25],[-4.331,-23.16]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[16.987,-2.537],[19.067,-6.14],[1.749,-36.136],[-2.411,-36.136]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[1.498,-0.254],[0,0],[-0.755,0],[-1.753,-0.281],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[2.638,-0.008]],"o":[[-1.52,-0.001],[0,0],[0.761,-0.051],[1.776,0.001],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.527,-0.757],[0,0]],"v":[[-0.934,-9.488],[-5.469,-9.109],[-3.211,-13.009],[-0.934,-13.086],[4.368,-12.662],[-4.371,-27.797],[-18.926,-2.596],[-21.006,-6.199],[-4.404,-34.955],[-4.371,-34.896],[-4.337,-34.953],[15.699,-0.25],[11.539,-0.25],[6.856,-8.36],[-0.934,-9.49]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[6.126,0],[0,0],[5.809,5.808],[0,8.214],[-3.403,5.093],[-5.659,2.344],[-6.008,-1.195],[-4.331,-4.331],[-1.195,-6.008],[2.344,-5.659],[5.093,-3.403]],"o":[[0,0],[-8.214,0],[-5.808,-5.809],[0,-6.125],[3.403,-5.093],[5.66,-2.344],[6.008,1.195],[4.331,4.332],[1.195,6.008],[-2.344,5.659],[-5.093,3.403]],"v":[[-1.003,16.249],[-1.003,16.247],[-22.904,7.176],[-31.975,-14.725],[-26.754,-31.931],[-12.854,-43.338],[5.04,-45.099],[20.898,-36.622],[29.374,-20.764],[27.611,-2.87],[16.204,11.03]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[-5.785,3.865],[-2.662,6.427],[1.357,6.823],[4.919,4.919],[6.824,1.357],[6.428,-2.662],[3.865,-5.785],[0,-6.957],[-6.597,-6.596],[-9.329,0]],"o":[[6.957,0],[5.785,-3.865],[2.663,-6.428],[-1.357,-6.823],[-4.92,-4.919],[-6.823,-1.357],[-6.427,2.662],[-3.865,5.785],[0.001,9.329],[6.597,6.596],[0,0]],"v":[[-1.088,20.538],[18.455,14.61],[31.41,-1.177],[33.412,-21.5],[23.785,-39.511],[5.774,-49.138],[-14.549,-47.136],[-30.335,-34.18],[-36.263,-14.638],[-25.96,10.234],[-1.088,20.536]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[21.038,0],[0,0],[0,21.044],[-21.038,0],[0,-21.038]],"o":[[0,0],[-21.038,0],[0,-21.044],[21.038,0],[0,21.038]],"v":[[-0.916,23.456],[-0.916,23.454],[-39.01,-14.64],[-0.916,-52.732],[37.175,-14.638]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[-23.219,0],[0,23.219],[23.217,0],[0,-23.213]],"o":[[23.217,0],[0,-23.219],[-23.217,0],[0,23.213]],"v":[[-1.088,27.399],[40.951,-14.64],[-1.088,-56.679],[-43.127,-14.64]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0.01,0.392,0.353,1,0.255,0.643,0.2,0.678,0.5,0.894,0.047,0.357,0.75,0.947,0.173,0.294,1,1,0.298,0.231],"ix":9}},"s":{"a":0,"k":[35.367,22.364],"ix":5},"e":{"a":0,"k":[-36.657,-54.727],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":8,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,26.51],[26.51,0],[0,-26.51]],"o":[[26.51,0],[0,-26.51],[-26.51,0],[0,26.51]],"v":[[-1.087,33.36],[46.913,-14.64],[-1.087,-62.64],[-49.087,-14.64]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"Apollo finance","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-35.802]},{"t":150,"s":[14.591]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[718,1356.5,0],"to":[-317.333,-290.333,0],"ti":[0,0,0]},{"t":150,"s":[674,574.5,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[102.062,102.062,100]},{"t":150,"s":[157.559,157.559,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.613,-5.583],[-6.936,-4.005],[-6.85,-1.329],[14.742,10.918]],"o":[[1.613,5.583],[5.11,2.952],[-3.049,-13.724],[-4.313,5.078]],"v":[[-46.652,-2.879],[-33.508,11.864],[-15.322,18.374],[-42.5,-19.272]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-0.042,-0.024],[0,0],[-0.015,-0.034],[0.015,-0.032],[0,0],[0.041,-0.023],[0.057,-0.008],[0.057,0.01],[0.042,0.024],[0,0],[0.016,0.033],[-0.013,0.032],[0,0],[-0.041,0.023],[-0.057,0.008],[-0.057,-0.01]],"o":[[0,0],[0.042,0.025],[0.016,0.033],[0,0],[-0.014,0.033],[-0.04,0.023],[-0.056,0.008],[-0.057,-0.01],[0,0],[-0.042,-0.025],[-0.016,-0.033],[0,0],[0.014,-0.033],[0.04,-0.023],[0.056,-0.008],[0.057,0.01]],"v":[[-11.669,20.612],[-7.55,22.99],[-7.462,23.079],[-7.461,23.18],[-8.923,26.432],[-9.006,26.517],[-9.153,26.565],[-9.325,26.562],[-9.476,26.51],[-13.595,24.132],[-13.684,24.045],[-13.689,23.946],[-12.223,20.691],[-12.139,20.606],[-11.992,20.558],[-11.82,20.561]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[6.051,0.686],[-3.179,9.423],[-11.462,6.949],[-5.14,-1.97],[-3.445,-2.954],[-1.227,-3.489],[1.179,-3.492],[3.405,-2.964],[5.112,-1.985],[6.041,-0.703]],"o":[[-6.102,-8.939],[3.179,-9.424],[6.052,0.686],[5.139,1.97],[3.446,2.955],[1.227,3.489],[-1.178,3.492],[-3.404,2.964],[-5.112,1.984],[-6.042,0.703]],"v":[[-9.716,19.246],[-14.191,-8.873],[8.229,-33.944],[25.18,-29.92],[38.183,-22.461],[45.261,-12.701],[45.334,-2.126],[38.393,7.653],[25.494,15.149],[8.601,19.22]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[16.173,-9.337],[0,0],[16.173,9.337],[0,0],[-16.173,9.337],[0,0],[-16.173,-9.337],[0,0]],"o":[[0,0],[-16.173,9.337],[0,0],[-16.173,-9.337],[0,0],[16.173,-9.337],[0,0],[16.173,9.337]],"v":[[70.994,10.287],[29.283,34.368],[-29.283,34.368],[-70.994,10.287],[-70.994,-23.527],[-29.283,-47.608],[29.283,-47.608],[70.994,-23.527]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.404,0.286,1,0.5,0.518,0.269,0.996,1,0.631,0.251,0.992],"ix":9}},"s":{"a":0,"k":[64.039,39.985],"ix":5},"e":{"a":0,"k":[-51.902,-48.258],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.232,1.289],[0,0],[16.173,-9.337],[0,0],[1.616,-1.479],[0,0],[0,0],[-8.248,-4.762],[0,0],[-16.173,9.337],[0,0],[0.143,6.225],[0,0],[0,0]],"o":[[-1.616,-1.479],[0,0],[-16.173,-9.337],[0,0],[-2.233,1.289],[0,0],[0,0],[-0.164,6.24],[0,0],[16.173,9.337],[0,0],[8.227,-4.75],[0,0],[0,0],[0,0]],"v":[[76.768,-6.118],[70.995,-10.286],[29.285,-34.367],[-29.282,-34.367],[-70.992,-10.286],[-76.765,-6.118],[-83.117,-6.118],[-83.117,6.255],[-70.992,23.528],[-29.282,47.609],[29.285,47.609],[70.995,23.528],[83.121,6.302],[83.123,6.302],[83.123,-6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.318,0.224,0.784,0.5,0.427,0.245,0.79,1,0.537,0.267,0.796],"ix":9}},"s":{"a":0,"k":[-85.457,8.874],"ix":5},"e":{"a":0,"k":[87.572,17.04],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"Layer 1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[195.195]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1303,1006,0],"to":[-493.333,-101.667,0],"ti":[573.333,355.667,0]},{"t":150,"s":[819,1134,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[239.583,239.583,100]},{"t":150,"s":[118.75,118.75,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.547,0],[0,1.65],[1.547,0],[0,-1.65]],"o":[[1.547,0],[0,-1.65],[-1.547,0],[0,1.65]],"v":[[-5.839,30.937],[-3.038,27.948],[-5.839,24.96],[-8.641,27.948]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.547,0],[0,1.65],[1.547,0],[0,-1.65]],"o":[[1.547,0],[0,-1.65],[-1.547,0],[0,1.65]],"v":[[-26.96,-5.543],[-24.159,-8.531],[-26.96,-11.52],[-29.762,-8.531]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.547,0],[0,1.65],[1.547,0],[0,-1.65]],"o":[[1.547,0],[0,-1.65],[-1.547,0],[0,1.65]],"v":[[20.083,-16.104],[22.884,-19.092],[20.083,-22.08],[17.281,-19.092]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-2.682,0],[0,2.682],[2.682,0],[0,-2.682]],"o":[[2.682,0],[0,-2.682],[-2.682,0],[0,2.682]],"v":[[0.055,4.912],[4.911,0.056],[0.055,-4.8],[-4.801,0.056]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0.187],[0,0],[0,0],[0,0],[-0.56,-1.681],[0.374,-0.187],[0,0],[0,0],[0,0]],"o":[[-0.374,-0.934],[3.549,-0.747],[13.821,3.175],[18.864,13.261],[0,0.374],[-2.055,0.934],[-16.249,-4.296],[-11.58,-6.35],[-8.778,-7.471]],"v":[[-34.489,-19.069],[-34.116,-20.189],[-25.524,-19.255],[12.764,-0.765],[34.99,19.966],[34.616,20.9],[27.332,20.527],[-1.804,8.2],[-24.964,-7.863]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-2.428,4.482],[19.984,11.58],[2.615,-4.482],[-20.171,-11.58]],"o":[[2.615,-4.482],[-19.984,-11.58],[-2.615,4.482],[19.984,11.58]],"v":[[36.484,21.46],[4.919,-7.676],[-36.17,-20.563],[-4.419,8.573]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.435294121504,0.450980395079,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":3,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-1.681,-0.56],[0,-0.374],[0,0],[0,0],[0,0]],"o":[[-0.934,-0.187],[1.121,-3.362],[9.525,-10.272],[20.918,-9.712],[0.373,0.187],[-0.187,2.241],[-11.953,11.953],[-11.393,6.911],[-10.833,3.922]],"v":[[-33.929,20.716],[-34.676,19.782],[-29.633,12.684],[5.48,-11.222],[34.429,-20],[34.99,-19.253],[31.067,-13.277],[5.853,5.774],[-19.548,17.914]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[2.615,4.482],[20.171,-11.393],[-2.615,-4.482],[-20.171,11.393]],"o":[[-2.615,-4.482],[-20.171,11.58],[2.615,4.482],[20.171,-11.58]],"v":[[36.67,-20.561],[-4.419,-7.86],[-36.17,21.276],[4.919,8.576]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.435294121504,0.450980395079,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-1.121,1.121],[-0.187,-0.374],[0,0],[0,0],[0,0]],"o":[[-0.56,0.747],[-2.428,-2.802],[-4.109,-13.448],[2.055,-22.973],[0.187,-0.187],[1.681,1.307],[4.296,16.249],[0.373,13.261],[-1.868,11.393]],"v":[[0.297,39.378],[-0.823,39.565],[-4.372,31.721],[-7.547,-10.676],[-0.823,-40.186],[0.111,-40.186],[3.286,-33.649],[7.208,-2.271],[4.967,25.744]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[5.043,0],[0,-23.16],[-5.043,0],[0,23.16]],"o":[[-5.23,0],[0,23.16],[5.043,0],[0,-23.16]],"v":[[-0.263,-42.24],[-9.602,-0.217],[-0.263,41.807],[9.076,-0.217]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.435294121504,0.450980395079,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":3,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-15.369,0],[0,15.37],[15.369,0],[0,-15.369]],"o":[[15.369,0],[0,-15.369],[-15.369,0],[0,15.37]],"v":[[-0.011,27.818],[27.818,-0.011],[-0.011,-27.84],[-27.84,-0.011]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105882354081,0.117647059262,0.211764708161,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,26.51],[26.51,0],[0,-26.51]],"o":[[26.51,0],[0,-26.51],[-26.51,0],[0,26.51]],"v":[[0,48],[48,0],[0,-48],[-48,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.180392161012,0.192156866193,0.282352954149,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"Kava","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-57.061]},{"t":150,"s":[-11.31]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1206,368,0],"to":[153,526.333,0],"ti":[0,0,0]},{"t":150,"s":[1132.386,1042.564,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[162.998,162.998,100]},{"t":150,"s":[125,125,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[13.755,27.73],[-7.461,0],[13.755,-27.729],[25.878,-27.729],[4.977,0],[25.878,27.73]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-12.707,27.743],[-12.707,-27.717],[-22.39,-27.717],[-22.39,27.743]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,26.51],[26.51,0],[0,-26.51]],"o":[[26.51,0],[0,-26.51],[-26.51,0],[0,26.51]],"v":[[0,48],[48,0],[0,-48],[-48,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.337254911661,0.309803932905,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":10,"ty":4,"nm":"Neutron","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-159.564]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[985.5,1244,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[1222.5,1454,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[129.004,129.004,100]},{"t":150,"s":[67.708,67.708,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-6.796,0],[-1.882,1.168],[0,0],[0,0],[0,0],[0,0],[0,-2.364]],"o":[[2.377,0],[0,0],[0,0],[0,0],[0,0],[-1.155,1.875],[0,6.796]],"v":[[-0.094,12.212],[6.384,10.371],[19.294,25.594],[-25.781,25.594],[-25.781,-19.649],[-10.578,-6.54],[-12.4,-0.094]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[2.157,-1.866],[0,0],[0,0],[0,0],[0,0],[0,3.024],[6.796,0]],"o":[[0,0],[0,0],[0,0],[0,0],[1.809,-2.142],[0,-6.796],[-3.076,0]],"v":[[-8.14,-9.405],[-22.026,-25.781],[25.594,-25.781],[25.594,21.921],[9.312,7.841],[12.212,-0.094],[-0.094,-12.4]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":1.249,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,26.51],[26.51,0],[0,-26.51],[-26.51,0]],"o":[[0,-26.51],[-26.51,0],[0,26.51],[26.51,0]],"v":[[48,0],[0,-48],[-48,0],[0,48]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.04705882445,0.04705882445,0.04705882445,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":11,"ty":3,"nm":"Null 25","parent":13,"sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[57.514]},{"t":150,"s":[110.514]}],"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":12,"ty":3,"nm":"Null 24","parent":13,"sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[112]},{"t":150,"s":[37]}],"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":13,"ty":3,"nm":"Null 22","sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[0]}],"ix":10},"p":{"a":0,"k":[985,985,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":14,"ty":3,"nm":"Null 23","parent":13,"sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[112]},{"t":150,"s":[143]}],"ix":10},"p":{"a":0,"k":[13.486,-33.379,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":16,"ty":4,"nm":"Uniswap","parent":14,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":0,"k":[-330.449,615.615,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.423,1.482],[1.615,-0.027],[-0.464,-3.266],[-1.963,1.538]],"o":[[0.608,-2.159],[-3.017,0.063],[0.226,1.593],[1.394,-1.092]],"v":[[8.774,-3.915],[7.224,-7.392],[0.729,0.885],[5.32,1.005]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[1.429,-1.828],[0.222,-3.891],[-0.78,-0.539],[-2.786,2.184],[-0.049,4.111],[3.11,-0.402]],"o":[[-2.271,2.842],[-0.149,2.419],[1.326,0.909],[5.499,-4.397],[0.014,-3.374],[-1.656,0.235]],"v":[[1.495,-5.116],[-2.888,6.64],[-1.494,12.984],[3.699,11.393],[13.578,-3.785],[7.803,-9.262]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.685,3.104],[1.977,0.044],[-0.261,-1.832],[-0.626,0.048],[0.568,-1.95],[-1,-0.102]],"o":[[0.738,-3.233],[-1.914,-0.094],[0.079,0.558],[1.041,-0.107],[-0.556,2.03],[1.585,0.262]],"v":[[-29.845,92.834],[-32.084,86.976],[-36.232,91.466],[-35.217,92.175],[-34.59,94.605],[-33.913,97.882]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-2.394,-1.488],[-2.215,-1.717],[2.273,-3.817],[1.456,-1.142],[0,0],[6.479,6.963],[0.149,0.06],[-16.19,-17.855],[-0.113,-0.796],[1.33,-3.521],[-0.369,-9.537],[6.018,-18.083],[0.733,-3.761],[-0.507,-4.56],[-1.785,-3.647],[-3.47,-3.124],[-0.193,-1.354],[-3.462,3.865],[-3.179,8.334],[0.634,4.461],[0.871,1.176],[4.626,0.359],[1.369,4.682],[-1.919,10.268],[0.659,8.602],[-0.966,2.616],[-3.087,3.039],[-2.219,5.191],[0.428,4.003],[0,0],[0,0],[0.317,-0.248]],"o":[[28.478,17.165],[1.818,1.407],[-1.246,2.127],[-1.647,1.29],[-1.108,-0.371],[-8.643,-7.833],[-0.437,-0.101],[2.778,4.197],[0.238,1.673],[-2.18,5.958],[0.39,10.671],[-3.5,10.534],[-0.947,4.726],[0.489,4.929],[1.579,3.189],[2.988,2.704],[0.147,1.035],[8.326,-9.269],[2.006,-5.202],[-0.419,-2.947],[-1.398,-1.915],[-6.103,-0.352],[-1.107,-3.824],[1.949,-10.557],[-0.441,-5.585],[1.017,-2.745],[5.006,-4.896],[1.958,-4.545],[0,0],[0,0],[-5.66,-3.178],[0.086,0.11]],"v":[[-60.336,-36.6],[-11.475,-15.666],[-12.108,-7.734],[-17.588,-1.226],[-19.918,-0.286],[-27.989,-7.063],[-44.031,-21.403],[-28.278,-3.649],[-26.676,4.656],[-28.024,11.024],[-30.438,31.684],[-37.793,69.583],[-42.605,85.748],[-43.142,97.323],[-40.058,108.628],[-33.559,116.726],[-28.573,123.088],[-24.774,120.11],[-6.787,92.647],[-5.105,80.705],[-6.548,75.994],[-14.8,72.899],[-25.083,65.908],[-24.119,48.421],[-22.567,25.161],[-21.83,14.492],[-16.665,7.257],[-6.385,-7.084],[-4.267,-18.925],[-4.559,-21.972],[-6.16,-22.841],[-64.675,-39.397]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-8.185,8.274],[-3.515,1.515],[-3.115,-2.605],[-2.31,-7.839],[-0.24,-0.697],[-2.213,-0.214],[-4.958,6.718],[-0.011,-0.079],[1.73,-2.684],[2.66,-2.084],[4.25,3.663],[1.615,2.452],[4.603,0.199],[3.177,-4.881],[-3.887,-2.089],[-2.008,1.22],[0.667,4.7],[2.536,-0.482],[-0.595,-3.695],[-1.369,0.276],[0.656,-0.337],[-1.988,4.833],[-2.717,-3.271],[0.409,-3.065],[5.103,-2.228],[4.788,2.002],[10.352,-5.9],[0,0]],"o":[[6.3,-13.613],[3.508,-3.546],[5.632,-2.466],[3.103,2.525],[0.93,3.078],[1.457,3.816],[3.51,0.436],[0.818,-1.172],[0.224,0.09],[-2.307,3.578],[-4.876,3.822],[-0.814,-0.778],[-4.984,-7.338],[-4.029,-0.119],[-4.164,6.361],[1.59,0.79],[3.816,-2.37],[-0.43,-3.027],[-3.49,0.699],[0.226,1.593],[0.891,-0.167],[-3.09,1.536],[2.34,-5.818],[1.117,1.426],[-0.866,6.787],[-3.503,1.595],[-8.309,-3.493],[0,0],[0,0]],"v":[[-4.456,99.142],[18.42,64.483],[31.493,54.946],[45.596,55.137],[52.577,68.611],[54.677,75.464],[60.45,81.917],[74.387,71.526],[76.006,69.549],[72.157,76.638],[65.254,84.526],[51.633,84.754],[47.163,79.051],[35.362,69.797],[23.454,77.624],[22.951,94.396],[29.182,93.673],[34.999,80.616],[30.834,77.063],[24.762,86.337],[27.074,88.243],[27.309,88.413],[24.877,81.201],[36.05,75.631],[37.451,84.006],[27.013,99.71],[17.222,99.151],[-4.411,101.94],[-6.431,103.08]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.839,2.542],[-0.488,7.465],[-0.19,0.149],[-0.713,-0.062],[-7.145,0.73],[-3.856,-2.378],[-1.672,-5.33],[0.221,-3.892],[6.529,-10.517],[0.052,-0.129],[-0.418,2.01],[2.821,5.491],[5.92,5.011]],"o":[[-3.667,-5.006],[0.025,-0.816],[0.126,-0.1],[1.35,0.092],[8.962,-0.826],[3.398,2.118],[0.919,2.998],[-0.689,12.491],[-0.975,1.561],[-0.127,0.099],[1.565,-8.308],[-1.739,-3.329],[-6.935,-5.719]],"v":[[64.933,2.005],[60.2,-16.949],[60.589,-18.67],[62.118,-18.806],[73.332,-19.627],[91.384,-17.397],[98.854,-6.43],[100.464,8.863],[89.379,44.285],[87.481,47.277],[87.983,43.874],[86.097,23.663],[75.422,11.932]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[3.27,10.629],[0.401,0.837],[0,0],[0,0],[-1.327,-2.412],[-0.554,-3.903],[0.328,-2.647],[1.664,-4.137],[6.618,-6.426],[2.942,-2.571],[4.15,-5.465],[0.075,0.03],[-2.307,3.579],[-7.69,7.797],[-0.956,1.193]],"o":[[-0.513,-1.633],[0,0],[0,0],[1.59,0.79],[1.037,1.844],[0.543,3.824],[-0.463,4.17],[-3.017,7.499],[-1.18,1.102],[-7.532,6.434],[-0.588,0.815],[-0.224,-0.09],[3.241,-4.93],[3.814,-3.874],[9.008,-11.397]],"v":[[52.939,-11.083],[51.242,-15.596],[50.464,-17.11],[51.607,-16.501],[55.877,-11.703],[57.633,-5.289],[57.898,2.028],[54.907,13.668],[41.011,33.765],[33.514,40.437],[16.976,57.292],[15.766,58.683],[20.572,50.402],[34.879,33.701],[43.555,24.423]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[14.25,-3.73],[2.094,14.737],[-0.064,0.05],[-1.011,-0.181],[-12.856,7.596],[-4.078,1.514],[-3.754,-12.551],[0.246,-4.708],[0.473,-0.636],[0.147,1.035],[4.089,1.044]],"o":[[-21.374,5.597],[-0.305,-2.151],[0.063,-0.049],[4.63,0.887],[7.539,-4.403],[12.872,-4.51],[1.083,3.665],[-0.244,3.732],[-0.115,0.179],[-0.937,-5.109],[-4.59,-1.095]],"v":[[66.335,-26.273],[34.604,-38.587],[34.177,-42.59],[36.113,-42.337],[58.344,-50.818],[74.299,-58.895],[99.921,-46.484],[101.517,-30.295],[99.577,-18.683],[99.023,-20.107],[91.119,-29.671]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.108,3.155],[0.618,8.81],[0,0],[0,0],[-1.679,0.076],[-3.307,-8.916],[-0.487,-0.946],[-1.99,-1.627],[2.515,-1.617]],"o":[[-5.284,-4.003],[0,0],[0,0],[1.893,-1.041],[4.494,-0.069],[0.937,2.63],[0.778,1.515],[1.435,1.178],[-3.919,2.629]],"v":[[-7.036,-29.503],[-17.205,-51.544],[-17.389,-54.322],[-16.405,-54.828],[-9.515,-56.863],[0.562,-45.373],[3.169,-38.917],[8.448,-32.962],[6.743,-28.616]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.315,3.206],[-0.606,3.661],[-0.064,0.049],[0.106,-1.234],[-1.14,-4.064],[-5.684,-2.362],[-1.113,-0.898],[0,0],[0,0],[1.115,-0.077],[0.364,-0.905],[-0.446,-3.634],[0.947,-4.726],[-0.454,2.746],[0.77,5.417],[6.714,-0.304],[1.708,-0.365],[-0.052,0.129],[-2.576,0.691],[-0.421,0.507]],"o":[[-0.489,-4.928],[0.285,-1.463],[0.063,-0.05],[-0.364,3.384],[1.437,5.159],[2.624,1.131],[0,0],[0,0],[-2.44,-0.832],[-0.764,0.068],[-0.312,0.775],[0.729,5.626],[-0.552,2.557],[0.269,-2.07],[-1.55,-10.913],[-1.678,0.076],[-1.707,0.364],[0.156,-0.388],[3.784,-1.106],[0.156,-0.388]],"v":[[61.118,-103.629],[61.352,-115.852],[61.945,-118.618],[61.836,-116.409],[63.029,-105.038],[70.643,-97.018],[77.549,-93.489],[79.655,-92.041],[77.662,-92.692],[68.551,-94.405],[67.296,-93.332],[67.416,-88.027],[67.085,-73.514],[66.804,-74.002],[66.265,-82.256],[56.615,-94.7],[50.458,-93.947],[47.498,-93.486],[56.425,-97.03],[61.234,-98.851]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[7.867,-4.571],[-0.991,0.954],[-3.164,1.506],[-8.41,-4.209],[0,0],[0,0],[-10.28,1.948],[-0.62,-0.399],[-0.491,-1.474],[0.981,-4.487],[-0.733,-1.196],[-1.14,0.894],[-0.189,7.585],[0,0],[0,0],[-1.693,-6.464],[0,0],[0,0],[2.126,0.104],[9.653,-6.857],[5.16,-1.83],[12.102,8.398],[3.176,1.052]],"o":[[-2.146,1.24],[1.843,-1.887],[7.525,-3.507],[0,0],[0,0],[10.892,-11.015],[2.811,-0.521],[0.224,0.09],[1.534,5.349],[-0.5,2.428],[0.625,0.928],[2.343,-1.836],[0,0],[0,0],[6.096,3.279],[0,0],[0,0],[-1.864,-1.726],[-3.827,-0.188],[-8.755,6.242],[-8.708,3.106],[-5.388,-3.745],[-7.023,-2.375]],"v":[[-16.001,-60.899],[-17.294,-60.593],[-7.711,-66.952],[15.528,-65.865],[17.726,-64.755],[20.307,-67.397],[53.128,-87.541],[61.169,-87.911],[62.363,-84.952],[63.233,-70.407],[63.482,-66.176],[66.511,-66.159],[70.961,-82.394],[71.031,-85.37],[72.173,-84.761],[85.407,-68.396],[85.857,-66.713],[84.733,-67.691],[78.951,-70.242],[61.725,-61.7],[42.798,-50.763],[17.164,-57.32],[5.385,-63.936]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-7.259,5.688],[0,0],[-1.297,-9.13],[0,0],[7.259,-5.688],[0,0],[1.297,9.13],[0,0]],"o":[[0,0],[7.259,-5.688],[0,0],[1.297,9.13],[0,0],[-7.259,5.688],[0,0],[-1.297,-9.13]],"v":[[-114.963,-61.837],[104.181,-233.575],[119.673,-227.343],[158.83,48.311],[148.036,75.142],[-71.109,246.881],[-86.6,240.648],[-125.758,-35.005]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,1,0.847,0.918,0.436,1,0.878,0.933,0.871,1,0.91,0.949],"ix":9}},"s":{"a":0,"k":[-162.135,-924.583],"ix":5},"e":{"a":0,"k":[-222.837,-1205.443],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":2,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-1.297,-9.13],[0,0],[-7.259,5.688],[0,0],[0,0],[0,0],[0,0],[1.297,9.13],[0,0],[0,0],[0,0],[0,0],[7.258,-5.688]],"o":[[-7.259,5.688],[0,0],[1.297,9.131],[0,0],[0,0],[0,0],[0,0],[7.259,-5.689],[0,0],[0,0],[0,0],[0,0],[-1.297,-9.13],[0,0]],"v":[[-148.035,-75.143],[-158.83,-48.311],[-119.673,227.342],[-104.181,233.575],[-75.332,210.966],[-67.918,213.949],[-62.751,201.107],[114.963,61.837],[125.757,35.005],[94.003,-188.535],[99.17,-201.378],[91.755,-204.361],[86.6,-240.648],[71.109,-246.881]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0,1,1,1,0.383,1,0.924,0.959,0.766,1,0.847,0.918,0.857,0.931,0.778,0.849,0.948,0.863,0.71,0.78],"ix":9}},"s":{"a":0,"k":[-353,-680.305],"ix":5},"e":{"a":0,"k":[-822.002,-806.499],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":2,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":17,"ty":4,"nm":"Opensea 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":150,"s":[24]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[543.975,-252.182,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[387.975,-128.182,0]}],"ix":2},"a":{"a":0,"k":[439.975,103.818,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[1.25,9]],"o":[[0,0],[0,0],[0,0],[-1.25,-9]],"v":[[427,-81.25],[409.5,-47.75],[427,-53],[432.25,-68.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.125490196078,0.505882352941,0.886274509804,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 2","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-0.514,-16.446],[0,0],[0,0],[0,0],[8.737,-2.056],[2.056,5.139],[0,0],[-24.669,5.139],[0,0],[-3.084,5.139],[0,0],[0,0],[0,0],[4.625,-2.57],[0,0],[0,0],[-8.737,16.446],[3.084,9.765],[3.598,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0.514,16.446],[0,0],[0,0],[0,0],[-4.904,1.154],[-8.223,2.57],[0,0],[24.669,-5.139],[0,0],[3.084,-5.139],[0,0],[0,0],[0,0],[-4.625,2.57],[0,0],[0,0],[8.737,-16.446],[-3.084,-9.765],[-3.598,0]],"v":[[-26.586,-186.994],[-42.004,-181.341],[-42.004,-168.493],[-61.02,-165.923],[-46.116,-124.294],[-61.02,-75.984],[-42.518,-82.151],[-42.518,-69.817],[-64.103,-61.08],[-72.326,-72.901],[-113.955,-57.996],[-81.577,-25.619],[11.959,-58.51],[29.433,-99.625],[46.393,-114.529],[45.879,-123.78],[3.736,-98.597],[-5.515,-85.235],[-25.044,-77.012],[-25.044,-89.347],[-2.431,-107.848],[5.792,-141.254],[-23.502,-168.493]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.125490196078,0.505882352941,0.886274509804,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":1,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[3.064,-65.944],[59.724,-23.705],[1.517,77.408],[-70.816,21.257]],"o":[[-3.358,72.268],[-66.147,26.254],[-1.665,-84.994],[68.176,-20.464]],"v":[[88.296,-156.476],[-26.179,16.588],[-167.379,-46.493],[-30.291,-237.031]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.1254902035,0.505882382393,0.886274516582,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[441.948,81.346],"ix":2},"a":{"a":0,"k":[-37.486,187.861],"ix":1},"s":{"a":0,"k":[48.644,48.644],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[35.092,-145.117],[34.592,-131.383],[-37.092,-108.883],[-35.592,-121.617]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.849065563725,0.849065563725,0.849065563725,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.414756954418,0.454261779785,0.52409620098,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[400.092,198.617],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 2","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[89.975,-290.818],[90.975,-57.182],[-92.475,9.318],[-90.975,-223.818]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":12,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"st","c":{"a":0,"k":[0.849065563725,0.849065563725,0.849065563725,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.307652801275,0.406062930822,0.504473030567,1],"ix":4},"o":{"a":0,"k":77,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[439.975,103.818],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":4,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":18,"ty":4,"nm":"Filecoin","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-570.61,-473.457,0],"ix":2},"a":{"a":0,"k":[297.39,-313.457,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[2.073,-4.974],[2.487,-5.388],[7.875,-1.244],[3.73,2.901],[0,1.244],[-1.243,0.829],[-1.243,-0.415],[-0.829,-1.658],[-3.316,2.487],[-1.243,4.559],[-2.073,9.947],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.829,2.073],[-4.974,6.632],[-8.704,-0.415],[-2.487,-2.901],[0,-0.829],[1.244,-1.243],[1.658,1.658],[1.243,1.243],[2.901,-2.901],[1.243,-2.901],[2.901,-9.119],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[-1.658,5.388],[-2.072,5.803],[-3.316,7.046],[-4.559,0.829],[-1.243,-0.829],[0,-1.658],[0.829,-0.414],[1.243,1.243],[2.487,3.316],[3.73,-3.316],[2.487,-9.948],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0.829,-2.487],[2.073,-7.461],[4.974,-6.632],[3.731,0],[0.415,0.414],[0,1.658],[-1.658,1.243],[-1.244,-1.243],[-2.487,-3.316],[-2.073,2.073],[-2.902,8.704],[0,0],[0,0],[0,0]],"v":[[305.265,-323.403],[302.778,-310.139],[326.404,-306.823],[324.746,-300.606],[301.535,-303.922],[296.976,-287.757],[290.344,-270.763],[273.35,-257.499],[260.086,-259.986],[257.599,-263.717],[259.671,-268.276],[263.816,-267.861],[267.132,-263.302],[276.251,-262.059],[283.297,-274.493],[290.344,-303.922],[290.344,-305.58],[268.376,-308.896],[269.205,-315.113],[292.002,-311.797],[294.903,-324.646],[271.277,-328.377],[272.106,-335.009],[296.561,-331.693],[298.634,-338.325],[307.752,-359.878],[327.233,-370.241],[337.181,-366.096],[338.425,-364.023],[337.181,-359.049],[331.793,-359.878],[328.477,-363.609],[319.358,-364.438],[313.97,-356.562],[306.094,-329.62],[328.891,-326.304],[327.233,-320.087]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[45.594,0],[0,46.009],[-46.009,-0.414],[0,-46.423]],"o":[[-45.594,0],[0.414,-45.594],[45.594,0.414],[-0.414,45.179]],"v":[[297.39,-230.557],[214.492,-313.869],[297.805,-396.353],[380.288,-312.626]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.564705908298,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":19,"ty":4,"nm":"Arbitrum 2","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":0,"k":[-286.145,203.634,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[42.098,42.098,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.78,1.747],[0,0],[2.755,-1.386],[0,0],[0.471,-0.337],[0.155,-3.037],[0,0],[0,0],[0,0],[-0.023,0.127],[-0.708,0.508],[-0.122,0.061],[-0.899,-0.442],[0,0],[-0.051,-1.074],[0,0],[0.732,-0.594],[0,0],[0,0],[0,0],[0,0],[0.745,0.303],[0,0],[0,0],[0,0],[-0.358,-0.202],[-0.134,-0.064],[-1.367,0],[-1.156,0.453],[0,0],[-0.123,2.943]],"o":[[-0.131,-3.278],[0,0],[-2.75,-1.385],[-0.326,0.164],[-0.52,0.249],[-2.482,1.779],[0,0],[0,0],[0,0],[0.008,-0.131],[0.151,-0.843],[0.177,-0.127],[0.898,-0.451],[0,0],[0.91,0.579],[0,0],[-0.047,0.941],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0],[0,0],[0.49,0.278],[0.555,0.312],[1.054,0.512],[1.253,0],[0,0],[2.325,-1.801],[0,0]],"v":[[48.35,-22.64],[43.664,-30.666],[4.696,-53.075],[-4.244,-53.076],[-42.139,-31.123],[-43.631,-30.24],[-47.781,-22.66],[-47.781,23.75],[-41.087,13.463],[-41.145,-22.346],[-41.098,-22.733],[-39.768,-24.835],[-1.258,-47.141],[1.68,-47.155],[40.144,-25.03],[41.675,-22.394],[41.675,21.965],[40.525,24.372],[33.068,28.693],[29.221,30.923],[15.468,38.893],[1.521,46.976],[-0.853,46.929],[-17.354,37.438],[-20.725,43.154],[-5.896,51.693],[-4.61,52.42],[-3.543,53.003],[0.394,53.814],[4.024,53.13],[44.534,29.671],[48.35,22.21]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.588235318661,0.745098054409,0.86274510622,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.017,-22.559],[2.343,-22.502],[-33.12,36.018],[-20.725,43.154],[-17.354,37.438]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[2.506,-4.09],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0]],"v":[[-47.781,27.572],[-37.251,33.639],[-2.208,-22.559],[-8.156,-22.717],[-21.187,-17.381],[-41.087,13.462],[-47.781,23.749],[-47.781,27.572]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.046,0.941]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.731,-0.594],[0,0]],"v":[[41.745,21.549],[41.735,15.163],[20.371,-18.112],[12.445,-4.663],[33.069,28.693],[40.526,24.372],[41.746,21.965]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.581,15.527],[15.469,38.893],[29.221,30.923],[9.669,0.105]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[15.469,38.893],[0.581,15.526],[9.669,0.105],[29.221,30.923]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.91,0.579],[0,0],[0.898,-0.451],[0.109,-0.072],[0,0],[0,0],[0,0],[0.177,-0.127],[0.152,-0.842],[0.008,-0.131],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[-0.05,-1.074],[0,0],[-0.9,-0.442],[-0.121,0.061],[0,0],[0,0],[0,0],[-0.186,0.086],[-0.708,0.508],[-0.023,0.128],[0,0],[0,0],[2.505,-4.09],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0.745,0.302],[0,0],[0,0],[0,0]],"v":[[12.444,-4.663],[20.371,-18.112],[41.735,15.163],[41.745,21.549],[41.675,-22.394],[40.144,-25.03],[1.681,-47.155],[-1.258,-47.141],[-1.602,-46.942],[-1.736,-46.858],[-39.071,-25.222],[-39.216,-25.157],[-39.768,-24.835],[-41.097,-22.735],[-41.145,-22.347],[-41.086,13.463],[-21.187,-17.381],[-8.155,-22.716],[-2.208,-22.559],[-37.25,33.639],[-33.12,36.018],[2.343,-22.502],[18.018,-22.559],[-17.354,37.438],[-2.614,45.915],[-0.853,46.929],[1.522,46.974],[40.526,24.372],[33.069,28.693]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-45.784,0],[0,-45.784],[45.784,0],[0,45.784]],"o":[[45.784,0],[0,45.784],[-45.784,0],[0,-45.784]],"v":[[0,-82.898],[82.898,0],[0,82.898],[-82.898,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":20,"ty":4,"nm":"Arbitrum","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[67.715]},{"t":150,"s":[26.605]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[316.526,-625.396,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[310.526,-651.396,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[130.008,130.008,100]},{"t":150,"s":[140.805,140.805,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.78,1.747],[0,0],[2.755,-1.386],[0,0],[0.471,-0.337],[0.155,-3.037],[0,0],[0,0],[0,0],[-0.023,0.127],[-0.708,0.508],[-0.122,0.061],[-0.899,-0.442],[0,0],[-0.051,-1.074],[0,0],[0.732,-0.594],[0,0],[0,0],[0,0],[0,0],[0.745,0.303],[0,0],[0,0],[0,0],[-0.358,-0.202],[-0.134,-0.064],[-1.367,0],[-1.156,0.453],[0,0],[-0.123,2.943]],"o":[[-0.131,-3.278],[0,0],[-2.75,-1.385],[-0.326,0.164],[-0.52,0.249],[-2.482,1.779],[0,0],[0,0],[0,0],[0.008,-0.131],[0.151,-0.843],[0.177,-0.127],[0.898,-0.451],[0,0],[0.91,0.579],[0,0],[-0.047,0.941],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0],[0,0],[0.49,0.278],[0.555,0.312],[1.054,0.512],[1.253,0],[0,0],[2.325,-1.801],[0,0]],"v":[[48.35,-22.64],[43.664,-30.666],[4.696,-53.075],[-4.244,-53.076],[-42.139,-31.123],[-43.631,-30.24],[-47.781,-22.66],[-47.781,23.75],[-41.087,13.463],[-41.145,-22.346],[-41.098,-22.733],[-39.768,-24.835],[-1.258,-47.141],[1.68,-47.155],[40.144,-25.03],[41.675,-22.394],[41.675,21.965],[40.525,24.372],[33.068,28.693],[29.221,30.923],[15.468,38.893],[1.521,46.976],[-0.853,46.929],[-17.354,37.438],[-20.725,43.154],[-5.896,51.693],[-4.61,52.42],[-3.543,53.003],[0.394,53.814],[4.024,53.13],[44.534,29.671],[48.35,22.21]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.588235318661,0.745098054409,0.86274510622,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.017,-22.559],[2.343,-22.502],[-33.12,36.018],[-20.725,43.154],[-17.354,37.438]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[2.506,-4.09],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0]],"v":[[-47.781,27.572],[-37.251,33.639],[-2.208,-22.559],[-8.156,-22.717],[-21.187,-17.381],[-41.087,13.462],[-47.781,23.749],[-47.781,27.572]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.046,0.941]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.731,-0.594],[0,0]],"v":[[41.745,21.549],[41.735,15.163],[20.371,-18.112],[12.445,-4.663],[33.069,28.693],[40.526,24.372],[41.746,21.965]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.581,15.527],[15.469,38.893],[29.221,30.923],[9.669,0.105]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[15.469,38.893],[0.581,15.526],[9.669,0.105],[29.221,30.923]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.91,0.579],[0,0],[0.898,-0.451],[0.109,-0.072],[0,0],[0,0],[0,0],[0.177,-0.127],[0.152,-0.842],[0.008,-0.131],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[-0.05,-1.074],[0,0],[-0.9,-0.442],[-0.121,0.061],[0,0],[0,0],[0,0],[-0.186,0.086],[-0.708,0.508],[-0.023,0.128],[0,0],[0,0],[2.505,-4.09],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0.745,0.302],[0,0],[0,0],[0,0]],"v":[[12.444,-4.663],[20.371,-18.112],[41.735,15.163],[41.745,21.549],[41.675,-22.394],[40.144,-25.03],[1.681,-47.155],[-1.258,-47.141],[-1.602,-46.942],[-1.736,-46.858],[-39.071,-25.222],[-39.216,-25.157],[-39.768,-24.835],[-41.097,-22.735],[-41.145,-22.347],[-41.086,13.463],[-21.187,-17.381],[-8.155,-22.716],[-2.208,-22.559],[-37.25,33.639],[-33.12,36.018],[2.343,-22.502],[18.018,-22.559],[-17.354,37.438],[-2.614,45.915],[-0.853,46.929],[1.522,46.974],[40.526,24.372],[33.069,28.693]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-45.784,0],[0,-45.784],[45.784,0],[0,45.784]],"o":[[45.784,0],[0,45.784],[-45.784,0],[0,-45.784]],"v":[[0,-82.898],[82.898,0],[0,82.898],[-82.898,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":21,"ty":4,"nm":"BTC","parent":11,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-71.748]},{"t":150,"s":[-36.25]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[279.889,-220.474,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[196.913,-252.482,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.584,16.027],[-7.604,2.267],[0,0]],"o":[[-4.376,-15.298],[0,0],[-7.603,2.268]],"v":[[-13.934,29.635],[13.776,7.059],[21.486,34.013]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[5.001,17.484],[-9.219,2.777],[0,0]],"o":[[-4.793,-16.755],[0,0],[-9.219,2.777]],"v":[[-32.234,-10.516],[1.456,-36.333],[9.908,-6.624]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[-4.473,-11.423],[-17.993,3.386],[0,0],[0,0],[0,0],[-3.484,0.95],[0,0],[0,0],[0,0],[-2.755,0.741],[0,0],[0,0],[-0.159,0.092],[1.311,2.638],[0,0],[0.569,-0.116],[-0.57,0.116],[0,0],[-3.802,1.134],[0,0],[0,0],[0,0],[3.166,-0.766],[0,0],[0,0],[0,0],[3.392,-1.109],[0,0],[0,0],[0,0],[-4.109,-21.819],[-13.721,0.494]],"o":[[6.201,15.518],[0,0],[0,0],[0,0],[3.643,-1.042],[0,0],[0,0],[0,0],[2.914,-0.834],[0,0],[0,0],[0,0],[-5.51,1.484],[0,0],[-0.41,0.024],[0.41,-0.024],[0,0],[-0.19,-1.8],[-0.251,-0.067],[0,0],[0,0],[-3.324,0.859],[0,0],[0,0],[0,0],[-3.734,0.883],[0,0],[0,0],[0,0],[-22.419,7.85],[3.36,17.582],[-6.721,6.002]],"v":[[-37.422,42.984],[2.005,56.507],[8.44,78.68],[21.964,74.904],[15.804,53.208],[26.481,50.015],[32.732,71.87],[46.256,68.094],[39.821,45.921],[48.312,43.353],[66.935,38.118],[62.859,23.707],[53.07,26.6],[43.548,22.973],[36.347,-2.365],[34.89,-1.949],[36.347,-2.365],[26.228,-37.903],[29.985,-43.892],[39.774,-46.785],[37.853,-63.712],[20.209,-58.619],[10.487,-55.977],[4.119,-78.401],[-9.404,-74.625],[-2.969,-52.452],[-13.738,-49.418],[-20.081,-71.432],[-33.605,-67.656],[-27.236,-45.231],[-59.747,-5.241],[-32.385,17.158]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[18.939,65.883],[-65.885,18.941],[-18.938,-65.883],[66.044,-19.032]],"o":[[-19.03,-66.042],[65.885,-18.941],[19.031,66.042],[-66.136,18.873]],"v":[[-119.511,34.339],[-34.301,-119.473],[119.51,-34.27],[34.301,119.541]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.964705884457,0.572549045086,0.101960785687,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":22,"ty":4,"nm":"Beefy","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-539.185,383.552,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-636.662,219.059,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[100,100,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.256,1.446],[-2.701,0.676],[-1.958,-1.31],[0.748,-1.411],[2.196,0.139]],"o":[[-1.732,-1.955],[2.102,-0.516],[2.031,1.342],[-0.651,1.216],[-2.406,-0.157]],"v":[[-21.958,2.476],[-19.963,-2.201],[-12.72,-0.89],[-10.75,3.458],[-15.754,5.179]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.090196080506,0.082352943718,0.070588238537,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.513,-0.937],[-2.573,-0.488],[-1.057,1.233],[1.785,1.363],[1.551,0.257],[1.128,-1.31]],"o":[[0.837,1.521],[2.499,0.456],[1.05,-1.204],[-1.055,-0.796],[-2.593,-0.4],[-0.668,0.701]],"v":[[0.723,23.104],[6.129,26.493],[12.24,25.333],[11.223,21.045],[7.092,19.26],[1.047,20.482]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-1.765,-1.809],[-2.515,-2.288],[-1.907,-1.654],[-1.228,-0.742],[-1.5,-0.602],[-4.451,0.342],[-0.997,0.255],[-2.228,0.72],[0.091,0.191],[0.586,2.038],[-2.627,4.983],[-1.487,1.476],[-1.826,1.199],[-1.807,0.754],[-3.041,1.11],[5.061,4.675],[0.338,0.169],[0.904,-0.199],[0.61,-0.327],[0.441,-1.48],[0.761,-1.826],[1.385,-0.431],[10.892,-3.442],[0.817,-0.528],[0.561,-0.586],[-0.501,-2.173]],"o":[[2.364,2.361],[1.849,1.672],[0.968,0.823],[1.272,0.783],[4.429,1.775],[1.145,-0.082],[2.34,-0.618],[0.091,-0.166],[-1.073,-2.023],[-1.657,-5.734],[0.895,-1.703],[1.417,-1.4],[1.476,-0.952],[2.907,-1.233],[-5.062,-4.675],[-0.245,-0.225],[-0.85,-0.393],[-0.766,0.183],[-1.68,0.906],[-0.593,1.911],[-0.402,0.947],[-10.959,3.381],[-1.067,0.332],[-0.759,0.51],[-1.607,1.65],[0.447,1.944]],"v":[[-50.852,16.368],[-43.377,23.307],[-37.887,28.341],[-34.828,30.597],[-30.655,32.67],[-16.612,34.881],[-12.965,34.295],[-6.213,32.195],[-6.148,31.791],[-8.828,25.718],[-7.587,9.408],[-4.027,4.574],[0.683,0.587],[5.587,-2.116],[14.608,-5.469],[-0.599,-19.514],[-1.623,-20.21],[-4.573,-20.69],[-6.859,-19.951],[-10.328,-16.351],[-11.724,-10.408],[-14.514,-8.39],[-47.353,1.822],[-50.223,3.126],[-52.251,4.744],[-54.096,10.771]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[2.511,-0.78],[0,0],[-2.329,0.807],[-0.196,0.389],[0.618,0.712],[2.168,0.257],[0.347,-0.108]],"o":[[0,0],[2.44,-0.704],[0.555,-0.2],[0.357,-0.632],[-1.025,-1.161],[-0.444,-0.054],[-2.592,0.669]],"v":[[44.771,8.994],[50.654,14.428],[57.84,12.193],[59.072,11.372],[58.738,9.283],[54.097,6.67],[52.318,6.702]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0.202,-0.063],[0,0],[-2.295,0.659],[0.025,0.842],[0.297,0.346],[2.175,0.228],[0.259,-0.081],[2.33,-0.697]],"o":[[0,0],[2.206,-0.741],[1.09,-0.312],[0,-0.356],[-1.019,-1.191],[-0.342,-0.031],[-2.42,0.615],[-0.173,0.054]],"v":[[17.599,-16.101],[23.482,-10.668],[30.163,-12.691],[32.043,-14.482],[31.544,-15.834],[26.742,-18.451],[25.124,-18.414],[18.154,-16.301]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[4.347,4.157],[-0.85,4.595],[-3.917,2.26],[-2.258,0.73],[-9.407,2.925],[-0.149,0.896],[-1.735,3.527],[-2.313,1.569],[-3.713,-0.544],[-1.095,-0.975],[-4.818,-4.449],[-2.737,0.714],[-3.534,-0.984],[-2.1,-1.868],[2.288,-2.767],[1.427,-0.499],[2.54,-0.79],[-0.045,-0.041],[-3.13,-2.891],[-2.857,0.532],[-4.096,-1.823],[-1.37,-2.37],[0.193,-1.211],[2.16,-0.891],[2.799,-0.87],[-4.151,-3.834],[0.963,-1.176],[4.981,0.396],[7.042,1.729],[1.206,-0.348],[10.568,-2.601],[5.472,0.601],[5.184,2.471],[2.646,2.301]],"o":[[-4.717,-4.535],[0.668,-3.551],[1.823,-1.06],[9.385,-2.946],[1.241,-0.386],[0.794,-3.755],[1.046,-2.134],[2.091,-1.418],[1.821,0.256],[4.846,4.44],[2.626,-0.817],[3.025,-0.804],[3.329,0.938],[3.578,3.163],[-0.766,0.896],[-2.473,0.851],[0.045,0.041],[3.101,2.9],[2.677,-0.805],[4.035,-0.762],[3.532,1.588],[0.73,1.28],[-0.306,1.712],[-2.571,1.046],[4.152,3.834],[1.443,1.333],[-2.24,2.67],[-7.09,-0.564],[-1.423,-0.352],[-10.186,3.167],[-4.646,1.088],[-5.916,-0.654],[-3.658,-1.74],[-4.527,-4.074]],"v":[[-61.893,19.637],[-67.806,5.305],[-60.73,-3.692],[-54.532,-6.305],[-26.333,-15.101],[-24.169,-17.912],[-21.722,-29.225],[-16.472,-34.886],[-7.405,-37.021],[-2.765,-34.873],[11.665,-21.546],[19.587,-23.955],[30.167,-23.518],[38.405,-19.009],[40.379,-9.811],[36.996,-7.663],[29.4,-5.273],[29.527,-5.121],[38.895,3.531],[47.548,0.978],[60.558,2.769],[68.124,9.187],[68.754,13.047],[64.846,17.168],[56.537,19.861],[68.991,31.363],[69.851,35.399],[53.762,37.854],[30.356,32.909],[25.43,32.742],[-6.256,42.486],[-21.759,43.059],[-39.052,38.132],[-48.528,31.98]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.090196080506,0.082352943718,0.070588238537,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":6,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-5.457,-5.04],[0,0],[7.093,-2.206],[0,0],[5.456,5.04],[0,0],[-7.093,2.206],[0,0]],"o":[[0,0],[5.457,5.04],[0,0],[-7.093,2.206],[0,0],[-5.457,-5.04],[0,0],[7.093,-2.206]],"v":[[26.09,-62.656],[128.405,31.841],[125.443,44.96],[-7.552,86.319],[-30.274,81.188],[-132.589,-13.309],[-129.627,-26.427],[3.367,-67.787]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.937254901961,0.917647058824,0.894117647059,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[7.092,-2.206],[0,0],[-5.456,-5.04],[0,0],[0,0],[0,0],[0,0],[-7.093,2.206],[0,0],[0,0],[0,0],[0,0],[5.457,5.04]],"o":[[-5.457,-5.04],[0,0],[-7.093,2.206],[0,0],[0,0],[0,0],[0,0],[5.457,5.04],[0,0],[0,0],[0,0],[0,0],[7.093,-2.206],[0,0]],"v":[[30.274,-81.188],[7.552,-86.319],[-125.443,-44.96],[-128.405,-31.841],[-117.399,-21.675],[-118.295,-17.705],[-111.418,-16.152],[-26.09,62.655],[-3.367,67.786],[107.546,33.294],[114.424,34.847],[115.32,30.876],[129.627,26.427],[132.589,13.308]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.670588235294,0.658823529412,0.643137254902,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":23,"ty":4,"nm":"Op","parent":11,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-82.131,"ix":10},"p":{"a":0,"k":[325.553,761.989,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.401,-0.949],[1.387,-2.599],[0.225,-0.841],[-0.839,-1.265],[-2.647,-0.71],[0,0],[0,0]],"o":[[-2.709,-0.726],[-2.462,0.934],[-0.491,1.047],[-0.502,1.873],[0.823,1.327],[0,0],[0,0],[0,0]],"v":[[-40.453,-6.992],[-48.121,-6.657],[-53.899,-1.357],[-54.967,1.471],[-54.463,6.175],[-49.263,9.228],[-37.64,12.342],[-29.316,-4.007]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-0.267,-0.553],[0.302,-0.61],[0,0],[0.7,-0.299],[0.65,0.174],[0,0],[3.53,4.127],[-1.506,5.621],[-0.854,1.64],[-5.859,2.236],[-8.453,-2.265],[0,0],[0,0],[-0.7,0.299],[-0.646,-0.173],[0,0]],"o":[[0.712,0.191],[0.187,0.603],[0,0],[-0.32,0.677],[-0.705,0.298],[0,0],[-7.169,-1.921],[-3.597,-4.144],[0.433,-1.615],[3.605,-6.994],[5.793,-2.253],[0,0],[0,0],[0.32,-0.678],[0.705,-0.298],[0,0],[0,0]],"v":[[3.738,-34.8],[5.203,-33.682],[5.024,-31.861],[-25.202,27.501],[-26.733,28.96],[-28.756,29.143],[-54.514,22.241],[-70.558,13.168],[-73.692,-1.478],[-71.759,-6.358],[-57.568,-20.201],[-36.194,-20.182],[-23.121,-16.679],[-12.986,-36.692],[-11.455,-38.151],[-9.431,-38.334],[3.739,-34.805]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[3.089,-1.456],[2.275,-4.092],[1.984,-4.309],[0.381,-1.419],[-6.131,-1.643],[-3.151,1.44],[-2.275,4.092],[-2.843,5.948],[-0.38,1.419],[6.193,1.659]],"o":[[-3.617,-0.969],[-3.152,1.44],[-3.113,5.671],[-0.621,1.288],[-1.573,5.873],[3.618,0.969],[3.09,-1.457],[2.32,-4.013],[0.604,-1.221],[1.592,-5.94],[0,0]],"v":[[41.31,-10.826],[31.253,-10.097],[23.11,-1.797],[15.464,13.175],[13.961,17.236],[20.797,28.51],[30.948,27.806],[38.993,19.479],[46.736,4.534],[48.213,0.571],[41.305,-10.827]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-3.938,-4.933],[1.817,-6.781],[0.878,-1.977],[3.295,-6.103],[18.269,4.895],[3.488,2.733],[1.373,3.897],[-1.212,4.52],[-0.88,1.983],[-2.805,5.061],[-6.725,2.905],[-9.299,-2.492]],"o":[[7.685,2.059],[3.855,4.977],[-0.381,1.419],[-2.087,4.424],[-9.148,16.577],[-4.97,-1.332],[-3.505,-2.67],[-1.396,-3.831],[0.363,-1.358],[2.509,-5.484],[4.631,-8.24],[6.712,-2.837],[0,0]],"v":[[46.404,-24.407],[63.834,-13.923],[66.892,3.712],[65.006,8.81],[56.935,24.602],[15.811,42.125],[3.124,36.026],[-4.199,26.176],[-4.475,13.646],[-2.614,8.64],[5.358,-7.178],[22.393,-23.893],[46.405,-24.412]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[71.279,19.099],[19.099,-71.279],[-71.279,-19.099],[-19.099,71.278]],"o":[[-71.279,-19.099],[-19.099,71.279],[71.279,19.099],[19.099,-71.279]],"v":[[34.553,-129.113],[-129.091,-34.633],[-34.611,129.01],[129.032,34.531]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.015686275437,0.1254902035,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":24,"ty":4,"nm":"BTC 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-115,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-711.509,485.332,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-815.822,471.229,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[41.711,41.711,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.584,16.027],[-7.604,2.267],[0,0]],"o":[[-4.376,-15.298],[0,0],[-7.603,2.268]],"v":[[-13.934,29.635],[13.776,7.059],[21.486,34.013]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[5.001,17.484],[-9.219,2.777],[0,0]],"o":[[-4.793,-16.755],[0,0],[-9.219,2.777]],"v":[[-32.234,-10.516],[1.456,-36.333],[9.908,-6.624]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[-4.473,-11.423],[-17.993,3.386],[0,0],[0,0],[0,0],[-3.484,0.95],[0,0],[0,0],[0,0],[-2.755,0.741],[0,0],[0,0],[-0.159,0.092],[1.311,2.638],[0,0],[0.569,-0.116],[-0.57,0.116],[0,0],[-3.802,1.134],[0,0],[0,0],[0,0],[3.166,-0.766],[0,0],[0,0],[0,0],[3.392,-1.109],[0,0],[0,0],[0,0],[-4.109,-21.819],[-13.721,0.494]],"o":[[6.201,15.518],[0,0],[0,0],[0,0],[3.643,-1.042],[0,0],[0,0],[0,0],[2.914,-0.834],[0,0],[0,0],[0,0],[-5.51,1.484],[0,0],[-0.41,0.024],[0.41,-0.024],[0,0],[-0.19,-1.8],[-0.251,-0.067],[0,0],[0,0],[-3.324,0.859],[0,0],[0,0],[0,0],[-3.734,0.883],[0,0],[0,0],[0,0],[-22.419,7.85],[3.36,17.582],[-6.721,6.002]],"v":[[-37.422,42.984],[2.005,56.507],[8.44,78.68],[21.964,74.904],[15.804,53.208],[26.481,50.015],[32.732,71.87],[46.256,68.094],[39.821,45.921],[48.312,43.353],[66.935,38.118],[62.859,23.707],[53.07,26.6],[43.548,22.973],[36.347,-2.365],[34.89,-1.949],[36.347,-2.365],[26.228,-37.903],[29.985,-43.892],[39.774,-46.785],[37.853,-63.712],[20.209,-58.619],[10.487,-55.977],[4.119,-78.401],[-9.404,-74.625],[-2.969,-52.452],[-13.738,-49.418],[-20.081,-71.432],[-33.605,-67.656],[-27.236,-45.231],[-59.747,-5.241],[-32.385,17.158]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[18.939,65.883],[-65.885,18.941],[-18.938,-65.883],[66.044,-19.032]],"o":[[-19.03,-66.042],[65.885,-18.941],[19.031,66.042],[-66.136,18.873]],"v":[[-119.511,34.339],[-34.301,-119.473],[119.51,-34.27],[34.301,119.541]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.964705884457,0.572549045086,0.101960785687,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":25,"ty":4,"nm":"BNB 2","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":0,"k":[188.647,851.321,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,0.138],[-23.945,-3.002],[-23.945,13.996],[-9.344,22.495],[-9.344,16.215],[-18.577,10.856]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,-10.58],[-13.209,-13.72],[-18.577,-16.86],[-23.945,-13.72],[-23.945,-7.441],[-18.577,-4.301]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,-13.72],[-0.165,-10.58],[5.203,-13.72],[-0.165,-16.86]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,8.637],[-9.398,11.776],[-9.398,5.497],[-14.766,2.357]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,18.489],[-5.533,24.768],[-0.165,27.908],[5.203,24.768],[5.203,18.489],[-0.165,21.628]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[12.879,-13.72],[18.247,-10.58],[18.247,-4.301],[23.615,-7.441],[23.615,-13.72],[18.247,-16.86]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.247,10.856],[9.014,16.215],[9.014,22.495],[23.615,13.996],[23.615,-3.002],[18.247,0.138]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,8.637],[14.435,2.357],[9.068,5.497],[9.068,11.776]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,-8.361],[9.068,-11.501],[-0.165,-6.141],[-9.398,-11.501],[-14.766,-8.361],[-14.766,-2.081],[-5.533,3.278],[-5.533,13.996],[-0.165,17.135],[5.203,13.996],[5.203,3.278],[14.435,-2.081]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ind":9,"ty":"sh","ix":10,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,-19.079],[-0.165,-27.578],[14.435,-19.079],[9.068,-15.939],[-0.165,-21.298],[-9.398,-15.939]],"c":true},"ix":2},"nm":"Path 10","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":11,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-22.892,0],[0,-22.892],[22.892,0],[0,22.892]],"o":[[22.892,0],[0,22.892],[-22.892,0],[0,-22.892]],"v":[[0,-41.449],[41.449,0],[0,41.449],[-41.449,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176474094,0.72549021244,0.043137256056,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":26,"ty":4,"nm":"BNB","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[338.158,668.921,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[116.088,116.088,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,0.138],[-23.945,-3.002],[-23.945,13.996],[-9.344,22.495],[-9.344,16.215],[-18.577,10.856]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,-10.58],[-13.209,-13.72],[-18.577,-16.86],[-23.945,-13.72],[-23.945,-7.441],[-18.577,-4.301]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,-13.72],[-0.165,-10.58],[5.203,-13.72],[-0.165,-16.86]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,8.637],[-9.398,11.776],[-9.398,5.497],[-14.766,2.357]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,18.489],[-5.533,24.768],[-0.165,27.908],[5.203,24.768],[5.203,18.489],[-0.165,21.628]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[12.879,-13.72],[18.247,-10.58],[18.247,-4.301],[23.615,-7.441],[23.615,-13.72],[18.247,-16.86]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.247,10.856],[9.014,16.215],[9.014,22.495],[23.615,13.996],[23.615,-3.002],[18.247,0.138]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,8.637],[14.435,2.357],[9.068,5.497],[9.068,11.776]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,-8.361],[9.068,-11.501],[-0.165,-6.141],[-9.398,-11.501],[-14.766,-8.361],[-14.766,-2.081],[-5.533,3.278],[-5.533,13.996],[-0.165,17.135],[5.203,13.996],[5.203,3.278],[14.435,-2.081]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ind":9,"ty":"sh","ix":10,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,-19.079],[-0.165,-27.578],[14.435,-19.079],[9.068,-15.939],[-0.165,-21.298],[-9.398,-15.939]],"c":true},"ix":2},"nm":"Path 10","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":11,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-22.892,0],[0,-22.892],[22.892,0],[0,22.892]],"o":[[22.892,0],[0,22.892],[-22.892,0],[0,-22.892]],"v":[[0,-41.449],[41.449,0],[0,41.449],[-41.449,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176474094,0.72549021244,0.043137256056,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":28,"ty":4,"nm":"Fantom","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":110.446,"ix":10},"p":{"a":0,"k":[752.802,168.933,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[85.135,85.135,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-0.054,0.968],[-11.295,6.875],[0,0],[0,0],[1.614,-2.517],[0.219,-3.642],[0,0],[0.017,-1.043],[0,0],[0,0]],"o":[[0,0],[0,0],[0.018,-1.221],[0.573,-10.35],[0,0],[0,0],[-4.961,2.987],[-1.338,2.087],[0,0],[-0.044,0.797],[0,0],[0,0],[0,0]],"v":[[-124.334,-8.745],[-124.312,-12.946],[-124.303,-13.655],[-124.199,-16.867],[-108.535,-40.108],[-108.191,-40.316],[-103.61,-32.709],[-113.1,-24.67],[-115.262,-16.654],[-115.274,-16.447],[-115.363,-13.741],[-115.377,-12.514],[-115.396,-8.762]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-2.869,-1.73],[0,0],[-0.055,-0.03],[0,0],[0,0],[0,0],[0,0],[2.87,1.73],[0,0],[0.054,0.031],[0,0],[0,0],[0,0]],"o":[[0.186,3.346],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.186,-3.345],[0,0],[-0.058,-0.035],[0,0],[0,0],[0,0],[0,0]],"v":[[-92.897,49.349],[-87.077,59.016],[-31.896,92.279],[-31.727,92.377],[-31.678,92.404],[-31.681,92.301],[-31.687,92.154],[-35.271,27.822],[-41.091,18.156],[-96.272,-15.107],[-96.44,-15.206],[-96.489,-15.233],[-96.487,-15.13],[-96.48,-14.982]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-23.022,87.948],[23.029,60.22],[-26.388,30.252]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-88.334,-20.521],[-38.916,9.446],[-42.283,-48.25]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[-0.091,-0.429],[0,0],[0.344,0.207],[0,0],[0.054,0.03],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[-0.336,-0.282],[0,0],[-0.057,-0.035],[0,0],[0,0],[0,0],[0,0],[0.022,0.401]],"v":[[-29.804,12.653],[22.905,-19.084],[21.883,-19.821],[-33.299,-53.025],[-33.467,-53.123],[-33.516,-53.15],[-33.514,-53.047],[-33.507,-52.9],[-29.976,11.405]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[-0.343,-0.207],[0,0],[-0.055,-0.031],[0,0],[0,0],[0,0],[0,0],[0.092,0.429]],"o":[[0.337,0.281],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.022,-0.4],[0,0]],"v":[[-25.127,20.421],[-24.105,21.157],[31.077,54.362],[31.246,54.46],[31.295,54.487],[31.293,54.384],[31.286,54.236],[27.755,-10.069],[27.582,-11.317]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[-1.614,2.517],[-0.219,3.642],[0,0],[-0.017,1.043],[0,0],[0,0],[0,0],[0,0],[0,0],[0.054,-0.968],[11.295,-6.875],[0,0]],"o":[[4.96,-2.987],[1.338,-2.087],[0,0],[0.044,-0.797],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.018,1.222],[-0.573,10.35],[0,0],[0,0]],"v":[[103.608,32.709],[113.098,24.67],[115.26,16.654],[115.272,16.447],[115.361,13.741],[115.375,12.514],[115.394,8.763],[124.332,8.746],[124.31,12.946],[124.301,13.655],[124.197,16.867],[108.533,40.108],[108.189,40.316]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-0.349,-6.3],[0,0],[0,0],[0,0],[1.588,2.775],[0,0],[2.936,1.899],[0,0]],"o":[[0,0],[5.405,3.257],[0,0],[0,0],[0,0],[-0.182,-3.576],[0,0],[-1.636,-2.738],[0,0],[0,0]],"v":[[-25.638,-58.272],[26.245,-27.009],[36.377,-10.182],[39.728,50.165],[96.73,15.843],[93.251,-44.426],[91.198,-54.439],[91.105,-54.599],[83.545,-61.053],[31.21,-92.501]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0.358,6.305],[0,0],[-2.166,1.691],[0,0],[0,0],[-3.539,-2.139],[0,0],[-0.359,-6.304],[0,0],[2.494,-1.603],[0.182,-0.099],[0,0],[0.182,-0.1],[0,0],[0,0],[3.323,2.008]],"o":[[-5.404,-3.266],[0,0],[-0.216,-3.797],[0,0],[0,0],[2.588,-1.471],[0,0],[5.404,3.266],[0,0],[0.234,4.111],[-0.256,0.164],[0,0],[-0.176,0.116],[0,0],[0,0],[-2.493,1.206],[0,0]],"v":[[-91.683,66.939],[-101.829,50.087],[-105.488,-14.242],[-102.227,-22.676],[-102.255,-22.723],[27.14,-100.635],[36.762,-99.894],[91.906,-66.565],[102.053,-49.713],[105.711,14.617],[101.803,23.364],[101.151,23.757],[-26.721,100.751],[-27.258,101.075],[-27.592,101.276],[-27.606,101.254],[-36.538,100.269]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":10,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[47.233,78.444],[78.444,-47.233],[-47.233,-78.444],[-78.445,47.234]],"o":[[-47.234,-78.445],[-78.445,47.233],[47.233,78.445],[78.444,-47.233]],"v":[[142.036,-85.523],[-85.524,-142.036],[-142.037,85.523],[85.523,142.036]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.098039217293,0.411764711142,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":29,"ty":4,"nm":"Pancake","parent":14,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-80.839,"ix":10},"p":{"a":0,"k":[821.084,-157.321,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.34,-6.068],[6.631,2.557],[-2.341,6.068],[-6.632,-2.558]],"o":[[-2.34,6.068],[-6.632,-2.558],[2.34,-6.068],[6.631,2.558]],"v":[[59.789,-2.786],[44.223,1.811],[35.775,-12.048],[51.341,-16.645]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.341,-6.068],[6.632,2.557],[-2.34,6.068],[-6.631,-2.558]],"o":[[-2.34,6.068],[-6.631,-2.558],[2.34,-6.068],[6.632,2.558]],"v":[[-18.249,-32.884],[-33.815,-28.287],[-42.263,-42.146],[-26.697,-46.743]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[48.622,18.753],[-6.848,18.004],[0.011,-0.028],[-66.277,-25.562],[-8.581,22.248],[-0.01,0.028]],"o":[[-48.623,-18.753],[-0.011,0.028],[-8.581,22.248],[66.277,25.562],[0.011,-0.028],[-7.015,17.939]],"v":[[-5.643,14.909],[-95.576,-56.371],[-95.609,-56.287],[-8.438,22.156],[108.83,22.562],[108.862,22.478]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.996078431606,0.86274510622,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[21.491,8.289],[3.169,-8.216],[-1.312,-6.355],[2.283,0.37],[8.139,-21.103],[-66.165,-25.55],[-0.027,-0.01],[-0.026,-0.01],[-8.574,22.23],[10.996,7.131],[-1.178,0.861],[-2.519,6.531],[14.93,5.758],[7.104,-17.281],[2.18,0.841],[0,0],[-0.423,1.174]],"o":[[-14.93,-5.758],[-2.519,6.531],[0.295,1.43],[-12.936,-2.099],[-8.574,22.23],[0.027,0.01],[0.026,0.01],[66.186,25.496],[8.14,-21.104],[-1.94,-1.259],[5.241,-3.828],[3.169,-8.217],[-21.491,-8.289],[-0.473,1.153],[0,0],[-2.181,-0.841],[6.339,-17.575]],"v":[[-6.459,-107.676],[-33.722,-101.927],[-31.988,-72.881],[-35.618,-71.013],[-95.56,-56.413],[-8.548,21.969],[-8.468,21.999],[-8.39,22.03],[108.72,22.375],[74.106,-28.694],[72.67,-32.515],[93.46,-52.874],[77.118,-75.441],[36.902,-52.277],[32.12,-51.701],[10.944,-59.868],[7.787,-63.507]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.819607853889,0.533333361149,0.309803932905,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.34,-6.068],[6.631,2.557],[-2.341,6.068],[-6.632,-2.558]],"o":[[-2.34,6.068],[-6.632,-2.558],[2.34,-6.068],[6.631,2.558]],"v":[[59.789,-2.786],[44.223,1.811],[35.775,-12.048],[51.341,-16.645]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.341,-6.068],[6.632,2.557],[-2.34,6.068],[-6.631,-2.558]],"o":[[-2.34,6.068],[-6.631,-2.558],[2.34,-6.068],[6.632,2.558]],"v":[[-18.249,-32.884],[-33.815,-28.287],[-42.263,-42.146],[-26.697,-46.743]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[48.622,18.753],[-6.848,18.004],[0.011,-0.028],[-66.277,-25.562],[-8.581,22.248],[-0.01,0.028]],"o":[[-48.623,-18.753],[-0.011,0.028],[-8.581,22.248],[66.277,25.562],[0.011,-0.028],[-7.015,17.939]],"v":[[-5.643,14.909],[-95.576,-56.371],[-95.609,-56.287],[-8.438,22.156],[108.83,22.562],[108.862,22.478]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.996078431606,0.86274510622,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[21.491,8.289],[3.169,-8.216],[-1.312,-6.355],[2.283,0.37],[8.139,-21.103],[-66.165,-25.55],[-0.027,-0.01],[-0.026,-0.01],[-8.574,22.23],[10.996,7.131],[-1.178,0.861],[-2.519,6.531],[14.93,5.758],[7.104,-17.281],[2.18,0.841],[0,0],[-0.423,1.174]],"o":[[-14.93,-5.758],[-2.519,6.531],[0.295,1.43],[-12.936,-2.099],[-8.574,22.23],[0.027,0.01],[0.026,0.01],[66.186,25.496],[8.14,-21.104],[-1.94,-1.259],[5.241,-3.828],[3.169,-8.217],[-21.491,-8.289],[-0.473,1.153],[0,0],[-2.181,-0.841],[6.339,-17.575]],"v":[[-6.459,-107.676],[-33.722,-101.927],[-31.988,-72.881],[-35.618,-71.013],[-95.56,-56.413],[-8.548,21.969],[-8.468,21.999],[-8.39,22.03],[108.72,22.375],[74.106,-28.694],[72.67,-32.515],[93.46,-52.874],[77.118,-75.441],[36.902,-52.277],[32.12,-51.701],[10.944,-59.868],[7.787,-63.507]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.819607853889,0.533333361149,0.309803932905,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[16.399,15.349],[-4.924,12.767],[-14.089,1.454],[-7.759,-1.004],[0.435,4.204],[-1.559,4.043],[-6.768,1.679],[-10.193,-3.932],[-4.257,-4.734],[-0.952,-4.46],[2.58,-8.02],[0,0],[-6.502,4.682],[-6.055,0.62],[-7.966,-3.073],[-4.108,-6.116],[1.845,-4.785],[4.208,-3.778],[2.606,-1.98],[-7.416,-8.258],[4.744,-12.301],[22.729,-0.367],[34.525,13.301]],"o":[[-34.515,-13.328],[-16.596,-15.534],[4.744,-12.301],[11.041,-1.139],[-0.601,-3.217],[-0.581,-5.626],[1.845,-4.784],[7.15,-1.774],[7.967,3.072],[4.069,4.525],[1.673,7.835],[0,0],[3.474,-7.675],[3.7,-2.665],[6.333,-0.65],[10.195,3.931],[3.887,5.788],[-1.559,4.042],[-3.146,2.824],[6.424,4.466],[9.464,10.538],[-4.924,12.767],[-22.459,0.363],[0,0]],"v":[[-10.846,27.86],[-87.88,-15.916],[-105.631,-59.522],[-72.969,-78.133],[-42.824,-77.349],[-44.549,-88.944],[-43.793,-105.036],[-31.351,-115.543],[-4.72,-112.231],[13.666,-100.256],[20.738,-86.555],[18.389,-62.223],[28.153,-58.458],[42.752,-78.065],[57.192,-83.468],[78.856,-79.997],[100.816,-64.568],[102.98,-48.427],[92.734,-35.997],[83.67,-28.563],[106.534,-8.901],[118.24,26.821],[75.806,47.215],[-10.673,27.926]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-96.132,-37.076],[19.577,-50.759],[96.132,37.076],[-19.577,50.759]],"o":[[96.132,37.076],[-19.577,50.759],[-96.132,-37.076],[19.577,-50.759]],"v":[[47.126,-122.188],[185.74,36.853],[-23.769,61.628],[-162.383,-97.413]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.086274512112,0.733333349228,0.749019622803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":2,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-117.51,-45.322],[23.968,-62.145],[117.51,45.322],[-23.968,62.145]],"o":[[117.51,45.322],[-23.968,62.145],[-117.51,-45.322],[23.968,-62.145]],"v":[[55.08,-142.8],[224.453,51.786],[-31.717,82.246],[-201.09,-112.34]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.164705887437,0.78823530674,0.839215695858,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":2,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-114.491,-43.529],[-29.542,56.213]],"o":[[0,0],[0,0],[-17.629,62.108],[113.079,42.993],[0,0]],"v":[[224.454,51.772],[-201.089,-112.353],[-219.693,-64.118],[-47.309,124.861],[205.85,100.01]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.086274512112,0.733333349228,0.749019622803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 12","np":1,"cix":2,"bm":0,"ix":12,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":30,"ty":4,"nm":"Tron","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":0,"k":[340.148,414.781,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.545,-2.097],[69.989,-12.83],[1.766,69.917]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[2.017,-6.215],[-7.138,69.667],[-57.051,-54.889]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[6.03,-14.452],[-50.53,-61.13],[42.022,-44.156]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[51.804,-40.786],[71.494,-22.19],[17.819,-12.455]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[53.811,-51.145],[-74.608,-74.609],[-7.012,94.504],[87.044,-19.569]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":6,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-68.676,0],[0,68.675],[68.675,0],[0,-68.676]],"o":[[68.675,0],[0,-68.676],[-68.676,0],[0,68.675]],"v":[[0.001,124.347],[124.348,0],[0.001,-124.347],[-124.348,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.921568632126,0,0.160784319043,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":33,"ty":4,"nm":"Fantom 2","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":0,"k":[286.924,641.972,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[46.931,46.931,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-0.054,0.968],[-11.295,6.875],[0,0],[0,0],[1.614,-2.517],[0.219,-3.642],[0,0],[0.017,-1.043],[0,0],[0,0]],"o":[[0,0],[0,0],[0.018,-1.221],[0.573,-10.35],[0,0],[0,0],[-4.961,2.987],[-1.338,2.087],[0,0],[-0.044,0.797],[0,0],[0,0],[0,0]],"v":[[-124.334,-8.745],[-124.312,-12.946],[-124.303,-13.655],[-124.199,-16.867],[-108.535,-40.108],[-108.191,-40.316],[-103.61,-32.709],[-113.1,-24.67],[-115.262,-16.654],[-115.274,-16.447],[-115.363,-13.741],[-115.377,-12.514],[-115.396,-8.762]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-2.869,-1.73],[0,0],[-0.055,-0.03],[0,0],[0,0],[0,0],[0,0],[2.87,1.73],[0,0],[0.054,0.031],[0,0],[0,0],[0,0]],"o":[[0.186,3.346],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.186,-3.345],[0,0],[-0.058,-0.035],[0,0],[0,0],[0,0],[0,0]],"v":[[-92.897,49.349],[-87.077,59.016],[-31.896,92.279],[-31.727,92.377],[-31.678,92.404],[-31.681,92.301],[-31.687,92.154],[-35.271,27.822],[-41.091,18.156],[-96.272,-15.107],[-96.44,-15.206],[-96.489,-15.233],[-96.487,-15.13],[-96.48,-14.982]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-23.022,87.948],[23.029,60.22],[-26.388,30.252]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-88.334,-20.521],[-38.916,9.446],[-42.283,-48.25]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[-0.091,-0.429],[0,0],[0.344,0.207],[0,0],[0.054,0.03],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[-0.336,-0.282],[0,0],[-0.057,-0.035],[0,0],[0,0],[0,0],[0,0],[0.022,0.401]],"v":[[-29.804,12.653],[22.905,-19.084],[21.883,-19.821],[-33.299,-53.025],[-33.467,-53.123],[-33.516,-53.15],[-33.514,-53.047],[-33.507,-52.9],[-29.976,11.405]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[-0.343,-0.207],[0,0],[-0.055,-0.031],[0,0],[0,0],[0,0],[0,0],[0.092,0.429]],"o":[[0.337,0.281],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.022,-0.4],[0,0]],"v":[[-25.127,20.421],[-24.105,21.157],[31.077,54.362],[31.246,54.46],[31.295,54.487],[31.293,54.384],[31.286,54.236],[27.755,-10.069],[27.582,-11.317]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[-1.614,2.517],[-0.219,3.642],[0,0],[-0.017,1.043],[0,0],[0,0],[0,0],[0,0],[0,0],[0.054,-0.968],[11.295,-6.875],[0,0]],"o":[[4.96,-2.987],[1.338,-2.087],[0,0],[0.044,-0.797],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.018,1.222],[-0.573,10.35],[0,0],[0,0]],"v":[[103.608,32.709],[113.098,24.67],[115.26,16.654],[115.272,16.447],[115.361,13.741],[115.375,12.514],[115.394,8.763],[124.332,8.746],[124.31,12.946],[124.301,13.655],[124.197,16.867],[108.533,40.108],[108.189,40.316]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-0.349,-6.3],[0,0],[0,0],[0,0],[1.588,2.775],[0,0],[2.936,1.899],[0,0]],"o":[[0,0],[5.405,3.257],[0,0],[0,0],[0,0],[-0.182,-3.576],[0,0],[-1.636,-2.738],[0,0],[0,0]],"v":[[-25.638,-58.272],[26.245,-27.009],[36.377,-10.182],[39.728,50.165],[96.73,15.843],[93.251,-44.426],[91.198,-54.439],[91.105,-54.599],[83.545,-61.053],[31.21,-92.501]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0.358,6.305],[0,0],[-2.166,1.691],[0,0],[0,0],[-3.539,-2.139],[0,0],[-0.359,-6.304],[0,0],[2.494,-1.603],[0.182,-0.099],[0,0],[0.182,-0.1],[0,0],[0,0],[3.323,2.008]],"o":[[-5.404,-3.266],[0,0],[-0.216,-3.797],[0,0],[0,0],[2.588,-1.471],[0,0],[5.404,3.266],[0,0],[0.234,4.111],[-0.256,0.164],[0,0],[-0.176,0.116],[0,0],[0,0],[-2.493,1.206],[0,0]],"v":[[-91.683,66.939],[-101.829,50.087],[-105.488,-14.242],[-102.227,-22.676],[-102.255,-22.723],[27.14,-100.635],[36.762,-99.894],[91.906,-66.565],[102.053,-49.713],[105.711,14.617],[101.803,23.364],[101.151,23.757],[-26.721,100.751],[-27.258,101.075],[-27.592,101.276],[-27.606,101.254],[-36.538,100.269]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":10,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[47.233,78.444],[78.444,-47.233],[-47.233,-78.444],[-78.445,47.234]],"o":[[-47.234,-78.445],[-78.445,47.233],[47.233,78.445],[78.444,-47.233]],"v":[[142.036,-85.523],[-85.524,-142.036],[-142.037,85.523],[85.523,142.036]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.098039217293,0.411764711142,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":34,"ty":4,"nm":"Avalanche 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":15,"ix":10},"p":{"a":0,"k":[-472,-228,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[40.25,40.25,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.713,4.836],[0,0],[0,0],[2.171,-7.872],[0,0],[-7.98,2.134],[0,0],[0,0],[0,0],[-1.785,6.573],[0,0]],"o":[[0,0],[0,0],[-5.81,-5.738],[0,0],[-2.171,7.872],[0,0],[0,0],[0,0],[6.613,-1.769],[0,0],[1.731,-6.32]],"v":[[12.398,-54.356],[-6.769,-73.496],[-14.95,-81.708],[-29.315,-77.867],[-68.784,66.92],[-58.206,77.24],[-37.913,71.814],[-24.004,68.095],[-21.61,67.455],[-6.227,52.345],[17.856,-33.941]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.011,-7.824],[0,0],[-7.549,2.019],[0,0],[5.618,5.665]],"o":[[-5.648,-5.776],[0,0],[-2.041,7.713],[0,0],[7.659,-2.048],[0,0]],"v":[[55.303,-12.004],[41.517,-8.318],[28.756,40.847],[38.928,51.267],[86.847,38.455],[90.57,24.319]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-66.345,17.74],[-17.74,-66.345],[66.345,-17.74],[17.74,66.345]],"o":[[66.345,-17.74],[17.74,66.345],[-66.345,17.74],[-17.74,-66.345]],"v":[[-32.12,-120.128],[120.128,-32.12],[32.12,120.128],[-120.128,32.12]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.909803926945,0.254901975393,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":35,"ty":4,"nm":"Avalanche","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[632,-556,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.713,4.836],[0,0],[0,0],[2.171,-7.872],[0,0],[-7.98,2.134],[0,0],[0,0],[0,0],[-1.785,6.573],[0,0]],"o":[[0,0],[0,0],[-5.81,-5.738],[0,0],[-2.171,7.872],[0,0],[0,0],[0,0],[6.613,-1.769],[0,0],[1.731,-6.32]],"v":[[12.398,-54.356],[-6.769,-73.496],[-14.95,-81.708],[-29.315,-77.867],[-68.784,66.92],[-58.206,77.24],[-37.913,71.814],[-24.004,68.095],[-21.61,67.455],[-6.227,52.345],[17.856,-33.941]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.011,-7.824],[0,0],[-7.549,2.019],[0,0],[5.618,5.665]],"o":[[-5.648,-5.776],[0,0],[-2.041,7.713],[0,0],[7.659,-2.048],[0,0]],"v":[[55.303,-12.004],[41.517,-8.318],[28.756,40.847],[38.928,51.267],[86.847,38.455],[90.57,24.319]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-66.345,17.74],[-17.74,-66.345],[66.345,-17.74],[17.74,66.345]],"o":[[66.345,-17.74],[17.74,66.345],[-66.345,17.74],[-17.74,-66.345]],"v":[[-32.12,-120.128],[120.128,-32.12],[32.12,120.128],[-120.128,32.12]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.909803926945,0.254901975393,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":36,"ty":4,"nm":"BNB","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-34]},{"t":150,"s":[6.846]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[72,-140,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[40,-254,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-101.16,37.76],[-128.935,50.316],[-96.676,86.793],[-21.206,52.554],[-33.123,39.078],[-80.818,60.762]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-121.501,14.759],[-105.643,-11.272],[-133.418,1.283],[-149.276,27.314],[-137.359,40.79],[-109.584,28.234]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-74.445,-38.862],[-46.67,-51.417],[-30.812,-77.448],[-58.587,-64.893]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-69.54,42.301],[-41.765,29.745],[-53.683,16.269],[-81.458,28.825]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-13.319,30.259],[-1.401,43.735],[26.374,31.179],[42.232,5.148],[30.314,-8.327],[14.456,17.704]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[0.385,-105.038],[28.16,-117.593],[40.077,-104.118],[55.935,-130.149],[44.018,-143.624],[16.243,-131.069]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[68.843,-71.59],[41.489,-26.905],[53.407,-13.429],[96.618,-84.146],[64.36,-120.623],[48.502,-94.592]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[49.141,-62.655],[37.224,-76.13],[21.366,-50.099],[33.283,-36.624]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[16.882,-99.132],[-10.893,-86.577],[-38.246,-41.891],[-85.941,-20.208],[-101.799,5.823],[-89.882,19.299],[-42.187,-2.385],[-21.846,20.617],[5.93,8.062],[21.787,-17.97],[1.446,-40.971],[28.8,-85.656]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ind":9,"ty":"sh","ix":10,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-122.14,-17.178],[-78.929,-87.895],[-3.459,-122.134],[-19.317,-96.102],[-67.012,-74.419],[-94.365,-29.734]],"c":true},"ix":2},"nm":"Path 10","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":11,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-93.039,82.278],[-43.445,-49.126],[93.039,-82.278],[43.445,49.126]],"o":[[93.039,-82.278],[43.444,49.126],[-93.039,82.278],[-43.445,-49.126]],"v":[[-104.583,-118.256],[142.541,-178.283],[52.743,59.646],[-194.381,119.673]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.866666674614,0.670588254929,0.121568627656,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-113.73,100.576],[-53.189,-60.145],[113.73,-100.576],[53.189,60.145]],"o":[[113.73,-100.576],[53.189,60.145],[-113.73,100.576],[-53.189,-60.145]],"v":[[-122.229,-138.213],[180.005,-211.42],[70.387,79.593],[-231.847,152.8]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176474094,0.72549021244,0.043137256056,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-110.136,98.341],[43.749,62.816]],"o":[[0,0],[0,0],[56.669,53.342],[108.777,-97.128],[0,0]],"v":[[179.997,-211.429],[-231.856,152.79],[-190.571,199.474],[107.335,119.933],[221.283,-164.744]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.709803938866,0.537254929543,0.050980392843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":1,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":39,"ty":4,"nm":"Eth 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-21.105]},{"t":150,"s":[-21.105]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-670,-102,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-180,344,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[36.284,36.284,100]},{"t":150,"s":[36.284,36.284,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":40,"ty":4,"nm":"Eth 4","parent":11,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-74.714,"ix":10},"p":{"a":0,"k":[705.425,-382.651,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[-35.106,-35.106,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":41,"ty":4,"nm":"Eth 3","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-17.2,"ix":10},"p":{"a":0,"k":[438,-101,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[-15.816,-15.816,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":42,"ty":4,"nm":"Eth","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-97,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-710.394,293.403,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-778.394,249.403,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[79.395,79.395,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":43,"ty":4,"nm":"Polygon 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-483.473,-767.951,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-458,-831,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[35.714,35.714,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,2.213],[0,0],[1.91,1.106],[0,0],[1.916,-1.101],[0,0],[0,-2.207],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.091,0],[0.934,-0.543],[0,0],[0,-2.212],[0,0],[-1.91,-1.106],[0,0],[-1.915,1.102],[0,0],[0,2.208],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-1.915,1.101]],"o":[[0,0],[1.915,-1.106],[0,0],[0,-2.207],[0,0],[-1.915,-1.106],[0,0],[-1.915,1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.939,-0.543],[-1.091,0],[0,0],[-1.915,1.106],[0,0],[0,2.207],[0,0],[1.91,1.102],[0,0],[1.915,-1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.916,1.101],[0,0]],"v":[[60.391,6.113],[96.549,-14.766],[99.648,-20.141],[99.648,-61.893],[96.549,-67.268],[60.391,-88.146],[54.186,-88.146],[18.029,-67.268],[14.929,-61.893],[14.929,12.724],[-10.427,27.362],[-35.783,12.724],[-35.783,-16.556],[-10.427,-31.193],[6.298,-21.539],[6.298,-41.181],[-7.327,-49.045],[-10.432,-49.875],[-13.532,-49.045],[-49.689,-28.166],[-52.789,-22.792],[-52.789,18.96],[-49.689,24.335],[-13.532,45.213],[-7.327,45.213],[28.831,24.34],[31.93,18.965],[31.93,-55.652],[32.39,-55.912],[57.286,-70.289],[82.642,-55.652],[82.642,-26.371],[57.286,-11.734],[40.588,-21.377],[40.588,-1.736],[54.186,6.118],[60.391,6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[163.332,-161.368],[-116.474,-161.368],[-116.474,118.439],[163.332,118.439]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.482352942228,0.247058823705,0.89411765337,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":244,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":44,"ty":4,"nm":"Polygon 3","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-280,528,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[33.804,33.804,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,2.213],[0,0],[1.91,1.106],[0,0],[1.916,-1.101],[0,0],[0,-2.207],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.091,0],[0.934,-0.543],[0,0],[0,-2.212],[0,0],[-1.91,-1.106],[0,0],[-1.915,1.102],[0,0],[0,2.208],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-1.915,1.101]],"o":[[0,0],[1.915,-1.106],[0,0],[0,-2.207],[0,0],[-1.915,-1.106],[0,0],[-1.915,1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.939,-0.543],[-1.091,0],[0,0],[-1.915,1.106],[0,0],[0,2.207],[0,0],[1.91,1.102],[0,0],[1.915,-1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.916,1.101],[0,0]],"v":[[60.391,6.113],[96.549,-14.766],[99.648,-20.141],[99.648,-61.893],[96.549,-67.268],[60.391,-88.146],[54.186,-88.146],[18.029,-67.268],[14.929,-61.893],[14.929,12.724],[-10.427,27.362],[-35.783,12.724],[-35.783,-16.556],[-10.427,-31.193],[6.298,-21.539],[6.298,-41.181],[-7.327,-49.045],[-10.432,-49.875],[-13.532,-49.045],[-49.689,-28.166],[-52.789,-22.792],[-52.789,18.96],[-49.689,24.335],[-13.532,45.213],[-7.327,45.213],[28.831,24.34],[31.93,18.965],[31.93,-55.652],[32.39,-55.912],[57.286,-70.289],[82.642,-55.652],[82.642,-26.371],[57.286,-11.734],[40.588,-21.377],[40.588,-1.736],[54.186,6.118],[60.391,6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[163.332,-161.368],[-116.474,-161.368],[-116.474,118.439],[163.332,118.439]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.482352942228,0.247058823705,0.89411765337,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":244,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":45,"ty":4,"nm":"Polygon","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":0,"k":[449.061,-522.249,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[90.816,90.816,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,2.213],[0,0],[1.91,1.106],[0,0],[1.916,-1.101],[0,0],[0,-2.207],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.091,0],[0.934,-0.543],[0,0],[0,-2.212],[0,0],[-1.91,-1.106],[0,0],[-1.915,1.102],[0,0],[0,2.208],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-1.915,1.101]],"o":[[0,0],[1.915,-1.106],[0,0],[0,-2.207],[0,0],[-1.915,-1.106],[0,0],[-1.915,1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.939,-0.543],[-1.091,0],[0,0],[-1.915,1.106],[0,0],[0,2.207],[0,0],[1.91,1.102],[0,0],[1.915,-1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.916,1.101],[0,0]],"v":[[60.391,6.113],[96.549,-14.766],[99.648,-20.141],[99.648,-61.893],[96.549,-67.268],[60.391,-88.146],[54.186,-88.146],[18.029,-67.268],[14.929,-61.893],[14.929,12.724],[-10.427,27.362],[-35.783,12.724],[-35.783,-16.556],[-10.427,-31.193],[6.298,-21.539],[6.298,-41.181],[-7.327,-49.045],[-10.432,-49.875],[-13.532,-49.045],[-49.689,-28.166],[-52.789,-22.792],[-52.789,18.96],[-49.689,24.335],[-13.532,45.213],[-7.327,45.213],[28.831,24.34],[31.93,18.965],[31.93,-55.652],[32.39,-55.912],[57.286,-70.289],[82.642,-55.652],[82.642,-26.371],[57.286,-11.734],[40.588,-21.377],[40.588,-1.736],[54.186,6.118],[60.391,6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[163.332,-161.368],[-116.474,-161.368],[-116.474,118.439],[163.332,118.439]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.482352942228,0.247058823705,0.89411765337,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":244,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0}],"markers":[]}');; // CONCATENATED MODULE: ./src/routes/defiwallet/lottie/animate-desktop.json
                const animate_desktop_namespaceObject = JSON.parse('{"v":"4.8.0","meta":{"g":"LottieFiles AE 3.4.5","a":"","k":"","d":"","tc":""},"fr":25,"ip":0,"op":151,"w":1970,"h":1970,"nm":"Coinstorm_03","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Neutron","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-159.564]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[985.5,1244,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[1234.5,1461,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[129.004,129.004,100]},{"t":150,"s":[44.792,44.792,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-6.796,0],[-1.882,1.168],[0,0],[0,0],[0,0],[0,0],[0,-2.364]],"o":[[2.377,0],[0,0],[0,0],[0,0],[0,0],[-1.155,1.875],[0,6.796]],"v":[[-0.094,12.212],[6.384,10.371],[19.294,25.594],[-25.781,25.594],[-25.781,-19.649],[-10.578,-6.54],[-12.4,-0.094]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[2.157,-1.866],[0,0],[0,0],[0,0],[0,0],[0,3.024],[6.796,0]],"o":[[0,0],[0,0],[0,0],[0,0],[1.809,-2.142],[0,-6.796],[-3.076,0]],"v":[[-8.14,-9.405],[-22.026,-25.781],[25.594,-25.781],[25.594,21.921],[9.312,7.841],[12.212,-0.094],[-0.094,-12.4]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":1.249,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,26.51],[26.51,0],[0,-26.51],[-26.51,0]],"o":[[0,-26.51],[-26.51,0],[0,26.51],[26.51,0]],"v":[[48,0],[0,-48],[-48,0],[0,48]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.04705882445,0.04705882445,0.04705882445,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Kava","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-146.853]},{"t":150,"s":[-11.31]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[460,862,0],"to":[153,526.333,0],"ti":[0,0,0]},{"t":150,"s":[1126,1116,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[226.83,226.83,100]},{"t":150,"s":[125,125,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[13.755,27.73],[-7.461,0],[13.755,-27.729],[25.878,-27.729],[4.977,0],[25.878,27.73]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-12.707,27.743],[-12.707,-27.717],[-22.39,-27.717],[-22.39,27.743]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,26.51],[26.51,0],[0,-26.51]],"o":[[26.51,0],[0,-26.51],[-26.51,0],[0,26.51]],"v":[[0,48],[48,0],[0,-48],[-48,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.337254911661,0.309803932905,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Layer 1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[195.195]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1183,1084,0],"to":[-493.333,-101.667,0],"ti":[691.333,441.667,0]},{"t":150,"s":[1067,1284,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[239.583,239.583,100]},{"t":150,"s":[85.417,85.417,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.547,0],[0,1.65],[1.547,0],[0,-1.65]],"o":[[1.547,0],[0,-1.65],[-1.547,0],[0,1.65]],"v":[[-5.839,30.937],[-3.038,27.948],[-5.839,24.96],[-8.641,27.948]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.547,0],[0,1.65],[1.547,0],[0,-1.65]],"o":[[1.547,0],[0,-1.65],[-1.547,0],[0,1.65]],"v":[[-26.96,-5.543],[-24.159,-8.531],[-26.96,-11.52],[-29.762,-8.531]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.547,0],[0,1.65],[1.547,0],[0,-1.65]],"o":[[1.547,0],[0,-1.65],[-1.547,0],[0,1.65]],"v":[[20.083,-16.104],[22.884,-19.092],[20.083,-22.08],[17.281,-19.092]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-2.682,0],[0,2.682],[2.682,0],[0,-2.682]],"o":[[2.682,0],[0,-2.682],[-2.682,0],[0,2.682]],"v":[[0.055,4.912],[4.911,0.056],[0.055,-4.8],[-4.801,0.056]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.717647075653,0.72549021244,0.784313738346,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0.187],[0,0],[0,0],[0,0],[-0.56,-1.681],[0.374,-0.187],[0,0],[0,0],[0,0]],"o":[[-0.374,-0.934],[3.549,-0.747],[13.821,3.175],[18.864,13.261],[0,0.374],[-2.055,0.934],[-16.249,-4.296],[-11.58,-6.35],[-8.778,-7.471]],"v":[[-34.489,-19.069],[-34.116,-20.189],[-25.524,-19.255],[12.764,-0.765],[34.99,19.966],[34.616,20.9],[27.332,20.527],[-1.804,8.2],[-24.964,-7.863]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-2.428,4.482],[19.984,11.58],[2.615,-4.482],[-20.171,-11.58]],"o":[[2.615,-4.482],[-19.984,-11.58],[-2.615,4.482],[19.984,11.58]],"v":[[36.484,21.46],[4.919,-7.676],[-36.17,-20.563],[-4.419,8.573]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.435294121504,0.450980395079,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":3,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-1.681,-0.56],[0,-0.374],[0,0],[0,0],[0,0]],"o":[[-0.934,-0.187],[1.121,-3.362],[9.525,-10.272],[20.918,-9.712],[0.373,0.187],[-0.187,2.241],[-11.953,11.953],[-11.393,6.911],[-10.833,3.922]],"v":[[-33.929,20.716],[-34.676,19.782],[-29.633,12.684],[5.48,-11.222],[34.429,-20],[34.99,-19.253],[31.067,-13.277],[5.853,5.774],[-19.548,17.914]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[2.615,4.482],[20.171,-11.393],[-2.615,-4.482],[-20.171,11.393]],"o":[[-2.615,-4.482],[-20.171,11.58],[2.615,4.482],[20.171,-11.58]],"v":[[36.67,-20.561],[-4.419,-7.86],[-36.17,21.276],[4.919,8.576]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.435294121504,0.450980395079,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-1.121,1.121],[-0.187,-0.374],[0,0],[0,0],[0,0]],"o":[[-0.56,0.747],[-2.428,-2.802],[-4.109,-13.448],[2.055,-22.973],[0.187,-0.187],[1.681,1.307],[4.296,16.249],[0.373,13.261],[-1.868,11.393]],"v":[[0.297,39.378],[-0.823,39.565],[-4.372,31.721],[-7.547,-10.676],[-0.823,-40.186],[0.111,-40.186],[3.286,-33.649],[7.208,-2.271],[4.967,25.744]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[5.043,0],[0,-23.16],[-5.043,0],[0,23.16]],"o":[[-5.23,0],[0,23.16],[5.043,0],[0,-23.16]],"v":[[-0.263,-42.24],[-9.602,-0.217],[-0.263,41.807],[9.076,-0.217]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.435294121504,0.450980395079,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":3,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-15.369,0],[0,15.37],[15.369,0],[0,-15.369]],"o":[[15.369,0],[0,-15.369],[-15.369,0],[0,15.37]],"v":[[-0.011,27.818],[27.818,-0.011],[-0.011,-27.84],[-27.84,-0.011]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.105882354081,0.117647059262,0.211764708161,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,26.51],[26.51,0],[0,-26.51]],"o":[[26.51,0],[0,-26.51],[-26.51,0],[0,26.51]],"v":[[0,48],[48,0],[0,-48],[-48,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.180392161012,0.192156866193,0.282352954149,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"Apollo finance","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-35.802]},{"t":150,"s":[14.591]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[718,1356.5,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[982,1434.5,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[102.062,102.062,100]},{"t":150,"s":[43.9,43.9,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.613,-5.583],[-6.936,-4.005],[-6.85,-1.329],[14.742,10.918]],"o":[[1.613,5.583],[5.11,2.952],[-3.049,-13.724],[-4.313,5.078]],"v":[[-46.652,-2.879],[-33.508,11.864],[-15.322,18.374],[-42.5,-19.272]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-0.042,-0.024],[0,0],[-0.015,-0.034],[0.015,-0.032],[0,0],[0.041,-0.023],[0.057,-0.008],[0.057,0.01],[0.042,0.024],[0,0],[0.016,0.033],[-0.013,0.032],[0,0],[-0.041,0.023],[-0.057,0.008],[-0.057,-0.01]],"o":[[0,0],[0.042,0.025],[0.016,0.033],[0,0],[-0.014,0.033],[-0.04,0.023],[-0.056,0.008],[-0.057,-0.01],[0,0],[-0.042,-0.025],[-0.016,-0.033],[0,0],[0.014,-0.033],[0.04,-0.023],[0.056,-0.008],[0.057,0.01]],"v":[[-11.669,20.612],[-7.55,22.99],[-7.462,23.079],[-7.461,23.18],[-8.923,26.432],[-9.006,26.517],[-9.153,26.565],[-9.325,26.562],[-9.476,26.51],[-13.595,24.132],[-13.684,24.045],[-13.689,23.946],[-12.223,20.691],[-12.139,20.606],[-11.992,20.558],[-11.82,20.561]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[6.051,0.686],[-3.179,9.423],[-11.462,6.949],[-5.14,-1.97],[-3.445,-2.954],[-1.227,-3.489],[1.179,-3.492],[3.405,-2.964],[5.112,-1.985],[6.041,-0.703]],"o":[[-6.102,-8.939],[3.179,-9.424],[6.052,0.686],[5.139,1.97],[3.446,2.955],[1.227,3.489],[-1.178,3.492],[-3.404,2.964],[-5.112,1.984],[-6.042,0.703]],"v":[[-9.716,19.246],[-14.191,-8.873],[8.229,-33.944],[25.18,-29.92],[38.183,-22.461],[45.261,-12.701],[45.334,-2.126],[38.393,7.653],[25.494,15.149],[8.601,19.22]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[16.173,-9.337],[0,0],[16.173,9.337],[0,0],[-16.173,9.337],[0,0],[-16.173,-9.337],[0,0]],"o":[[0,0],[-16.173,9.337],[0,0],[-16.173,-9.337],[0,0],[16.173,-9.337],[0,0],[16.173,9.337]],"v":[[70.994,10.287],[29.283,34.368],[-29.283,34.368],[-70.994,10.287],[-70.994,-23.527],[-29.283,-47.608],[29.283,-47.608],[70.994,-23.527]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.404,0.286,1,0.5,0.518,0.269,0.996,1,0.631,0.251,0.992],"ix":9}},"s":{"a":0,"k":[64.039,39.985],"ix":5},"e":{"a":0,"k":[-51.902,-48.258],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.232,1.289],[0,0],[16.173,-9.337],[0,0],[1.616,-1.479],[0,0],[0,0],[-8.248,-4.762],[0,0],[-16.173,9.337],[0,0],[0.143,6.225],[0,0],[0,0]],"o":[[-1.616,-1.479],[0,0],[-16.173,-9.337],[0,0],[-2.233,1.289],[0,0],[0,0],[-0.164,6.24],[0,0],[16.173,9.337],[0,0],[8.227,-4.75],[0,0],[0,0],[0,0]],"v":[[76.768,-6.118],[70.995,-10.286],[29.285,-34.367],[-29.282,-34.367],[-70.992,-10.286],[-76.765,-6.118],[-83.117,-6.118],[-83.117,6.255],[-70.992,23.528],[-29.282,47.609],[29.285,47.609],[70.995,23.528],[83.121,6.302],[83.123,6.302],[83.123,-6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.318,0.224,0.784,0.5,0.427,0.245,0.79,1,0.537,0.267,0.796],"ix":9}},"s":{"a":0,"k":[-85.457,8.874],"ix":5},"e":{"a":0,"k":[87.572,17.04],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"ACA","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-61.536]},{"t":150,"s":[17.134]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1028,402,0],"to":[-590.333,671.667,0],"ti":[0,0,0]},{"t":150,"s":[1406,1494,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[136.853,136.853,100]},{"t":150,"s":[114.921,114.921,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-3.165,0],[-0.256,-0.01],[-1.767,-0.327],[0,0],[2.997,0.008],[3.848,-2.065],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[2.851,-0.86],[0.256,0],[1.797,0.043],[0,0],[-2.812,-1.036],[-4.367,-0.015],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-2.265,-19.557],[-10.231,-5.755],[-0.861,-6.999],[-0.092,-6.99],[5.263,-6.434],[7.921,-1.829],[-0.861,-3.407],[-13.378,-0.284],[-13.319,-0.388],[-13.399,-0.25],[-17.56,-0.25],[-4.331,-23.16]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[16.987,-2.537],[19.067,-6.14],[1.749,-36.136],[-2.411,-36.136]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[1.498,-0.254],[0,0],[-0.755,0],[-1.753,-0.281],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[2.638,-0.008]],"o":[[-1.52,-0.001],[0,0],[0.761,-0.051],[1.776,0.001],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.527,-0.757],[0,0]],"v":[[-0.934,-9.488],[-5.469,-9.109],[-3.211,-13.009],[-0.934,-13.086],[4.368,-12.662],[-4.371,-27.797],[-18.926,-2.596],[-21.006,-6.199],[-4.404,-34.955],[-4.371,-34.896],[-4.337,-34.953],[15.699,-0.25],[11.539,-0.25],[6.856,-8.36],[-0.934,-9.49]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[6.126,0],[0,0],[5.809,5.808],[0,8.214],[-3.403,5.093],[-5.659,2.344],[-6.008,-1.195],[-4.331,-4.331],[-1.195,-6.008],[2.344,-5.659],[5.093,-3.403]],"o":[[0,0],[-8.214,0],[-5.808,-5.809],[0,-6.125],[3.403,-5.093],[5.66,-2.344],[6.008,1.195],[4.331,4.332],[1.195,6.008],[-2.344,5.659],[-5.093,3.403]],"v":[[-1.003,16.249],[-1.003,16.247],[-22.904,7.176],[-31.975,-14.725],[-26.754,-31.931],[-12.854,-43.338],[5.04,-45.099],[20.898,-36.622],[29.374,-20.764],[27.611,-2.87],[16.204,11.03]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[-5.785,3.865],[-2.662,6.427],[1.357,6.823],[4.919,4.919],[6.824,1.357],[6.428,-2.662],[3.865,-5.785],[0,-6.957],[-6.597,-6.596],[-9.329,0]],"o":[[6.957,0],[5.785,-3.865],[2.663,-6.428],[-1.357,-6.823],[-4.92,-4.919],[-6.823,-1.357],[-6.427,2.662],[-3.865,5.785],[0.001,9.329],[6.597,6.596],[0,0]],"v":[[-1.088,20.538],[18.455,14.61],[31.41,-1.177],[33.412,-21.5],[23.785,-39.511],[5.774,-49.138],[-14.549,-47.136],[-30.335,-34.18],[-36.263,-14.638],[-25.96,10.234],[-1.088,20.536]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[21.038,0],[0,0],[0,21.044],[-21.038,0],[0,-21.038]],"o":[[0,0],[-21.038,0],[0,-21.044],[21.038,0],[0,21.038]],"v":[[-0.916,23.456],[-0.916,23.454],[-39.01,-14.64],[-0.916,-52.732],[37.175,-14.638]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[-23.219,0],[0,23.219],[23.217,0],[0,-23.213]],"o":[[23.217,0],[0,-23.219],[-23.217,0],[0,23.213]],"v":[[-1.088,27.399],[40.951,-14.64],[-1.088,-56.679],[-43.127,-14.64]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0.01,0.392,0.353,1,0.255,0.643,0.2,0.678,0.5,0.894,0.047,0.357,0.75,0.947,0.173,0.294,1,1,0.298,0.231],"ix":9}},"s":{"a":0,"k":[35.367,22.364],"ix":5},"e":{"a":0,"k":[-36.657,-54.727],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":8,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,26.51],[26.51,0],[0,-26.51]],"o":[[26.51,0],[0,-26.51],[-26.51,0],[0,26.51]],"v":[[-1.087,33.36],[46.913,-14.64],[-1.087,-62.64],[-49.087,-14.64]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"CFX","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[108.104]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[537,1195,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[585,1365,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[115.98,115.98,100]},{"t":150,"s":[85.632,85.632,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[24.375,-20.784],[-1.16,-46.32],[-26.767,-20.713],[-26.685,-8.744],[-1.268,-34.16],[24.333,-8.558]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.219607844949,0.631372570992,0.858823537827,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[12.311,-8.564],[-1.209,4.956],[-8.733,-2.569],[4.786,-16.088],[-1.226,-22.101],[-20.824,-2.504],[-1.28,17.04],[18.317,-2.558]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.101960785687,0.101960785687,0.101960785687,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,-26.51],[26.51,0],[0,26.51]],"o":[[26.51,0],[0,26.51],[-26.51,0],[0,-26.51]],"v":[[-1.087,-62.64],[46.913,-14.64],[-1.087,33.36],[-49.087,-14.64]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"Klaytan","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-220.193]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[323,373,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[1385,1149,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[134,134,100]},{"t":150,"s":[100,100,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-6.303,-6.745],[0,0]],"o":[[0,7.741],[0,0],[0,0]],"v":[[-33.653,-0.166],[-24.586,22.835],[-1.806,-32.013]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-0.591,-1.161],[22.963,-24.715],[1.289,-33.672],[-20.495,18.854]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.296,1.382],[-22.483,24.272],[0.186,33.671],[23.076,24.272]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,8.072],[5.861,6.303]],"o":[[0,0],[6.192,-6.635],[0,-8.625],[0,0]],"v":[[1.953,-0.277],[25.064,22.724],[34.021,-0.277],[24.954,-23.388]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.309803932905,0.278431385756,0.243137255311,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,-26.51],[26.51,0],[0,26.51]],"o":[[26.51,0],[0,26.51],[-26.51,0],[0,-26.51]],"v":[[0,-48],[48,0],[0,48],[-48,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"Lido","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-173.362]},{"t":150,"s":[15]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1304,703,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[388,1365,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[185.552,185.552,100]},{"t":150,"s":[130.118,130.118,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[1.271,-4.778],[5.755,-19.685],[-33.805,-18.58]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.409,1,0.498,0.447,0.704,0.58,0.484,0.692,1,0.161,0.471,0.937,0.409,1,0.704,0.85,1,0.7],"ix":9}},"s":{"a":0,"k":[-35.551,-20.41],"ix":5},"e":{"a":0,"k":[8.314,-14.092],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-33.795,-18.574],[-22.247,2.641],[1.268,-4.777]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.377,1,0.89,0.212,0.689,0.537,0.822,0.463,1,0.075,0.753,0.714,0.377,1,0.689,0.85,1,0.7],"ix":9}},"s":{"a":0,"k":[103.938,-21.058],"ix":5},"e":{"a":0,"k":[-71.586,-164.115],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-15.271,-11.309],[-20.4,6.046],[6.88,-2.549],[12.077,-19.852]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.337,0.949,1,0.5,0.337,0.775,0.963,1,0.337,0.6,0.925],"ix":9}},"s":{"a":0,"k":[-3.806,-7.011],"ix":5},"e":{"a":0,"k":[8.217,-1.744],"ix":6},"t":2,"h":{"a":0,"k":0,"ix":7},"a":{"a":0,"k":0,"ix":8},"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-17.774,-12.272],[-22.247,2.64],[1.269,-4.779],[5.744,-19.678]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.933,1,0.514,0.345,0.635,0.8,0.72,0.69,0.337,0.6,0.925],"ix":9}},"s":{"a":0,"k":[-0.19,24.677],"ix":5},"e":{"a":0,"k":[36.46,-8.739],"ix":6},"t":2,"h":{"a":0,"k":0,"ix":7},"a":{"a":0,"k":0,"ix":8},"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":60,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-14.234,2.224],[1.284,9.714],[14.135,-0.395],[0,0]],"o":[[0,0],[0,0],[4.13,7.582],[16.75,-2.617],[-1.092,-8.255],[0,0],[0,0]],"v":[[6.866,-2.551],[-20.416,6.054],[-20.05,6.726],[11.392,15.9],[39.395,-6.427],[13.324,-19.884],[12.071,-19.849]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.204,0.337,0.949,1,0.602,0.314,0.749,0.959,1,0.29,0.549,0.918],"ix":9}},"s":{"a":0,"k":[37.89,10.987],"ix":5},"e":{"a":0,"k":[4.308,-4.062],"ix":6},"t":2,"h":{"a":0,"k":0,"ix":7},"a":{"a":0,"k":0,"ix":8},"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-7.269,5.796],[0,0],[-8.651,-3.404],[0,0],[7.269,-5.796],[0,0],[8.651,3.404],[0,0]],"o":[[0,0],[7.269,-5.796],[0,0],[8.651,3.404],[0,0],[-7.269,5.796],[0,0],[-8.651,-3.404]],"v":[[-72.176,-3.383],[-21.334,-43.92],[7.491,-48.25],[67.999,-24.442],[70.501,-7.784],[19.659,32.753],[-9.166,37.083],[-69.673,13.274]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,1,1,1,0.5,0.951,0.955,0.959,1,0.902,0.91,0.918],"ix":9}},"s":{"a":0,"k":[-650.476,-1343.406],"ix":5},"e":{"a":0,"k":[-712.001,-1420.57],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-8.65,-3.403],[0,0],[-7.27,5.796],[0,0],[8.65,3.403],[0,0],[0,0],[0,0],[0,0],[7.27,-5.796],[0,0],[0,0],[0,0]],"o":[[-7.27,5.796],[0,0],[8.65,3.403],[0,0],[7.269,-5.796],[0,0],[0,0],[0,0],[0,0],[-8.65,-3.403],[0,0],[0,0],[0,0],[0,0]],"v":[[-70.499,7.798],[-67.999,24.454],[-7.505,48.251],[21.321,43.917],[72.176,3.367],[69.676,-13.289],[69.628,-13.309],[69.27,-15.691],[65.147,-15.071],[9.182,-37.086],[-19.644,-32.752],[-66.671,4.746],[-70.816,5.369],[-70.457,7.764]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.827450990677,0.827450990677,0.827450990677,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"Venus","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[47.698]},{"t":150,"s":[36.016]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[1633,1761,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[498,1131,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[77.55,77.55,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.044,-0.603],[0.487,-1.246],[-0.905,-1.165],[-1.81,-0.723],[-2.227,0],[-1.81,0.723],[-0.835,1.206],[0.418,1.286],[1.601,0.924],[1.392,0.322],[1.462,-0.04],[1.392,-0.322]],"o":[[-1.601,0.924],[-0.418,1.286],[0.835,1.206],[1.81,0.723],[2.227,0],[1.81,-0.723],[0.835,-1.206],[-0.418,-1.286],[-1.044,-0.603],[-1.392,-0.322],[-1.531,0],[-1.253,0.322]],"v":[[-40.378,-19.194],[-43.51,-15.859],[-42.814,-12.081],[-38.707,-9.148],[-32.443,-8.023],[-26.179,-9.148],[-22.072,-12.081],[-21.376,-15.859],[-24.508,-19.194],[-28.197,-20.601],[-32.513,-21.083],[-36.828,-20.601]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[1.114,-0.643],[0,0],[0,0],[0,0],[0,0],[-0.07,0.04],[-0.974,0],[-0.835,-0.241],[-0.626,-0.362],[-0.209,-0.522],[0,0],[0.209,-0.523],[0.557,-0.482],[0.835,-0.241],[0.974,-0.08],[0.07,0.04],[0,0],[0.07,-0.04],[0,0],[0,0],[-1.461,0.201],[-1.114,0.643],[-0.417,0.884],[0.348,0.844],[0,0],[1.114,0.643],[1.532,0.241],[1.461,-0.201]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.835,-0.241],[0.974,0],[0.835,0.241],[0.626,0.442],[0,0],[0.279,0.563],[-0.139,0.563],[-0.556,0.482],[-0.836,0.241],[0,0],[0,0],[0,0],[0,0],[0,0],[1.461,0.201],[1.462,-0.201],[1.044,-0.603],[0.418,-0.884],[0,0],[-0.348,-0.844],[-1.044,-0.603],[-1.461,-0.201],[-1.392,0.241]],"v":[[-8.29,-37.72],[-17.548,-32.375],[-17.617,-32.335],[-17.548,-32.295],[-17.478,-32.255],[-17.408,-32.295],[-14.624,-32.616],[-11.91,-32.255],[-9.682,-31.29],[-8.43,-29.844],[1.384,-8.585],[1.454,-6.938],[0.34,-5.411],[-1.817,-4.326],[-4.601,-3.843],[-4.741,-3.843],[-4.81,-3.803],[-4.81,-3.723],[-4.741,-3.683],[8.206,-1.673],[12.66,-1.673],[16.558,-2.959],[18.785,-5.21],[18.785,-7.782],[6.117,-35.51],[3.89,-37.76],[-0.008,-39.046],[-4.462,-39.046]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[-0.696,-1.286],[0,0],[0.627,-1.246],[1.601,-0.924],[2.228,-0.322],[2.158,0.362],[0,0],[0,0],[-0.069,0.04],[0,0],[-0.069,-0.04],[-1.462,0.442],[-1.044,0.763],[-0.279,0.964],[0.418,0.884],[0,0],[1.044,0.764],[1.531,0.402],[1.6,-0.04],[1.461,-0.442],[0,0],[0,0],[0,0],[0,0],[0,0],[-2.227,0.322],[-2.158,-0.362],[-1.601,-0.924]],"o":[[0,0],[0.557,1.286],[-0.557,1.286],[-1.601,0.924],[-2.227,0.321],[0,0],[0,0],[0,0],[0,0],[0,0],[1.671,0],[1.462,-0.442],[1.044,-0.764],[0.348,-0.924],[0,0],[-0.487,-0.924],[-1.114,-0.723],[-1.601,-0.362],[-1.671,0.08],[0,0],[0,0],[0,0],[0,0],[0,0],[1.601,-0.924],[2.227,-0.322],[2.227,0.322],[1.253,1.045]],"v":[[37.23,-48.008],[56.789,-5.853],[56.789,-1.995],[53.448,1.381],[47.601,3.31],[40.919,3.31],[28.182,1.341],[28.112,1.3],[28.112,1.22],[28.182,1.18],[28.321,1.18],[33.124,0.497],[36.952,-1.312],[38.971,-3.924],[38.831,-6.737],[22.405,-42.02],[20.108,-44.552],[16.071,-46.239],[11.199,-46.722],[6.466,-45.918],[6.396,-45.878],[6.326,-45.918],[6.257,-45.958],[6.326,-45.998],[15.792,-51.464],[21.639,-53.393],[28.321,-53.393],[34.168,-51.464]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0,0.271,0.302,0.612,0.25,0.275,0.512,0.765,0.5,0.278,0.722,0.918,0.75,0.394,0.741,0.729,1,0.51,0.761,0.541],"ix":9}},"s":{"a":0,"k":[88.957,-12.992],"ix":5},"e":{"a":0,"k":[-74.671,-15.936],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-18.444,10.649],[0,0],[-18.444,-10.649],[0,0],[18.444,-10.649],[0,0],[18.444,10.649],[0,0]],"o":[[0,0],[18.444,-10.649],[0,0],[18.444,10.649],[0,0],[-18.444,10.649],[0,0],[-18.444,-10.649]],"v":[[-69.644,-36.306],[-22.075,-63.77],[44.718,-63.77],[92.286,-36.306],[92.286,2.257],[44.718,29.721],[-22.075,29.721],[-69.644,2.257]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,0.075,0.086,0.122,0.5,0.237,0.243,0.261,1,0.4,0.4,0.4],"ix":9}},"s":{"a":0,"k":[-711.337,-1293.708],"ix":5},"e":{"a":0,"k":[-777.364,-1408.069],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-9.389,-5.421],[0,0],[-18.445,10.649],[0,0],[0.121,7.069],[0,0],[0,0],[2.544,1.469],[0,0],[18.444,-10.649],[0,0],[1.842,-1.686],[0,0]],"o":[[-0.17,7.104],[0,0],[18.444,10.649],[0,0],[9.342,-5.394],[0,0],[0,0],[-1.842,-1.686],[0,0],[-18.445,-10.649],[0,0],[-2.544,1.469],[0,0],[0,0]],"v":[[-83.477,-2.308],[-69.648,17.352],[-22.08,44.815],[44.713,44.815],[92.281,17.352],[106.112,-2.202],[106.112,-16.462],[98.86,-16.462],[92.281,-21.211],[44.713,-48.675],[-22.08,-48.675],[-69.648,-21.211],[-76.228,-16.462],[-83.477,-16.462]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0.043,0.412,0.412,0.412,0.309,0.243,0.249,0.267,0.575,0.075,0.086,0.122,0.788,0.237,0.243,0.261,1,0.4,0.4,0.4],"ix":9}},"s":{"a":0,"k":[-520,-556.859],"ix":5},"e":{"a":0,"k":[-781.037,-533.344],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":10,"ty":4,"nm":"Eth classic","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-35]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[617.5,783,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[731.5,1305,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[167.697,167.697,100]},{"t":150,"s":[86.081,86.081,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.915,-23.783],[10.825,-43.077],[31.464,-12.809]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[10.916,-23.783],[-9.8,-12.874],[10.826,-43.077],[31.465,-12.809]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.003921568859,0.784313738346,0.32549020648,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[6.913,-10.181]],"o":[[0,0],[-7.441,11.058],[0,0]],"v":[[10.919,4.357],[31.472,-6.67],[10.919,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[-7.441,11.058],[0,0]],"v":[[10.919,4.357],[31.472,-6.67],[10.919,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[6.153,9.066],[-5.868,-3.127],[0,0],[6.913,-10.181]],"o":[[7.274,3.858],[0,0],[-7.441,11.058],[-6.921,-10.159]],"v":[[-9.804,-6.673],[10.918,4.357],[31.471,-6.669],[10.918,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.003921568859,0.784313738346,0.32549020648,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[6.153,9.066],[-5.868,-3.127],[0,0],[6.913,-10.181]],"o":[[7.274,3.858],[0,0],[-7.441,11.058],[-6.921,-10.159]],"v":[[-9.804,-6.673],[10.918,4.357],[31.471,-6.669],[10.918,23.767]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[10.966,-7.92],[-9.8,-9.62],[10.949,1.391],[10.966,-7.92]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[10.966,-7.92],[31.464,-9.7],[10.984,1.392],[10.966,-7.92]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.470588237047,0.192156866193,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.966,-20.702],[31.464,-9.7],[10.984,1.391]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-9.8,-9.62],[10.967,-20.702],[31.465,-9.7],[10.984,1.391]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.003921568859,0.784313738346,0.32549020648,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":2,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-9.8,-9.62],[10.967,-20.702],[31.465,-9.7],[10.984,1.391]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.623529434204,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":2,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-26.51,0],[0,-26.51],[26.51,0],[0,26.51]],"o":[[26.51,0],[0,26.51],[-26.51,0],[0,-26.51]],"v":[[11.321,-57.477],[59.321,-9.477],[11.321,38.523],[-36.679,-9.477]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019610882,0.949019610882,0.949019610882,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 12","np":2,"cix":2,"bm":0,"ix":12,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":11,"ty":3,"nm":"Null 25","parent":13,"sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[57.514]},{"t":150,"s":[110.514]}],"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":12,"ty":3,"nm":"Null 24","parent":13,"sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[112]},{"t":150,"s":[37]}],"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":13,"ty":3,"nm":"Null 22","sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[0]}],"ix":10},"p":{"a":0,"k":[985,985,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":14,"ty":3,"nm":"Null 23","parent":13,"sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[112]},{"t":150,"s":[143]}],"ix":10},"p":{"a":0,"k":[13.486,-33.379,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":16,"ty":4,"nm":"Uniswap","parent":14,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[-147]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-330.449,615.615,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-593.143,-664.185,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[61.068,61.068,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.423,1.482],[1.615,-0.027],[-0.464,-3.266],[-1.963,1.538]],"o":[[0.608,-2.159],[-3.017,0.063],[0.226,1.593],[1.394,-1.092]],"v":[[8.774,-3.915],[7.224,-7.392],[0.729,0.885],[5.32,1.005]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[1.429,-1.828],[0.222,-3.891],[-0.78,-0.539],[-2.786,2.184],[-0.049,4.111],[3.11,-0.402]],"o":[[-2.271,2.842],[-0.149,2.419],[1.326,0.909],[5.499,-4.397],[0.014,-3.374],[-1.656,0.235]],"v":[[1.495,-5.116],[-2.888,6.64],[-1.494,12.984],[3.699,11.393],[13.578,-3.785],[7.803,-9.262]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.685,3.104],[1.977,0.044],[-0.261,-1.832],[-0.626,0.048],[0.568,-1.95],[-1,-0.102]],"o":[[0.738,-3.233],[-1.914,-0.094],[0.079,0.558],[1.041,-0.107],[-0.556,2.03],[1.585,0.262]],"v":[[-29.845,92.834],[-32.084,86.976],[-36.232,91.466],[-35.217,92.175],[-34.59,94.605],[-33.913,97.882]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-2.394,-1.488],[-2.215,-1.717],[2.273,-3.817],[1.456,-1.142],[0,0],[6.479,6.963],[0.149,0.06],[-16.19,-17.855],[-0.113,-0.796],[1.33,-3.521],[-0.369,-9.537],[6.018,-18.083],[0.733,-3.761],[-0.507,-4.56],[-1.785,-3.647],[-3.47,-3.124],[-0.193,-1.354],[-3.462,3.865],[-3.179,8.334],[0.634,4.461],[0.871,1.176],[4.626,0.359],[1.369,4.682],[-1.919,10.268],[0.659,8.602],[-0.966,2.616],[-3.087,3.039],[-2.219,5.191],[0.428,4.003],[0,0],[0,0],[0.317,-0.248]],"o":[[28.478,17.165],[1.818,1.407],[-1.246,2.127],[-1.647,1.29],[-1.108,-0.371],[-8.643,-7.833],[-0.437,-0.101],[2.778,4.197],[0.238,1.673],[-2.18,5.958],[0.39,10.671],[-3.5,10.534],[-0.947,4.726],[0.489,4.929],[1.579,3.189],[2.988,2.704],[0.147,1.035],[8.326,-9.269],[2.006,-5.202],[-0.419,-2.947],[-1.398,-1.915],[-6.103,-0.352],[-1.107,-3.824],[1.949,-10.557],[-0.441,-5.585],[1.017,-2.745],[5.006,-4.896],[1.958,-4.545],[0,0],[0,0],[-5.66,-3.178],[0.086,0.11]],"v":[[-60.336,-36.6],[-11.475,-15.666],[-12.108,-7.734],[-17.588,-1.226],[-19.918,-0.286],[-27.989,-7.063],[-44.031,-21.403],[-28.278,-3.649],[-26.676,4.656],[-28.024,11.024],[-30.438,31.684],[-37.793,69.583],[-42.605,85.748],[-43.142,97.323],[-40.058,108.628],[-33.559,116.726],[-28.573,123.088],[-24.774,120.11],[-6.787,92.647],[-5.105,80.705],[-6.548,75.994],[-14.8,72.899],[-25.083,65.908],[-24.119,48.421],[-22.567,25.161],[-21.83,14.492],[-16.665,7.257],[-6.385,-7.084],[-4.267,-18.925],[-4.559,-21.972],[-6.16,-22.841],[-64.675,-39.397]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-8.185,8.274],[-3.515,1.515],[-3.115,-2.605],[-2.31,-7.839],[-0.24,-0.697],[-2.213,-0.214],[-4.958,6.718],[-0.011,-0.079],[1.73,-2.684],[2.66,-2.084],[4.25,3.663],[1.615,2.452],[4.603,0.199],[3.177,-4.881],[-3.887,-2.089],[-2.008,1.22],[0.667,4.7],[2.536,-0.482],[-0.595,-3.695],[-1.369,0.276],[0.656,-0.337],[-1.988,4.833],[-2.717,-3.271],[0.409,-3.065],[5.103,-2.228],[4.788,2.002],[10.352,-5.9],[0,0]],"o":[[6.3,-13.613],[3.508,-3.546],[5.632,-2.466],[3.103,2.525],[0.93,3.078],[1.457,3.816],[3.51,0.436],[0.818,-1.172],[0.224,0.09],[-2.307,3.578],[-4.876,3.822],[-0.814,-0.778],[-4.984,-7.338],[-4.029,-0.119],[-4.164,6.361],[1.59,0.79],[3.816,-2.37],[-0.43,-3.027],[-3.49,0.699],[0.226,1.593],[0.891,-0.167],[-3.09,1.536],[2.34,-5.818],[1.117,1.426],[-0.866,6.787],[-3.503,1.595],[-8.309,-3.493],[0,0],[0,0]],"v":[[-4.456,99.142],[18.42,64.483],[31.493,54.946],[45.596,55.137],[52.577,68.611],[54.677,75.464],[60.45,81.917],[74.387,71.526],[76.006,69.549],[72.157,76.638],[65.254,84.526],[51.633,84.754],[47.163,79.051],[35.362,69.797],[23.454,77.624],[22.951,94.396],[29.182,93.673],[34.999,80.616],[30.834,77.063],[24.762,86.337],[27.074,88.243],[27.309,88.413],[24.877,81.201],[36.05,75.631],[37.451,84.006],[27.013,99.71],[17.222,99.151],[-4.411,101.94],[-6.431,103.08]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.839,2.542],[-0.488,7.465],[-0.19,0.149],[-0.713,-0.062],[-7.145,0.73],[-3.856,-2.378],[-1.672,-5.33],[0.221,-3.892],[6.529,-10.517],[0.052,-0.129],[-0.418,2.01],[2.821,5.491],[5.92,5.011]],"o":[[-3.667,-5.006],[0.025,-0.816],[0.126,-0.1],[1.35,0.092],[8.962,-0.826],[3.398,2.118],[0.919,2.998],[-0.689,12.491],[-0.975,1.561],[-0.127,0.099],[1.565,-8.308],[-1.739,-3.329],[-6.935,-5.719]],"v":[[64.933,2.005],[60.2,-16.949],[60.589,-18.67],[62.118,-18.806],[73.332,-19.627],[91.384,-17.397],[98.854,-6.43],[100.464,8.863],[89.379,44.285],[87.481,47.277],[87.983,43.874],[86.097,23.663],[75.422,11.932]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[3.27,10.629],[0.401,0.837],[0,0],[0,0],[-1.327,-2.412],[-0.554,-3.903],[0.328,-2.647],[1.664,-4.137],[6.618,-6.426],[2.942,-2.571],[4.15,-5.465],[0.075,0.03],[-2.307,3.579],[-7.69,7.797],[-0.956,1.193]],"o":[[-0.513,-1.633],[0,0],[0,0],[1.59,0.79],[1.037,1.844],[0.543,3.824],[-0.463,4.17],[-3.017,7.499],[-1.18,1.102],[-7.532,6.434],[-0.588,0.815],[-0.224,-0.09],[3.241,-4.93],[3.814,-3.874],[9.008,-11.397]],"v":[[52.939,-11.083],[51.242,-15.596],[50.464,-17.11],[51.607,-16.501],[55.877,-11.703],[57.633,-5.289],[57.898,2.028],[54.907,13.668],[41.011,33.765],[33.514,40.437],[16.976,57.292],[15.766,58.683],[20.572,50.402],[34.879,33.701],[43.555,24.423]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[14.25,-3.73],[2.094,14.737],[-0.064,0.05],[-1.011,-0.181],[-12.856,7.596],[-4.078,1.514],[-3.754,-12.551],[0.246,-4.708],[0.473,-0.636],[0.147,1.035],[4.089,1.044]],"o":[[-21.374,5.597],[-0.305,-2.151],[0.063,-0.049],[4.63,0.887],[7.539,-4.403],[12.872,-4.51],[1.083,3.665],[-0.244,3.732],[-0.115,0.179],[-0.937,-5.109],[-4.59,-1.095]],"v":[[66.335,-26.273],[34.604,-38.587],[34.177,-42.59],[36.113,-42.337],[58.344,-50.818],[74.299,-58.895],[99.921,-46.484],[101.517,-30.295],[99.577,-18.683],[99.023,-20.107],[91.119,-29.671]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.108,3.155],[0.618,8.81],[0,0],[0,0],[-1.679,0.076],[-3.307,-8.916],[-0.487,-0.946],[-1.99,-1.627],[2.515,-1.617]],"o":[[-5.284,-4.003],[0,0],[0,0],[1.893,-1.041],[4.494,-0.069],[0.937,2.63],[0.778,1.515],[1.435,1.178],[-3.919,2.629]],"v":[[-7.036,-29.503],[-17.205,-51.544],[-17.389,-54.322],[-16.405,-54.828],[-9.515,-56.863],[0.562,-45.373],[3.169,-38.917],[8.448,-32.962],[6.743,-28.616]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.315,3.206],[-0.606,3.661],[-0.064,0.049],[0.106,-1.234],[-1.14,-4.064],[-5.684,-2.362],[-1.113,-0.898],[0,0],[0,0],[1.115,-0.077],[0.364,-0.905],[-0.446,-3.634],[0.947,-4.726],[-0.454,2.746],[0.77,5.417],[6.714,-0.304],[1.708,-0.365],[-0.052,0.129],[-2.576,0.691],[-0.421,0.507]],"o":[[-0.489,-4.928],[0.285,-1.463],[0.063,-0.05],[-0.364,3.384],[1.437,5.159],[2.624,1.131],[0,0],[0,0],[-2.44,-0.832],[-0.764,0.068],[-0.312,0.775],[0.729,5.626],[-0.552,2.557],[0.269,-2.07],[-1.55,-10.913],[-1.678,0.076],[-1.707,0.364],[0.156,-0.388],[3.784,-1.106],[0.156,-0.388]],"v":[[61.118,-103.629],[61.352,-115.852],[61.945,-118.618],[61.836,-116.409],[63.029,-105.038],[70.643,-97.018],[77.549,-93.489],[79.655,-92.041],[77.662,-92.692],[68.551,-94.405],[67.296,-93.332],[67.416,-88.027],[67.085,-73.514],[66.804,-74.002],[66.265,-82.256],[56.615,-94.7],[50.458,-93.947],[47.498,-93.486],[56.425,-97.03],[61.234,-98.851]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[7.867,-4.571],[-0.991,0.954],[-3.164,1.506],[-8.41,-4.209],[0,0],[0,0],[-10.28,1.948],[-0.62,-0.399],[-0.491,-1.474],[0.981,-4.487],[-0.733,-1.196],[-1.14,0.894],[-0.189,7.585],[0,0],[0,0],[-1.693,-6.464],[0,0],[0,0],[2.126,0.104],[9.653,-6.857],[5.16,-1.83],[12.102,8.398],[3.176,1.052]],"o":[[-2.146,1.24],[1.843,-1.887],[7.525,-3.507],[0,0],[0,0],[10.892,-11.015],[2.811,-0.521],[0.224,0.09],[1.534,5.349],[-0.5,2.428],[0.625,0.928],[2.343,-1.836],[0,0],[0,0],[6.096,3.279],[0,0],[0,0],[-1.864,-1.726],[-3.827,-0.188],[-8.755,6.242],[-8.708,3.106],[-5.388,-3.745],[-7.023,-2.375]],"v":[[-16.001,-60.899],[-17.294,-60.593],[-7.711,-66.952],[15.528,-65.865],[17.726,-64.755],[20.307,-67.397],[53.128,-87.541],[61.169,-87.911],[62.363,-84.952],[63.233,-70.407],[63.482,-66.176],[66.511,-66.159],[70.961,-82.394],[71.031,-85.37],[72.173,-84.761],[85.407,-68.396],[85.857,-66.713],[84.733,-67.691],[78.951,-70.242],[61.725,-61.7],[42.798,-50.763],[17.164,-57.32],[5.385,-63.936]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0.478431373835,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-7.259,5.688],[0,0],[-1.297,-9.13],[0,0],[7.259,-5.688],[0,0],[1.297,9.13],[0,0]],"o":[[0,0],[7.259,-5.688],[0,0],[1.297,9.13],[0,0],[-7.259,5.688],[0,0],[-1.297,-9.13]],"v":[[-114.963,-61.837],[104.181,-233.575],[119.673,-227.343],[158.83,48.311],[148.036,75.142],[-71.109,246.881],[-86.6,240.648],[-125.758,-35.005]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0,1,0.847,0.918,0.436,1,0.878,0.933,0.871,1,0.91,0.949],"ix":9}},"s":{"a":0,"k":[-162.135,-924.583],"ix":5},"e":{"a":0,"k":[-222.837,-1205.443],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":2,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-1.297,-9.13],[0,0],[-7.259,5.688],[0,0],[0,0],[0,0],[0,0],[1.297,9.13],[0,0],[0,0],[0,0],[0,0],[7.258,-5.688]],"o":[[-7.259,5.688],[0,0],[1.297,9.131],[0,0],[0,0],[0,0],[0,0],[7.259,-5.689],[0,0],[0,0],[0,0],[0,0],[-1.297,-9.13],[0,0]],"v":[[-148.035,-75.143],[-158.83,-48.311],[-119.673,227.342],[-104.181,233.575],[-75.332,210.966],[-67.918,213.949],[-62.751,201.107],[114.963,61.837],[125.757,35.005],[94.003,-188.535],[99.17,-201.378],[91.755,-204.361],[86.6,-240.648],[71.109,-246.881]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":5,"k":{"a":0,"k":[0,1,1,1,0.383,1,0.924,0.959,0.766,1,0.847,0.918,0.857,0.931,0.778,0.849,0.948,0.863,0.71,0.78],"ix":9}},"s":{"a":0,"k":[-353,-680.305],"ix":5},"e":{"a":0,"k":[-822.002,-806.499],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":2,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":17,"ty":4,"nm":"Opensea 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":150,"s":[18.699]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[553.246,-248.436,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[225.975,381.818,0]}],"ix":2},"a":{"a":0,"k":[439.975,103.818,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[57.648,57.648,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[1.25,9]],"o":[[0,0],[0,0],[0,0],[-1.25,-9]],"v":[[427,-81.25],[409.5,-47.75],[427,-53],[432.25,-68.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.125490196078,0.505882352941,0.886274509804,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 2","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[-0.514,-16.446],[0,0],[0,0],[0,0],[8.737,-2.056],[2.056,5.139],[0,0],[-24.669,5.139],[0,0],[-3.084,5.139],[0,0],[0,0],[0,0],[4.625,-2.57],[0,0],[0,0],[-8.737,16.446],[3.084,9.765],[3.598,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0.514,16.446],[0,0],[0,0],[0,0],[-4.904,1.154],[-8.223,2.57],[0,0],[24.669,-5.139],[0,0],[3.084,-5.139],[0,0],[0,0],[0,0],[-4.625,2.57],[0,0],[0,0],[8.737,-16.446],[-3.084,-9.765],[-3.598,0]],"v":[[-26.586,-186.994],[-42.004,-181.341],[-42.004,-168.493],[-61.02,-165.923],[-46.116,-124.294],[-61.02,-75.984],[-42.518,-82.151],[-42.518,-69.817],[-64.103,-61.08],[-72.326,-72.901],[-113.955,-57.996],[-81.577,-25.619],[11.959,-58.51],[29.433,-99.625],[46.393,-114.529],[45.879,-123.78],[3.736,-98.597],[-5.515,-85.235],[-25.044,-77.012],[-25.044,-89.347],[-2.431,-107.848],[5.792,-141.254],[-23.502,-168.493]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.125490196078,0.505882352941,0.886274509804,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":1,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[3.064,-65.944],[59.724,-23.705],[1.517,77.408],[-70.816,21.257]],"o":[[-3.358,72.268],[-66.147,26.254],[-1.665,-84.994],[68.176,-20.464]],"v":[[88.296,-156.476],[-26.179,16.588],[-167.379,-46.493],[-30.291,-237.031]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.1254902035,0.505882382393,0.886274516582,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[441.948,81.346],"ix":2},"a":{"a":0,"k":[-37.486,187.861],"ix":1},"s":{"a":0,"k":[48.644,48.644],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[35.092,-145.117],[34.592,-131.383],[-37.092,-108.883],[-35.592,-121.617]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.849065563725,0.849065563725,0.849065563725,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.414756954418,0.454261779785,0.52409620098,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[400.092,198.617],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 2","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[89.975,-290.818],[90.975,-57.182],[-92.475,9.318],[-90.975,-223.818]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":12,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"st","c":{"a":0,"k":[0.849065563725,0.849065563725,0.849065563725,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.307652801275,0.406062930822,0.504473030567,1],"ix":4},"o":{"a":0,"k":77,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[439.975,103.818],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":4,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":18,"ty":4,"nm":"Filecoin","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-602.61,-437.457,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-394.61,461.543,0]}],"ix":2},"a":{"a":0,"k":[297.39,-313.457,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[27.622,27.622,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[2.073,-4.974],[2.487,-5.388],[7.875,-1.244],[3.73,2.901],[0,1.244],[-1.243,0.829],[-1.243,-0.415],[-0.829,-1.658],[-3.316,2.487],[-1.243,4.559],[-2.073,9.947],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.829,2.073],[-4.974,6.632],[-8.704,-0.415],[-2.487,-2.901],[0,-0.829],[1.244,-1.243],[1.658,1.658],[1.243,1.243],[2.901,-2.901],[1.243,-2.901],[2.901,-9.119],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[-1.658,5.388],[-2.072,5.803],[-3.316,7.046],[-4.559,0.829],[-1.243,-0.829],[0,-1.658],[0.829,-0.414],[1.243,1.243],[2.487,3.316],[3.73,-3.316],[2.487,-9.948],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0.829,-2.487],[2.073,-7.461],[4.974,-6.632],[3.731,0],[0.415,0.414],[0,1.658],[-1.658,1.243],[-1.244,-1.243],[-2.487,-3.316],[-2.073,2.073],[-2.902,8.704],[0,0],[0,0],[0,0]],"v":[[305.265,-323.403],[302.778,-310.139],[326.404,-306.823],[324.746,-300.606],[301.535,-303.922],[296.976,-287.757],[290.344,-270.763],[273.35,-257.499],[260.086,-259.986],[257.599,-263.717],[259.671,-268.276],[263.816,-267.861],[267.132,-263.302],[276.251,-262.059],[283.297,-274.493],[290.344,-303.922],[290.344,-305.58],[268.376,-308.896],[269.205,-315.113],[292.002,-311.797],[294.903,-324.646],[271.277,-328.377],[272.106,-335.009],[296.561,-331.693],[298.634,-338.325],[307.752,-359.878],[327.233,-370.241],[337.181,-366.096],[338.425,-364.023],[337.181,-359.049],[331.793,-359.878],[328.477,-363.609],[319.358,-364.438],[313.97,-356.562],[306.094,-329.62],[328.891,-326.304],[327.233,-320.087]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[45.594,0],[0,46.009],[-46.009,-0.414],[0,-46.423]],"o":[[-45.594,0],[0.414,-45.594],[45.594,0.414],[-0.414,45.179]],"v":[[297.39,-230.557],[214.492,-313.869],[297.805,-396.353],[380.288,-312.626]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0.564705908298,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":19,"ty":4,"nm":"Arbitrum 2","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[-55.571]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-286.145,203.634,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[71.099,222.423,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[42.098,42.098,100]},{"t":150,"s":[104.712,104.712,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.78,1.747],[0,0],[2.755,-1.386],[0,0],[0.471,-0.337],[0.155,-3.037],[0,0],[0,0],[0,0],[-0.023,0.127],[-0.708,0.508],[-0.122,0.061],[-0.899,-0.442],[0,0],[-0.051,-1.074],[0,0],[0.732,-0.594],[0,0],[0,0],[0,0],[0,0],[0.745,0.303],[0,0],[0,0],[0,0],[-0.358,-0.202],[-0.134,-0.064],[-1.367,0],[-1.156,0.453],[0,0],[-0.123,2.943]],"o":[[-0.131,-3.278],[0,0],[-2.75,-1.385],[-0.326,0.164],[-0.52,0.249],[-2.482,1.779],[0,0],[0,0],[0,0],[0.008,-0.131],[0.151,-0.843],[0.177,-0.127],[0.898,-0.451],[0,0],[0.91,0.579],[0,0],[-0.047,0.941],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0],[0,0],[0.49,0.278],[0.555,0.312],[1.054,0.512],[1.253,0],[0,0],[2.325,-1.801],[0,0]],"v":[[48.35,-22.64],[43.664,-30.666],[4.696,-53.075],[-4.244,-53.076],[-42.139,-31.123],[-43.631,-30.24],[-47.781,-22.66],[-47.781,23.75],[-41.087,13.463],[-41.145,-22.346],[-41.098,-22.733],[-39.768,-24.835],[-1.258,-47.141],[1.68,-47.155],[40.144,-25.03],[41.675,-22.394],[41.675,21.965],[40.525,24.372],[33.068,28.693],[29.221,30.923],[15.468,38.893],[1.521,46.976],[-0.853,46.929],[-17.354,37.438],[-20.725,43.154],[-5.896,51.693],[-4.61,52.42],[-3.543,53.003],[0.394,53.814],[4.024,53.13],[44.534,29.671],[48.35,22.21]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.588235318661,0.745098054409,0.86274510622,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.017,-22.559],[2.343,-22.502],[-33.12,36.018],[-20.725,43.154],[-17.354,37.438]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[2.506,-4.09],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0]],"v":[[-47.781,27.572],[-37.251,33.639],[-2.208,-22.559],[-8.156,-22.717],[-21.187,-17.381],[-41.087,13.462],[-47.781,23.749],[-47.781,27.572]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.046,0.941]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.731,-0.594],[0,0]],"v":[[41.745,21.549],[41.735,15.163],[20.371,-18.112],[12.445,-4.663],[33.069,28.693],[40.526,24.372],[41.746,21.965]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.581,15.527],[15.469,38.893],[29.221,30.923],[9.669,0.105]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[15.469,38.893],[0.581,15.526],[9.669,0.105],[29.221,30.923]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.91,0.579],[0,0],[0.898,-0.451],[0.109,-0.072],[0,0],[0,0],[0,0],[0.177,-0.127],[0.152,-0.842],[0.008,-0.131],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[-0.05,-1.074],[0,0],[-0.9,-0.442],[-0.121,0.061],[0,0],[0,0],[0,0],[-0.186,0.086],[-0.708,0.508],[-0.023,0.128],[0,0],[0,0],[2.505,-4.09],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0.745,0.302],[0,0],[0,0],[0,0]],"v":[[12.444,-4.663],[20.371,-18.112],[41.735,15.163],[41.745,21.549],[41.675,-22.394],[40.144,-25.03],[1.681,-47.155],[-1.258,-47.141],[-1.602,-46.942],[-1.736,-46.858],[-39.071,-25.222],[-39.216,-25.157],[-39.768,-24.835],[-41.097,-22.735],[-41.145,-22.347],[-41.086,13.463],[-21.187,-17.381],[-8.155,-22.716],[-2.208,-22.559],[-37.25,33.639],[-33.12,36.018],[2.343,-22.502],[18.018,-22.559],[-17.354,37.438],[-2.614,45.915],[-0.853,46.929],[1.522,46.974],[40.526,24.372],[33.069,28.693]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-45.784,0],[0,-45.784],[45.784,0],[0,45.784]],"o":[[45.784,0],[0,45.784],[-45.784,0],[0,-45.784]],"v":[[0,-82.898],[82.898,0],[0,82.898],[-82.898,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":20,"ty":4,"nm":"Arbitrum","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[342.386,-629.592,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-310.614,45.408,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[43.304,43.304,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.78,1.747],[0,0],[2.755,-1.386],[0,0],[0.471,-0.337],[0.155,-3.037],[0,0],[0,0],[0,0],[-0.023,0.127],[-0.708,0.508],[-0.122,0.061],[-0.899,-0.442],[0,0],[-0.051,-1.074],[0,0],[0.732,-0.594],[0,0],[0,0],[0,0],[0,0],[0.745,0.303],[0,0],[0,0],[0,0],[-0.358,-0.202],[-0.134,-0.064],[-1.367,0],[-1.156,0.453],[0,0],[-0.123,2.943]],"o":[[-0.131,-3.278],[0,0],[-2.75,-1.385],[-0.326,0.164],[-0.52,0.249],[-2.482,1.779],[0,0],[0,0],[0,0],[0.008,-0.131],[0.151,-0.843],[0.177,-0.127],[0.898,-0.451],[0,0],[0.91,0.579],[0,0],[-0.047,0.941],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0],[0,0],[0.49,0.278],[0.555,0.312],[1.054,0.512],[1.253,0],[0,0],[2.325,-1.801],[0,0]],"v":[[48.35,-22.64],[43.664,-30.666],[4.696,-53.075],[-4.244,-53.076],[-42.139,-31.123],[-43.631,-30.24],[-47.781,-22.66],[-47.781,23.75],[-41.087,13.463],[-41.145,-22.346],[-41.098,-22.733],[-39.768,-24.835],[-1.258,-47.141],[1.68,-47.155],[40.144,-25.03],[41.675,-22.394],[41.675,21.965],[40.525,24.372],[33.068,28.693],[29.221,30.923],[15.468,38.893],[1.521,46.976],[-0.853,46.929],[-17.354,37.438],[-20.725,43.154],[-5.896,51.693],[-4.61,52.42],[-3.543,53.003],[0.394,53.814],[4.024,53.13],[44.534,29.671],[48.35,22.21]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.588235318661,0.745098054409,0.86274510622,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.017,-22.559],[2.343,-22.502],[-33.12,36.018],[-20.725,43.154],[-17.354,37.438]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[2.506,-4.09],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0]],"v":[[-47.781,27.572],[-37.251,33.639],[-2.208,-22.559],[-8.156,-22.717],[-21.187,-17.381],[-41.087,13.462],[-47.781,23.749],[-47.781,27.572]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.046,0.941]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.731,-0.594],[0,0]],"v":[[41.745,21.549],[41.735,15.163],[20.371,-18.112],[12.445,-4.663],[33.069,28.693],[40.526,24.372],[41.746,21.965]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.581,15.527],[15.469,38.893],[29.221,30.923],[9.669,0.105]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.156862750649,0.627451002598,0.941176474094,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[15.469,38.893],[0.581,15.526],[9.669,0.105],[29.221,30.923]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0.91,0.579],[0,0],[0.898,-0.451],[0.109,-0.072],[0,0],[0,0],[0,0],[0.177,-0.127],[0.152,-0.842],[0.008,-0.131],[0,0],[0,0],[-5.067,-0.072],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.751,0.271],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[-0.05,-1.074],[0,0],[-0.9,-0.442],[-0.121,0.061],[0,0],[0,0],[0,0],[-0.186,0.086],[-0.708,0.508],[-0.023,0.128],[0,0],[0,0],[2.505,-4.09],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0.745,0.302],[0,0],[0,0],[0,0]],"v":[[12.444,-4.663],[20.371,-18.112],[41.735,15.163],[41.745,21.549],[41.675,-22.394],[40.144,-25.03],[1.681,-47.155],[-1.258,-47.141],[-1.602,-46.942],[-1.736,-46.858],[-39.071,-25.222],[-39.216,-25.157],[-39.768,-24.835],[-41.097,-22.735],[-41.145,-22.347],[-41.086,13.463],[-21.187,-17.381],[-8.155,-22.716],[-2.208,-22.559],[-37.25,33.639],[-33.12,36.018],[2.343,-22.502],[18.018,-22.559],[-17.354,37.438],[-2.614,45.915],[-0.853,46.929],[1.522,46.974],[40.526,24.372],[33.069,28.693]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-45.784,0],[0,-45.784],[45.784,0],[0,45.784]],"o":[[45.784,0],[0,45.784],[-45.784,0],[0,-45.784]],"v":[[0,-82.898],[82.898,0],[0,82.898],[-82.898,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.176470592618,0.215686276555,0.29411765933,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":21,"ty":4,"nm":"BTC","parent":11,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-57.514]},{"t":150,"s":[92.486]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[237.862,-166.472,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[141.462,-538.267,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[48.49,48.49,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.584,16.027],[-7.604,2.267],[0,0]],"o":[[-4.376,-15.298],[0,0],[-7.603,2.268]],"v":[[-13.934,29.635],[13.776,7.059],[21.486,34.013]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[5.001,17.484],[-9.219,2.777],[0,0]],"o":[[-4.793,-16.755],[0,0],[-9.219,2.777]],"v":[[-32.234,-10.516],[1.456,-36.333],[9.908,-6.624]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[-4.473,-11.423],[-17.993,3.386],[0,0],[0,0],[0,0],[-3.484,0.95],[0,0],[0,0],[0,0],[-2.755,0.741],[0,0],[0,0],[-0.159,0.092],[1.311,2.638],[0,0],[0.569,-0.116],[-0.57,0.116],[0,0],[-3.802,1.134],[0,0],[0,0],[0,0],[3.166,-0.766],[0,0],[0,0],[0,0],[3.392,-1.109],[0,0],[0,0],[0,0],[-4.109,-21.819],[-13.721,0.494]],"o":[[6.201,15.518],[0,0],[0,0],[0,0],[3.643,-1.042],[0,0],[0,0],[0,0],[2.914,-0.834],[0,0],[0,0],[0,0],[-5.51,1.484],[0,0],[-0.41,0.024],[0.41,-0.024],[0,0],[-0.19,-1.8],[-0.251,-0.067],[0,0],[0,0],[-3.324,0.859],[0,0],[0,0],[0,0],[-3.734,0.883],[0,0],[0,0],[0,0],[-22.419,7.85],[3.36,17.582],[-6.721,6.002]],"v":[[-37.422,42.984],[2.005,56.507],[8.44,78.68],[21.964,74.904],[15.804,53.208],[26.481,50.015],[32.732,71.87],[46.256,68.094],[39.821,45.921],[48.312,43.353],[66.935,38.118],[62.859,23.707],[53.07,26.6],[43.548,22.973],[36.347,-2.365],[34.89,-1.949],[36.347,-2.365],[26.228,-37.903],[29.985,-43.892],[39.774,-46.785],[37.853,-63.712],[20.209,-58.619],[10.487,-55.977],[4.119,-78.401],[-9.404,-74.625],[-2.969,-52.452],[-13.738,-49.418],[-20.081,-71.432],[-33.605,-67.656],[-27.236,-45.231],[-59.747,-5.241],[-32.385,17.158]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[18.939,65.883],[-65.885,18.941],[-18.938,-65.883],[66.044,-19.032]],"o":[[-19.03,-66.042],[65.885,-18.941],[19.031,66.042],[-66.136,18.873]],"v":[[-119.511,34.339],[-34.301,-119.473],[119.51,-34.27],[34.301,119.541]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.964705884457,0.572549045086,0.101960785687,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":22,"ty":4,"nm":"Beefy","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-701,466,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-171,450,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[47.222,47.222,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.256,1.446],[-2.701,0.676],[-1.958,-1.31],[0.748,-1.411],[2.196,0.139]],"o":[[-1.732,-1.955],[2.102,-0.516],[2.031,1.342],[-0.651,1.216],[-2.406,-0.157]],"v":[[-21.958,2.476],[-19.963,-2.201],[-12.72,-0.89],[-10.75,3.458],[-15.754,5.179]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.090196080506,0.082352943718,0.070588238537,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.513,-0.937],[-2.573,-0.488],[-1.057,1.233],[1.785,1.363],[1.551,0.257],[1.128,-1.31]],"o":[[0.837,1.521],[2.499,0.456],[1.05,-1.204],[-1.055,-0.796],[-2.593,-0.4],[-0.668,0.701]],"v":[[0.723,23.104],[6.129,26.493],[12.24,25.333],[11.223,21.045],[7.092,19.26],[1.047,20.482]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[-1.765,-1.809],[-2.515,-2.288],[-1.907,-1.654],[-1.228,-0.742],[-1.5,-0.602],[-4.451,0.342],[-0.997,0.255],[-2.228,0.72],[0.091,0.191],[0.586,2.038],[-2.627,4.983],[-1.487,1.476],[-1.826,1.199],[-1.807,0.754],[-3.041,1.11],[5.061,4.675],[0.338,0.169],[0.904,-0.199],[0.61,-0.327],[0.441,-1.48],[0.761,-1.826],[1.385,-0.431],[10.892,-3.442],[0.817,-0.528],[0.561,-0.586],[-0.501,-2.173]],"o":[[2.364,2.361],[1.849,1.672],[0.968,0.823],[1.272,0.783],[4.429,1.775],[1.145,-0.082],[2.34,-0.618],[0.091,-0.166],[-1.073,-2.023],[-1.657,-5.734],[0.895,-1.703],[1.417,-1.4],[1.476,-0.952],[2.907,-1.233],[-5.062,-4.675],[-0.245,-0.225],[-0.85,-0.393],[-0.766,0.183],[-1.68,0.906],[-0.593,1.911],[-0.402,0.947],[-10.959,3.381],[-1.067,0.332],[-0.759,0.51],[-1.607,1.65],[0.447,1.944]],"v":[[-50.852,16.368],[-43.377,23.307],[-37.887,28.341],[-34.828,30.597],[-30.655,32.67],[-16.612,34.881],[-12.965,34.295],[-6.213,32.195],[-6.148,31.791],[-8.828,25.718],[-7.587,9.408],[-4.027,4.574],[0.683,0.587],[5.587,-2.116],[14.608,-5.469],[-0.599,-19.514],[-1.623,-20.21],[-4.573,-20.69],[-6.859,-19.951],[-10.328,-16.351],[-11.724,-10.408],[-14.514,-8.39],[-47.353,1.822],[-50.223,3.126],[-52.251,4.744],[-54.096,10.771]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[2.511,-0.78],[0,0],[-2.329,0.807],[-0.196,0.389],[0.618,0.712],[2.168,0.257],[0.347,-0.108]],"o":[[0,0],[2.44,-0.704],[0.555,-0.2],[0.357,-0.632],[-1.025,-1.161],[-0.444,-0.054],[-2.592,0.669]],"v":[[44.771,8.994],[50.654,14.428],[57.84,12.193],[59.072,11.372],[58.738,9.283],[54.097,6.67],[52.318,6.702]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0.202,-0.063],[0,0],[-2.295,0.659],[0.025,0.842],[0.297,0.346],[2.175,0.228],[0.259,-0.081],[2.33,-0.697]],"o":[[0,0],[2.206,-0.741],[1.09,-0.312],[0,-0.356],[-1.019,-1.191],[-0.342,-0.031],[-2.42,0.615],[-0.173,0.054]],"v":[[17.599,-16.101],[23.482,-10.668],[30.163,-12.691],[32.043,-14.482],[31.544,-15.834],[26.742,-18.451],[25.124,-18.414],[18.154,-16.301]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[4.347,4.157],[-0.85,4.595],[-3.917,2.26],[-2.258,0.73],[-9.407,2.925],[-0.149,0.896],[-1.735,3.527],[-2.313,1.569],[-3.713,-0.544],[-1.095,-0.975],[-4.818,-4.449],[-2.737,0.714],[-3.534,-0.984],[-2.1,-1.868],[2.288,-2.767],[1.427,-0.499],[2.54,-0.79],[-0.045,-0.041],[-3.13,-2.891],[-2.857,0.532],[-4.096,-1.823],[-1.37,-2.37],[0.193,-1.211],[2.16,-0.891],[2.799,-0.87],[-4.151,-3.834],[0.963,-1.176],[4.981,0.396],[7.042,1.729],[1.206,-0.348],[10.568,-2.601],[5.472,0.601],[5.184,2.471],[2.646,2.301]],"o":[[-4.717,-4.535],[0.668,-3.551],[1.823,-1.06],[9.385,-2.946],[1.241,-0.386],[0.794,-3.755],[1.046,-2.134],[2.091,-1.418],[1.821,0.256],[4.846,4.44],[2.626,-0.817],[3.025,-0.804],[3.329,0.938],[3.578,3.163],[-0.766,0.896],[-2.473,0.851],[0.045,0.041],[3.101,2.9],[2.677,-0.805],[4.035,-0.762],[3.532,1.588],[0.73,1.28],[-0.306,1.712],[-2.571,1.046],[4.152,3.834],[1.443,1.333],[-2.24,2.67],[-7.09,-0.564],[-1.423,-0.352],[-10.186,3.167],[-4.646,1.088],[-5.916,-0.654],[-3.658,-1.74],[-4.527,-4.074]],"v":[[-61.893,19.637],[-67.806,5.305],[-60.73,-3.692],[-54.532,-6.305],[-26.333,-15.101],[-24.169,-17.912],[-21.722,-29.225],[-16.472,-34.886],[-7.405,-37.021],[-2.765,-34.873],[11.665,-21.546],[19.587,-23.955],[30.167,-23.518],[38.405,-19.009],[40.379,-9.811],[36.996,-7.663],[29.4,-5.273],[29.527,-5.121],[38.895,3.531],[47.548,0.978],[60.558,2.769],[68.124,9.187],[68.754,13.047],[64.846,17.168],[56.537,19.861],[68.991,31.363],[69.851,35.399],[53.762,37.854],[30.356,32.909],[25.43,32.742],[-6.256,42.486],[-21.759,43.059],[-39.052,38.132],[-48.528,31.98]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.090196080506,0.082352943718,0.070588238537,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":6,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-5.457,-5.04],[0,0],[7.093,-2.206],[0,0],[5.456,5.04],[0,0],[-7.093,2.206],[0,0]],"o":[[0,0],[5.457,5.04],[0,0],[-7.093,2.206],[0,0],[-5.457,-5.04],[0,0],[7.093,-2.206]],"v":[[26.09,-62.656],[128.405,31.841],[125.443,44.96],[-7.552,86.319],[-30.274,81.188],[-132.589,-13.309],[-129.627,-26.427],[3.367,-67.787]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.937254901961,0.917647058824,0.894117647059,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[7.092,-2.206],[0,0],[-5.456,-5.04],[0,0],[0,0],[0,0],[0,0],[-7.093,2.206],[0,0],[0,0],[0,0],[0,0],[5.457,5.04]],"o":[[-5.457,-5.04],[0,0],[-7.093,2.206],[0,0],[0,0],[0,0],[0,0],[5.457,5.04],[0,0],[0,0],[0,0],[0,0],[7.093,-2.206],[0,0]],"v":[[30.274,-81.188],[7.552,-86.319],[-125.443,-44.96],[-128.405,-31.841],[-117.399,-21.675],[-118.295,-17.705],[-111.418,-16.152],[-26.09,62.655],[-3.367,67.786],[107.546,33.294],[114.424,34.847],[115.32,30.876],[129.627,26.427],[132.589,13.308]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.670588235294,0.658823529412,0.643137254902,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":23,"ty":4,"nm":"Op","parent":11,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-42.432]},{"t":150,"s":[61.122]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[289.345,754.715,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[230.901,-925.338,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[42.165,42.165,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.401,-0.949],[1.387,-2.599],[0.225,-0.841],[-0.839,-1.265],[-2.647,-0.71],[0,0],[0,0]],"o":[[-2.709,-0.726],[-2.462,0.934],[-0.491,1.047],[-0.502,1.873],[0.823,1.327],[0,0],[0,0],[0,0]],"v":[[-40.453,-6.992],[-48.121,-6.657],[-53.899,-1.357],[-54.967,1.471],[-54.463,6.175],[-49.263,9.228],[-37.64,12.342],[-29.316,-4.007]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-0.267,-0.553],[0.302,-0.61],[0,0],[0.7,-0.299],[0.65,0.174],[0,0],[3.53,4.127],[-1.506,5.621],[-0.854,1.64],[-5.859,2.236],[-8.453,-2.265],[0,0],[0,0],[-0.7,0.299],[-0.646,-0.173],[0,0]],"o":[[0.712,0.191],[0.187,0.603],[0,0],[-0.32,0.677],[-0.705,0.298],[0,0],[-7.169,-1.921],[-3.597,-4.144],[0.433,-1.615],[3.605,-6.994],[5.793,-2.253],[0,0],[0,0],[0.32,-0.678],[0.705,-0.298],[0,0],[0,0]],"v":[[3.738,-34.8],[5.203,-33.682],[5.024,-31.861],[-25.202,27.501],[-26.733,28.96],[-28.756,29.143],[-54.514,22.241],[-70.558,13.168],[-73.692,-1.478],[-71.759,-6.358],[-57.568,-20.201],[-36.194,-20.182],[-23.121,-16.679],[-12.986,-36.692],[-11.455,-38.151],[-9.431,-38.334],[3.739,-34.805]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[3.089,-1.456],[2.275,-4.092],[1.984,-4.309],[0.381,-1.419],[-6.131,-1.643],[-3.151,1.44],[-2.275,4.092],[-2.843,5.948],[-0.38,1.419],[6.193,1.659]],"o":[[-3.617,-0.969],[-3.152,1.44],[-3.113,5.671],[-0.621,1.288],[-1.573,5.873],[3.618,0.969],[3.09,-1.457],[2.32,-4.013],[0.604,-1.221],[1.592,-5.94],[0,0]],"v":[[41.31,-10.826],[31.253,-10.097],[23.11,-1.797],[15.464,13.175],[13.961,17.236],[20.797,28.51],[30.948,27.806],[38.993,19.479],[46.736,4.534],[48.213,0.571],[41.305,-10.827]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-3.938,-4.933],[1.817,-6.781],[0.878,-1.977],[3.295,-6.103],[18.269,4.895],[3.488,2.733],[1.373,3.897],[-1.212,4.52],[-0.88,1.983],[-2.805,5.061],[-6.725,2.905],[-9.299,-2.492]],"o":[[7.685,2.059],[3.855,4.977],[-0.381,1.419],[-2.087,4.424],[-9.148,16.577],[-4.97,-1.332],[-3.505,-2.67],[-1.396,-3.831],[0.363,-1.358],[2.509,-5.484],[4.631,-8.24],[6.712,-2.837],[0,0]],"v":[[46.404,-24.407],[63.834,-13.923],[66.892,3.712],[65.006,8.81],[56.935,24.602],[15.811,42.125],[3.124,36.026],[-4.199,26.176],[-4.475,13.646],[-2.614,8.64],[5.358,-7.178],[22.393,-23.893],[46.405,-24.412]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[71.279,19.099],[19.099,-71.279],[-71.279,-19.099],[-19.099,71.278]],"o":[[-71.279,-19.099],[-19.099,71.279],[71.279,19.099],[19.099,-71.279]],"v":[[34.553,-129.113],[-129.091,-34.633],[-34.611,129.01],[129.032,34.531]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.015686275437,0.1254902035,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":24,"ty":4,"nm":"BTC 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-115]},{"t":150,"s":[-175]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-815.822,471.229,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-488.822,535.729,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[41.711,41.711,100]},{"t":150,"s":[14.276,14.276,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.584,16.027],[-7.604,2.267],[0,0]],"o":[[-4.376,-15.298],[0,0],[-7.603,2.268]],"v":[[-13.934,29.635],[13.776,7.059],[21.486,34.013]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[5.001,17.484],[-9.219,2.777],[0,0]],"o":[[-4.793,-16.755],[0,0],[-9.219,2.777]],"v":[[-32.234,-10.516],[1.456,-36.333],[9.908,-6.624]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[-4.473,-11.423],[-17.993,3.386],[0,0],[0,0],[0,0],[-3.484,0.95],[0,0],[0,0],[0,0],[-2.755,0.741],[0,0],[0,0],[-0.159,0.092],[1.311,2.638],[0,0],[0.569,-0.116],[-0.57,0.116],[0,0],[-3.802,1.134],[0,0],[0,0],[0,0],[3.166,-0.766],[0,0],[0,0],[0,0],[3.392,-1.109],[0,0],[0,0],[0,0],[-4.109,-21.819],[-13.721,0.494]],"o":[[6.201,15.518],[0,0],[0,0],[0,0],[3.643,-1.042],[0,0],[0,0],[0,0],[2.914,-0.834],[0,0],[0,0],[0,0],[-5.51,1.484],[0,0],[-0.41,0.024],[0.41,-0.024],[0,0],[-0.19,-1.8],[-0.251,-0.067],[0,0],[0,0],[-3.324,0.859],[0,0],[0,0],[0,0],[-3.734,0.883],[0,0],[0,0],[0,0],[-22.419,7.85],[3.36,17.582],[-6.721,6.002]],"v":[[-37.422,42.984],[2.005,56.507],[8.44,78.68],[21.964,74.904],[15.804,53.208],[26.481,50.015],[32.732,71.87],[46.256,68.094],[39.821,45.921],[48.312,43.353],[66.935,38.118],[62.859,23.707],[53.07,26.6],[43.548,22.973],[36.347,-2.365],[34.89,-1.949],[36.347,-2.365],[26.228,-37.903],[29.985,-43.892],[39.774,-46.785],[37.853,-63.712],[20.209,-58.619],[10.487,-55.977],[4.119,-78.401],[-9.404,-74.625],[-2.969,-52.452],[-13.738,-49.418],[-20.081,-71.432],[-33.605,-67.656],[-27.236,-45.231],[-59.747,-5.241],[-32.385,17.158]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[18.939,65.883],[-65.885,18.941],[-18.938,-65.883],[66.044,-19.032]],"o":[[-19.03,-66.042],[65.885,-18.941],[19.031,66.042],[-66.136,18.873]],"v":[[-119.511,34.339],[-34.301,-119.473],[119.51,-34.27],[34.301,119.541]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.964705884457,0.572549045086,0.101960785687,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":25,"ty":4,"nm":"BNB 2","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[82.513]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[188.647,851.321,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[352.381,293.448,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[42.181,42.181,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,0.138],[-23.945,-3.002],[-23.945,13.996],[-9.344,22.495],[-9.344,16.215],[-18.577,10.856]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,-10.58],[-13.209,-13.72],[-18.577,-16.86],[-23.945,-13.72],[-23.945,-7.441],[-18.577,-4.301]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,-13.72],[-0.165,-10.58],[5.203,-13.72],[-0.165,-16.86]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,8.637],[-9.398,11.776],[-9.398,5.497],[-14.766,2.357]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,18.489],[-5.533,24.768],[-0.165,27.908],[5.203,24.768],[5.203,18.489],[-0.165,21.628]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[12.879,-13.72],[18.247,-10.58],[18.247,-4.301],[23.615,-7.441],[23.615,-13.72],[18.247,-16.86]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.247,10.856],[9.014,16.215],[9.014,22.495],[23.615,13.996],[23.615,-3.002],[18.247,0.138]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,8.637],[14.435,2.357],[9.068,5.497],[9.068,11.776]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,-8.361],[9.068,-11.501],[-0.165,-6.141],[-9.398,-11.501],[-14.766,-8.361],[-14.766,-2.081],[-5.533,3.278],[-5.533,13.996],[-0.165,17.135],[5.203,13.996],[5.203,3.278],[14.435,-2.081]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ind":9,"ty":"sh","ix":10,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,-19.079],[-0.165,-27.578],[14.435,-19.079],[9.068,-15.939],[-0.165,-21.298],[-9.398,-15.939]],"c":true},"ix":2},"nm":"Path 10","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":11,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-22.892,0],[0,-22.892],[22.892,0],[0,22.892]],"o":[[22.892,0],[0,22.892],[-22.892,0],[0,-22.892]],"v":[[0,-41.449],[41.449,0],[0,41.449],[-41.449,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176474094,0.72549021244,0.043137256056,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":26,"ty":4,"nm":"BNB","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[228,672,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-362,266,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[51.748,51.748,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,0.138],[-23.945,-3.002],[-23.945,13.996],[-9.344,22.495],[-9.344,16.215],[-18.577,10.856]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-18.577,-10.58],[-13.209,-13.72],[-18.577,-16.86],[-23.945,-13.72],[-23.945,-7.441],[-18.577,-4.301]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,-13.72],[-0.165,-10.58],[5.203,-13.72],[-0.165,-16.86]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,8.637],[-9.398,11.776],[-9.398,5.497],[-14.766,2.357]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-5.533,18.489],[-5.533,24.768],[-0.165,27.908],[5.203,24.768],[5.203,18.489],[-0.165,21.628]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[12.879,-13.72],[18.247,-10.58],[18.247,-4.301],[23.615,-7.441],[23.615,-13.72],[18.247,-16.86]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[18.247,10.856],[9.014,16.215],[9.014,22.495],[23.615,13.996],[23.615,-3.002],[18.247,0.138]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,8.637],[14.435,2.357],[9.068,5.497],[9.068,11.776]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[14.435,-8.361],[9.068,-11.501],[-0.165,-6.141],[-9.398,-11.501],[-14.766,-8.361],[-14.766,-2.081],[-5.533,3.278],[-5.533,13.996],[-0.165,17.135],[5.203,13.996],[5.203,3.278],[14.435,-2.081]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ind":9,"ty":"sh","ix":10,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-14.766,-19.079],[-0.165,-27.578],[14.435,-19.079],[9.068,-15.939],[-0.165,-21.298],[-9.398,-15.939]],"c":true},"ix":2},"nm":"Path 10","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":11,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-22.892,0],[0,-22.892],[22.892,0],[0,22.892]],"o":[[22.892,0],[0,22.892],[-22.892,0],[0,-22.892]],"v":[[0,-41.449],[41.449,0],[0,41.449],[-41.449,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176474094,0.72549021244,0.043137256056,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":28,"ty":4,"nm":"Fantom","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":150,"s":[-20]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[728,12,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[994,622,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[54.324,54.324,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-0.054,0.968],[-11.295,6.875],[0,0],[0,0],[1.614,-2.517],[0.219,-3.642],[0,0],[0.017,-1.043],[0,0],[0,0]],"o":[[0,0],[0,0],[0.018,-1.221],[0.573,-10.35],[0,0],[0,0],[-4.961,2.987],[-1.338,2.087],[0,0],[-0.044,0.797],[0,0],[0,0],[0,0]],"v":[[-124.334,-8.745],[-124.312,-12.946],[-124.303,-13.655],[-124.199,-16.867],[-108.535,-40.108],[-108.191,-40.316],[-103.61,-32.709],[-113.1,-24.67],[-115.262,-16.654],[-115.274,-16.447],[-115.363,-13.741],[-115.377,-12.514],[-115.396,-8.762]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-2.869,-1.73],[0,0],[-0.055,-0.03],[0,0],[0,0],[0,0],[0,0],[2.87,1.73],[0,0],[0.054,0.031],[0,0],[0,0],[0,0]],"o":[[0.186,3.346],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.186,-3.345],[0,0],[-0.058,-0.035],[0,0],[0,0],[0,0],[0,0]],"v":[[-92.897,49.349],[-87.077,59.016],[-31.896,92.279],[-31.727,92.377],[-31.678,92.404],[-31.681,92.301],[-31.687,92.154],[-35.271,27.822],[-41.091,18.156],[-96.272,-15.107],[-96.44,-15.206],[-96.489,-15.233],[-96.487,-15.13],[-96.48,-14.982]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-23.022,87.948],[23.029,60.22],[-26.388,30.252]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-88.334,-20.521],[-38.916,9.446],[-42.283,-48.25]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[-0.091,-0.429],[0,0],[0.344,0.207],[0,0],[0.054,0.03],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[-0.336,-0.282],[0,0],[-0.057,-0.035],[0,0],[0,0],[0,0],[0,0],[0.022,0.401]],"v":[[-29.804,12.653],[22.905,-19.084],[21.883,-19.821],[-33.299,-53.025],[-33.467,-53.123],[-33.516,-53.15],[-33.514,-53.047],[-33.507,-52.9],[-29.976,11.405]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[-0.343,-0.207],[0,0],[-0.055,-0.031],[0,0],[0,0],[0,0],[0,0],[0.092,0.429]],"o":[[0.337,0.281],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.022,-0.4],[0,0]],"v":[[-25.127,20.421],[-24.105,21.157],[31.077,54.362],[31.246,54.46],[31.295,54.487],[31.293,54.384],[31.286,54.236],[27.755,-10.069],[27.582,-11.317]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[-1.614,2.517],[-0.219,3.642],[0,0],[-0.017,1.043],[0,0],[0,0],[0,0],[0,0],[0,0],[0.054,-0.968],[11.295,-6.875],[0,0]],"o":[[4.96,-2.987],[1.338,-2.087],[0,0],[0.044,-0.797],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.018,1.222],[-0.573,10.35],[0,0],[0,0]],"v":[[103.608,32.709],[113.098,24.67],[115.26,16.654],[115.272,16.447],[115.361,13.741],[115.375,12.514],[115.394,8.763],[124.332,8.746],[124.31,12.946],[124.301,13.655],[124.197,16.867],[108.533,40.108],[108.189,40.316]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-0.349,-6.3],[0,0],[0,0],[0,0],[1.588,2.775],[0,0],[2.936,1.899],[0,0]],"o":[[0,0],[5.405,3.257],[0,0],[0,0],[0,0],[-0.182,-3.576],[0,0],[-1.636,-2.738],[0,0],[0,0]],"v":[[-25.638,-58.272],[26.245,-27.009],[36.377,-10.182],[39.728,50.165],[96.73,15.843],[93.251,-44.426],[91.198,-54.439],[91.105,-54.599],[83.545,-61.053],[31.21,-92.501]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0.358,6.305],[0,0],[-2.166,1.691],[0,0],[0,0],[-3.539,-2.139],[0,0],[-0.359,-6.304],[0,0],[2.494,-1.603],[0.182,-0.099],[0,0],[0.182,-0.1],[0,0],[0,0],[3.323,2.008]],"o":[[-5.404,-3.266],[0,0],[-0.216,-3.797],[0,0],[0,0],[2.588,-1.471],[0,0],[5.404,3.266],[0,0],[0.234,4.111],[-0.256,0.164],[0,0],[-0.176,0.116],[0,0],[0,0],[-2.493,1.206],[0,0]],"v":[[-91.683,66.939],[-101.829,50.087],[-105.488,-14.242],[-102.227,-22.676],[-102.255,-22.723],[27.14,-100.635],[36.762,-99.894],[91.906,-66.565],[102.053,-49.713],[105.711,14.617],[101.803,23.364],[101.151,23.757],[-26.721,100.751],[-27.258,101.075],[-27.592,101.276],[-27.606,101.254],[-36.538,100.269]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":10,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[47.233,78.444],[78.444,-47.233],[-47.233,-78.444],[-78.445,47.234]],"o":[[-47.234,-78.445],[-78.445,47.233],[47.233,78.445],[78.444,-47.233]],"v":[[142.036,-85.523],[-85.524,-142.036],[-142.037,85.523],[85.523,142.036]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.098039217293,0.411764711142,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":29,"ty":4,"nm":"Pancake","parent":14,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[-142]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[508.206,40.577,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[975.192,-40.763,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[41.934,41.934,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.34,-6.068],[6.631,2.557],[-2.341,6.068],[-6.632,-2.558]],"o":[[-2.34,6.068],[-6.632,-2.558],[2.34,-6.068],[6.631,2.558]],"v":[[59.789,-2.786],[44.223,1.811],[35.775,-12.048],[51.341,-16.645]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.341,-6.068],[6.632,2.557],[-2.34,6.068],[-6.631,-2.558]],"o":[[-2.34,6.068],[-6.631,-2.558],[2.34,-6.068],[6.632,2.558]],"v":[[-18.249,-32.884],[-33.815,-28.287],[-42.263,-42.146],[-26.697,-46.743]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[48.622,18.753],[-6.848,18.004],[0.011,-0.028],[-66.277,-25.562],[-8.581,22.248],[-0.01,0.028]],"o":[[-48.623,-18.753],[-0.011,0.028],[-8.581,22.248],[66.277,25.562],[0.011,-0.028],[-7.015,17.939]],"v":[[-5.643,14.909],[-95.576,-56.371],[-95.609,-56.287],[-8.438,22.156],[108.83,22.562],[108.862,22.478]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.996078431606,0.86274510622,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[21.491,8.289],[3.169,-8.216],[-1.312,-6.355],[2.283,0.37],[8.139,-21.103],[-66.165,-25.55],[-0.027,-0.01],[-0.026,-0.01],[-8.574,22.23],[10.996,7.131],[-1.178,0.861],[-2.519,6.531],[14.93,5.758],[7.104,-17.281],[2.18,0.841],[0,0],[-0.423,1.174]],"o":[[-14.93,-5.758],[-2.519,6.531],[0.295,1.43],[-12.936,-2.099],[-8.574,22.23],[0.027,0.01],[0.026,0.01],[66.186,25.496],[8.14,-21.104],[-1.94,-1.259],[5.241,-3.828],[3.169,-8.217],[-21.491,-8.289],[-0.473,1.153],[0,0],[-2.181,-0.841],[6.339,-17.575]],"v":[[-6.459,-107.676],[-33.722,-101.927],[-31.988,-72.881],[-35.618,-71.013],[-95.56,-56.413],[-8.548,21.969],[-8.468,21.999],[-8.39,22.03],[108.72,22.375],[74.106,-28.694],[72.67,-32.515],[93.46,-52.874],[77.118,-75.441],[36.902,-52.277],[32.12,-51.701],[10.944,-59.868],[7.787,-63.507]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.819607853889,0.533333361149,0.309803932905,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.34,-6.068],[6.631,2.557],[-2.341,6.068],[-6.632,-2.558]],"o":[[-2.34,6.068],[-6.632,-2.558],[2.34,-6.068],[6.631,2.558]],"v":[[59.789,-2.786],[44.223,1.811],[35.775,-12.048],[51.341,-16.645]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.341,-6.068],[6.632,2.557],[-2.34,6.068],[-6.631,-2.558]],"o":[[-2.34,6.068],[-6.631,-2.558],[2.34,-6.068],[6.632,2.558]],"v":[[-18.249,-32.884],[-33.815,-28.287],[-42.263,-42.146],[-26.697,-46.743]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[48.622,18.753],[-6.848,18.004],[0.011,-0.028],[-66.277,-25.562],[-8.581,22.248],[-0.01,0.028]],"o":[[-48.623,-18.753],[-0.011,0.028],[-8.581,22.248],[66.277,25.562],[0.011,-0.028],[-7.015,17.939]],"v":[[-5.643,14.909],[-95.576,-56.371],[-95.609,-56.287],[-8.438,22.156],[108.83,22.562],[108.862,22.478]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.996078431606,0.86274510622,0.564705908298,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[21.491,8.289],[3.169,-8.216],[-1.312,-6.355],[2.283,0.37],[8.139,-21.103],[-66.165,-25.55],[-0.027,-0.01],[-0.026,-0.01],[-8.574,22.23],[10.996,7.131],[-1.178,0.861],[-2.519,6.531],[14.93,5.758],[7.104,-17.281],[2.18,0.841],[0,0],[-0.423,1.174]],"o":[[-14.93,-5.758],[-2.519,6.531],[0.295,1.43],[-12.936,-2.099],[-8.574,22.23],[0.027,0.01],[0.026,0.01],[66.186,25.496],[8.14,-21.104],[-1.94,-1.259],[5.241,-3.828],[3.169,-8.217],[-21.491,-8.289],[-0.473,1.153],[0,0],[-2.181,-0.841],[6.339,-17.575]],"v":[[-6.459,-107.676],[-33.722,-101.927],[-31.988,-72.881],[-35.618,-71.013],[-95.56,-56.413],[-8.548,21.969],[-8.468,21.999],[-8.39,22.03],[108.72,22.375],[74.106,-28.694],[72.67,-32.515],[93.46,-52.874],[77.118,-75.441],[36.902,-52.277],[32.12,-51.701],[10.944,-59.868],[7.787,-63.507]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.819607853889,0.533333361149,0.309803932905,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 8","np":2,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[16.399,15.349],[-4.924,12.767],[-14.089,1.454],[-7.759,-1.004],[0.435,4.204],[-1.559,4.043],[-6.768,1.679],[-10.193,-3.932],[-4.257,-4.734],[-0.952,-4.46],[2.58,-8.02],[0,0],[-6.502,4.682],[-6.055,0.62],[-7.966,-3.073],[-4.108,-6.116],[1.845,-4.785],[4.208,-3.778],[2.606,-1.98],[-7.416,-8.258],[4.744,-12.301],[22.729,-0.367],[34.525,13.301]],"o":[[-34.515,-13.328],[-16.596,-15.534],[4.744,-12.301],[11.041,-1.139],[-0.601,-3.217],[-0.581,-5.626],[1.845,-4.784],[7.15,-1.774],[7.967,3.072],[4.069,4.525],[1.673,7.835],[0,0],[3.474,-7.675],[3.7,-2.665],[6.333,-0.65],[10.195,3.931],[3.887,5.788],[-1.559,4.042],[-3.146,2.824],[6.424,4.466],[9.464,10.538],[-4.924,12.767],[-22.459,0.363],[0,0]],"v":[[-10.846,27.86],[-87.88,-15.916],[-105.631,-59.522],[-72.969,-78.133],[-42.824,-77.349],[-44.549,-88.944],[-43.793,-105.036],[-31.351,-115.543],[-4.72,-112.231],[13.666,-100.256],[20.738,-86.555],[18.389,-62.223],[28.153,-58.458],[42.752,-78.065],[57.192,-83.468],[78.856,-79.997],[100.816,-64.568],[102.98,-48.427],[92.734,-35.997],[83.67,-28.563],[106.534,-8.901],[118.24,26.821],[75.806,47.215],[-10.673,27.926]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.388235300779,0.188235297799,0.003921568859,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 9","np":2,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-96.132,-37.076],[19.577,-50.759],[96.132,37.076],[-19.577,50.759]],"o":[[96.132,37.076],[-19.577,50.759],[-96.132,-37.076],[19.577,-50.759]],"v":[[47.126,-122.188],[185.74,36.853],[-23.769,61.628],[-162.383,-97.413]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.086274512112,0.733333349228,0.749019622803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 10","np":2,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-117.51,-45.322],[23.968,-62.145],[117.51,45.322],[-23.968,62.145]],"o":[[117.51,45.322],[-23.968,62.145],[-117.51,-45.322],[23.968,-62.145]],"v":[[55.08,-142.8],[224.453,51.786],[-31.717,82.246],[-201.09,-112.34]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.164705887437,0.78823530674,0.839215695858,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 11","np":2,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-114.491,-43.529],[-29.542,56.213]],"o":[[0,0],[0,0],[-17.629,62.108],[113.079,42.993],[0,0]],"v":[[224.454,51.772],[-201.089,-112.353],[-219.693,-64.118],[-47.309,124.861],[205.85,100.01]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.086274512112,0.733333349228,0.749019622803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 12","np":1,"cix":2,"bm":0,"ix":12,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":30,"ty":4,"nm":"Tron","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[-27]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[340.148,414.781,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-511.156,898.515,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[68.026,68.026,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.545,-2.097],[69.989,-12.83],[1.766,69.917]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[2.017,-6.215],[-7.138,69.667],[-57.051,-54.889]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[6.03,-14.452],[-50.53,-61.13],[42.022,-44.156]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[51.804,-40.786],[71.494,-22.19],[17.819,-12.455]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[53.811,-51.145],[-74.608,-74.609],[-7.012,94.504],[87.044,-19.569]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":6,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-68.676,0],[0,68.675],[68.675,0],[0,-68.676]],"o":[[68.675,0],[0,-68.676],[-68.676,0],[0,68.675]],"v":[[0.001,124.347],[124.348,0],[0.001,-124.347],[-124.348,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.921568632126,0,0.160784319043,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":33,"ty":4,"nm":"Fantom 2","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[608.377,224.441,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[721.17,-131.016,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[46.931,46.931,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-0.054,0.968],[-11.295,6.875],[0,0],[0,0],[1.614,-2.517],[0.219,-3.642],[0,0],[0.017,-1.043],[0,0],[0,0]],"o":[[0,0],[0,0],[0.018,-1.221],[0.573,-10.35],[0,0],[0,0],[-4.961,2.987],[-1.338,2.087],[0,0],[-0.044,0.797],[0,0],[0,0],[0,0]],"v":[[-124.334,-8.745],[-124.312,-12.946],[-124.303,-13.655],[-124.199,-16.867],[-108.535,-40.108],[-108.191,-40.316],[-103.61,-32.709],[-113.1,-24.67],[-115.262,-16.654],[-115.274,-16.447],[-115.363,-13.741],[-115.377,-12.514],[-115.396,-8.762]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[-2.869,-1.73],[0,0],[-0.055,-0.03],[0,0],[0,0],[0,0],[0,0],[2.87,1.73],[0,0],[0.054,0.031],[0,0],[0,0],[0,0]],"o":[[0.186,3.346],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.186,-3.345],[0,0],[-0.058,-0.035],[0,0],[0,0],[0,0],[0,0]],"v":[[-92.897,49.349],[-87.077,59.016],[-31.896,92.279],[-31.727,92.377],[-31.678,92.404],[-31.681,92.301],[-31.687,92.154],[-35.271,27.822],[-41.091,18.156],[-96.272,-15.107],[-96.44,-15.206],[-96.489,-15.233],[-96.487,-15.13],[-96.48,-14.982]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-23.022,87.948],[23.029,60.22],[-26.388,30.252]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[-88.334,-20.521],[-38.916,9.446],[-42.283,-48.25]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[-0.091,-0.429],[0,0],[0.344,0.207],[0,0],[0.054,0.03],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[-0.336,-0.282],[0,0],[-0.057,-0.035],[0,0],[0,0],[0,0],[0,0],[0.022,0.401]],"v":[[-29.804,12.653],[22.905,-19.084],[21.883,-19.821],[-33.299,-53.025],[-33.467,-53.123],[-33.516,-53.15],[-33.514,-53.047],[-33.507,-52.9],[-29.976,11.405]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[-0.343,-0.207],[0,0],[-0.055,-0.031],[0,0],[0,0],[0,0],[0,0],[0.092,0.429]],"o":[[0.337,0.281],[0,0],[0.058,0.035],[0,0],[0,0],[0,0],[0,0],[-0.022,-0.4],[0,0]],"v":[[-25.127,20.421],[-24.105,21.157],[31.077,54.362],[31.246,54.46],[31.295,54.487],[31.293,54.384],[31.286,54.236],[27.755,-10.069],[27.582,-11.317]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[-1.614,2.517],[-0.219,3.642],[0,0],[-0.017,1.043],[0,0],[0,0],[0,0],[0,0],[0,0],[0.054,-0.968],[11.295,-6.875],[0,0]],"o":[[4.96,-2.987],[1.338,-2.087],[0,0],[0.044,-0.797],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.018,1.222],[-0.573,10.35],[0,0],[0,0]],"v":[[103.608,32.709],[113.098,24.67],[115.26,16.654],[115.272,16.447],[115.361,13.741],[115.375,12.514],[115.394,8.763],[124.332,8.746],[124.31,12.946],[124.301,13.655],[124.197,16.867],[108.533,40.108],[108.189,40.316]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[-0.349,-6.3],[0,0],[0,0],[0,0],[1.588,2.775],[0,0],[2.936,1.899],[0,0]],"o":[[0,0],[5.405,3.257],[0,0],[0,0],[0,0],[-0.182,-3.576],[0,0],[-1.636,-2.738],[0,0],[0,0]],"v":[[-25.638,-58.272],[26.245,-27.009],[36.377,-10.182],[39.728,50.165],[96.73,15.843],[93.251,-44.426],[91.198,-54.439],[91.105,-54.599],[83.545,-61.053],[31.21,-92.501]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0.358,6.305],[0,0],[-2.166,1.691],[0,0],[0,0],[-3.539,-2.139],[0,0],[-0.359,-6.304],[0,0],[2.494,-1.603],[0.182,-0.099],[0,0],[0.182,-0.1],[0,0],[0,0],[3.323,2.008]],"o":[[-5.404,-3.266],[0,0],[-0.216,-3.797],[0,0],[0,0],[2.588,-1.471],[0,0],[5.404,3.266],[0,0],[0.234,4.111],[-0.256,0.164],[0,0],[-0.176,0.116],[0,0],[0,0],[-2.493,1.206],[0,0]],"v":[[-91.683,66.939],[-101.829,50.087],[-105.488,-14.242],[-102.227,-22.676],[-102.255,-22.723],[27.14,-100.635],[36.762,-99.894],[91.906,-66.565],[102.053,-49.713],[105.711,14.617],[101.803,23.364],[101.151,23.757],[-26.721,100.751],[-27.258,101.075],[-27.592,101.276],[-27.606,101.254],[-36.538,100.269]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":10,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[47.233,78.444],[78.444,-47.233],[-47.233,-78.444],[-78.445,47.234]],"o":[[-47.234,-78.445],[-78.445,47.233],[47.233,78.445],[78.444,-47.233]],"v":[[142.036,-85.523],[-85.524,-142.036],[-142.037,85.523],[85.523,142.036]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.098039217293,0.411764711142,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":34,"ty":4,"nm":"Avalanche 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":15,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-472,-228,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-197,137,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[40.25,40.25,100]},{"t":150,"s":[14.242,14.242,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.713,4.836],[0,0],[0,0],[2.171,-7.872],[0,0],[-7.98,2.134],[0,0],[0,0],[0,0],[-1.785,6.573],[0,0]],"o":[[0,0],[0,0],[-5.81,-5.738],[0,0],[-2.171,7.872],[0,0],[0,0],[0,0],[6.613,-1.769],[0,0],[1.731,-6.32]],"v":[[12.398,-54.356],[-6.769,-73.496],[-14.95,-81.708],[-29.315,-77.867],[-68.784,66.92],[-58.206,77.24],[-37.913,71.814],[-24.004,68.095],[-21.61,67.455],[-6.227,52.345],[17.856,-33.941]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.011,-7.824],[0,0],[-7.549,2.019],[0,0],[5.618,5.665]],"o":[[-5.648,-5.776],[0,0],[-2.041,7.713],[0,0],[7.659,-2.048],[0,0]],"v":[[55.303,-12.004],[41.517,-8.318],[28.756,40.847],[38.928,51.267],[86.847,38.455],[90.57,24.319]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-66.345,17.74],[-17.74,-66.345],[66.345,-17.74],[17.74,66.345]],"o":[[66.345,-17.74],[17.74,66.345],[-66.345,17.74],[-17.74,-66.345]],"v":[[-32.12,-120.128],[120.128,-32.12],[32.12,120.128],[-120.128,32.12]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.909803926945,0.254901975393,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":35,"ty":4,"nm":"Avalanche","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[632,-556,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[352,-8,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[67.84,67.84,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[4.713,4.836],[0,0],[0,0],[2.171,-7.872],[0,0],[-7.98,2.134],[0,0],[0,0],[0,0],[-1.785,6.573],[0,0]],"o":[[0,0],[0,0],[-5.81,-5.738],[0,0],[-2.171,7.872],[0,0],[0,0],[0,0],[6.613,-1.769],[0,0],[1.731,-6.32]],"v":[[12.398,-54.356],[-6.769,-73.496],[-14.95,-81.708],[-29.315,-77.867],[-68.784,66.92],[-58.206,77.24],[-37.913,71.814],[-24.004,68.095],[-21.61,67.455],[-6.227,52.345],[17.856,-33.941]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.011,-7.824],[0,0],[-7.549,2.019],[0,0],[5.618,5.665]],"o":[[-5.648,-5.776],[0,0],[-2.041,7.713],[0,0],[7.659,-2.048],[0,0]],"v":[[55.303,-12.004],[41.517,-8.318],[28.756,40.847],[38.928,51.267],[86.847,38.455],[90.57,24.319]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-66.345,17.74],[-17.74,-66.345],[66.345,-17.74],[17.74,66.345]],"o":[[66.345,-17.74],[17.74,66.345],[-66.345,17.74],[-17.74,-66.345]],"v":[[-32.12,-120.128],[120.128,-32.12],[32.12,120.128],[-120.128,32.12]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.909803926945,0.254901975393,0.258823543787,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":36,"ty":4,"nm":"BNB","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-34]},{"t":150,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[72,-140,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-754,194,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[44.359,44.359,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-101.16,37.76],[-128.935,50.316],[-96.676,86.793],[-21.206,52.554],[-33.123,39.078],[-80.818,60.762]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ind":1,"ty":"sh","ix":2,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-121.501,14.759],[-105.643,-11.272],[-133.418,1.283],[-149.276,27.314],[-137.359,40.79],[-109.584,28.234]],"c":true},"ix":2},"nm":"Path 2","mn":"ADBE Vector Shape - Group","hd":false},{"ind":2,"ty":"sh","ix":3,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-74.445,-38.862],[-46.67,-51.417],[-30.812,-77.448],[-58.587,-64.893]],"c":true},"ix":2},"nm":"Path 3","mn":"ADBE Vector Shape - Group","hd":false},{"ind":3,"ty":"sh","ix":4,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-69.54,42.301],[-41.765,29.745],[-53.683,16.269],[-81.458,28.825]],"c":true},"ix":2},"nm":"Path 4","mn":"ADBE Vector Shape - Group","hd":false},{"ind":4,"ty":"sh","ix":5,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-13.319,30.259],[-1.401,43.735],[26.374,31.179],[42.232,5.148],[30.314,-8.327],[14.456,17.704]],"c":true},"ix":2},"nm":"Path 5","mn":"ADBE Vector Shape - Group","hd":false},{"ind":5,"ty":"sh","ix":6,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[0.385,-105.038],[28.16,-117.593],[40.077,-104.118],[55.935,-130.149],[44.018,-143.624],[16.243,-131.069]],"c":true},"ix":2},"nm":"Path 6","mn":"ADBE Vector Shape - Group","hd":false},{"ind":6,"ty":"sh","ix":7,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[68.843,-71.59],[41.489,-26.905],[53.407,-13.429],[96.618,-84.146],[64.36,-120.623],[48.502,-94.592]],"c":true},"ix":2},"nm":"Path 7","mn":"ADBE Vector Shape - Group","hd":false},{"ind":7,"ty":"sh","ix":8,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[49.141,-62.655],[37.224,-76.13],[21.366,-50.099],[33.283,-36.624]],"c":true},"ix":2},"nm":"Path 8","mn":"ADBE Vector Shape - Group","hd":false},{"ind":8,"ty":"sh","ix":9,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[16.882,-99.132],[-10.893,-86.577],[-38.246,-41.891],[-85.941,-20.208],[-101.799,5.823],[-89.882,19.299],[-42.187,-2.385],[-21.846,20.617],[5.93,8.062],[21.787,-17.97],[1.446,-40.971],[28.8,-85.656]],"c":true},"ix":2},"nm":"Path 9","mn":"ADBE Vector Shape - Group","hd":false},{"ind":9,"ty":"sh","ix":10,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-122.14,-17.178],[-78.929,-87.895],[-3.459,-122.134],[-19.317,-96.102],[-67.012,-74.419],[-94.365,-29.734]],"c":true},"ix":2},"nm":"Path 10","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":11,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-93.039,82.278],[-43.445,-49.126],[93.039,-82.278],[43.445,49.126]],"o":[[93.039,-82.278],[43.444,49.126],[-93.039,82.278],[-43.445,-49.126]],"v":[[-104.583,-118.256],[142.541,-178.283],[52.743,59.646],[-194.381,119.673]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.866666674614,0.670588254929,0.121568627656,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-113.73,100.576],[-53.189,-60.145],[113.73,-100.576],[53.189,60.145]],"o":[[113.73,-100.576],[53.189,60.145],[-113.73,100.576],[-53.189,-60.145]],"v":[[-122.229,-138.213],[180.005,-211.42],[70.387,79.593],[-231.847,152.8]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176474094,0.72549021244,0.043137256056,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[-110.136,98.341],[43.749,62.816]],"o":[[0,0],[0,0],[56.669,53.342],[108.777,-97.128],[0,0]],"v":[[179.997,-211.429],[-231.856,152.79],[-190.571,199.474],[107.335,119.933],[221.283,-164.744]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.709803938866,0.537254929543,0.050980392843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":1,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":39,"ty":4,"nm":"Eth 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-21.105,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-670,-102,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[-962,4,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[36.284,36.284,100]},{"t":150,"s":[61.977,61.977,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":40,"ty":4,"nm":"Eth 4","parent":11,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-74.714]},{"t":150,"s":[55.286]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[847.635,-230.86,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[450.93,469.571,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[-35.106,-35.106,100]},{"t":150,"s":[-8.716,-8.716,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":42,"ty":4,"nm":"Eth","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[-112]},{"t":150,"s":[-37]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-701.502,177.729,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[573.006,-304.366,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[100,100,100]},{"t":150,"s":[22.847,22.847,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.398,-58.915],[-64.324,-35.5]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.915],[13.401,32.429],[-64.324,-35.501]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[-67.703,-17.342]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.870588243008,0.886274516582,0.964705884457,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 3","np":2,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[49.969,-164.089],[30.399,-58.915],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.815686285496,0.839215695858,0.917647063732,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 4","np":2,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[30.399,-58.916],[13.401,32.428],[110.358,-2.996]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.768627464771,0.784313738346,0.847058832645,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 5","np":2,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0]],"v":[[10.022,50.587],[-3.183,121.552],[106.979,15.163]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.823529422283,0.847058832645,0.92549020052,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-112.527,-20.939],[20.939,-112.527],[112.527,20.939],[-20.939,112.527]],"o":[[112.527,20.939],[-20.939,112.527],[-112.527,-20.939],[20.939,-112.527]],"v":[[61.342,-225.213],[227.177,16.449],[-14.485,182.284],[-180.32,-59.378]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.407843142748,0.494117647409,0.890196084976,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 7","np":2,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":43,"ty":4,"nm":"Polygon 2","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[-458,-831,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[730,-107,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[35.714,35.714,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,2.213],[0,0],[1.91,1.106],[0,0],[1.916,-1.101],[0,0],[0,-2.207],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.091,0],[0.934,-0.543],[0,0],[0,-2.212],[0,0],[-1.91,-1.106],[0,0],[-1.915,1.102],[0,0],[0,2.208],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-1.915,1.101]],"o":[[0,0],[1.915,-1.106],[0,0],[0,-2.207],[0,0],[-1.915,-1.106],[0,0],[-1.915,1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.939,-0.543],[-1.091,0],[0,0],[-1.915,1.106],[0,0],[0,2.207],[0,0],[1.91,1.102],[0,0],[1.915,-1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.916,1.101],[0,0]],"v":[[60.391,6.113],[96.549,-14.766],[99.648,-20.141],[99.648,-61.893],[96.549,-67.268],[60.391,-88.146],[54.186,-88.146],[18.029,-67.268],[14.929,-61.893],[14.929,12.724],[-10.427,27.362],[-35.783,12.724],[-35.783,-16.556],[-10.427,-31.193],[6.298,-21.539],[6.298,-41.181],[-7.327,-49.045],[-10.432,-49.875],[-13.532,-49.045],[-49.689,-28.166],[-52.789,-22.792],[-52.789,18.96],[-49.689,24.335],[-13.532,45.213],[-7.327,45.213],[28.831,24.34],[31.93,18.965],[31.93,-55.652],[32.39,-55.912],[57.286,-70.289],[82.642,-55.652],[82.642,-26.371],[57.286,-11.734],[40.588,-21.377],[40.588,-1.736],[54.186,6.118],[60.391,6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[163.332,-161.368],[-116.474,-161.368],[-116.474,118.439],[163.332,118.439]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.482352942228,0.247058823705,0.89411765337,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":244,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":44,"ty":4,"nm":"Polygon 3","parent":13,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[52,824,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[600,554,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[33.804,33.804,100]},{"t":150,"s":[24.008,24.008,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,2.213],[0,0],[1.91,1.106],[0,0],[1.916,-1.101],[0,0],[0,-2.207],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.091,0],[0.934,-0.543],[0,0],[0,-2.212],[0,0],[-1.91,-1.106],[0,0],[-1.915,1.102],[0,0],[0,2.208],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-1.915,1.101]],"o":[[0,0],[1.915,-1.106],[0,0],[0,-2.207],[0,0],[-1.915,-1.106],[0,0],[-1.915,1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.939,-0.543],[-1.091,0],[0,0],[-1.915,1.106],[0,0],[0,2.207],[0,0],[1.91,1.102],[0,0],[1.915,-1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.916,1.101],[0,0]],"v":[[60.391,6.113],[96.549,-14.766],[99.648,-20.141],[99.648,-61.893],[96.549,-67.268],[60.391,-88.146],[54.186,-88.146],[18.029,-67.268],[14.929,-61.893],[14.929,12.724],[-10.427,27.362],[-35.783,12.724],[-35.783,-16.556],[-10.427,-31.193],[6.298,-21.539],[6.298,-41.181],[-7.327,-49.045],[-10.432,-49.875],[-13.532,-49.045],[-49.689,-28.166],[-52.789,-22.792],[-52.789,18.96],[-49.689,24.335],[-13.532,45.213],[-7.327,45.213],[28.831,24.34],[31.93,18.965],[31.93,-55.652],[32.39,-55.912],[57.286,-70.289],[82.642,-55.652],[82.642,-26.371],[57.286,-11.734],[40.588,-21.377],[40.588,-1.736],[54.186,6.118],[60.391,6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[163.332,-161.368],[-116.474,-161.368],[-116.474,118.439],[163.332,118.439]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.482352942228,0.247058823705,0.89411765337,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":244,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0},{"ddd":0,"ind":45,"ty":4,"nm":"Polygon","parent":12,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-112,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":0,"s":[449.061,-522.249,0],"to":[0,0,0],"ti":[0,0,0]},{"t":150,"s":[952.103,-240.191,0]}],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":0,"s":[90.816,90.816,100]},{"t":150,"s":[40.112,40.112,100]}],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,2.213],[0,0],[1.91,1.106],[0,0],[1.916,-1.101],[0,0],[0,-2.207],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.091,0],[0.934,-0.543],[0,0],[0,-2.212],[0,0],[-1.91,-1.106],[0,0],[-1.915,1.102],[0,0],[0,2.208],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-1.915,1.101]],"o":[[0,0],[1.915,-1.106],[0,0],[0,-2.207],[0,0],[-1.915,-1.106],[0,0],[-1.915,1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[-0.939,-0.543],[-1.091,0],[0,0],[-1.915,1.106],[0,0],[0,2.207],[0,0],[1.91,1.102],[0,0],[1.915,-1.106],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1.916,1.101],[0,0]],"v":[[60.391,6.113],[96.549,-14.766],[99.648,-20.141],[99.648,-61.893],[96.549,-67.268],[60.391,-88.146],[54.186,-88.146],[18.029,-67.268],[14.929,-61.893],[14.929,12.724],[-10.427,27.362],[-35.783,12.724],[-35.783,-16.556],[-10.427,-31.193],[6.298,-21.539],[6.298,-41.181],[-7.327,-49.045],[-10.432,-49.875],[-13.532,-49.045],[-49.689,-28.166],[-52.789,-22.792],[-52.789,18.96],[-49.689,24.335],[-13.532,45.213],[-7.327,45.213],[28.831,24.34],[31.93,18.965],[31.93,-55.652],[32.39,-55.912],[57.286,-70.289],[82.642,-55.652],[82.642,-26.371],[57.286,-11.734],[40.588,-21.377],[40.588,-1.736],[54.186,6.118],[60.391,6.118]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[163.332,-161.368],[-116.474,-161.368],[-116.474,118.439],[163.332,118.439]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.482352942228,0.247058823705,0.89411765337,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"rd","nm":"Round Corners 1","r":{"a":0,"k":244,"ix":1},"ix":2,"mn":"ADBE Vector Filter - RC","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Group 2","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":151,"st":0,"bm":0}],"markers":[]}');
                // EXTERNAL MODULE: ./src/hooks/useUA.ts + 2 modules
                var useUA = __webpack_require__("OKG+");; // CONCATENATED MODULE: ./src/routes/defiwallet/components/Transition.tsx







                var Transition = function(props) {
                    var isDesktop = (0, useUA /* useUA */ .nD)().isDesktop;
                    var animateData = isDesktop ? animate_desktop_namespaceObject : animate_namespaceObject;
                    return /*#__PURE__*/ (0, jsx_runtime.jsx)(LottiePlayer_modern, (0, _object_spread /* default */ .Z)({
                        animationData: animateData
                    }, props));
                };


                /***/
            }),

        /***/
        "3zi4":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "c": () => ( /* binding */ Web3Ease)
                    /* harmony export */
                });
                /* harmony import */
                var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oUqw");
                /* harmony import */
                var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("CW2u");
                /* harmony import */
                var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("CgVz");
                /* harmony import */
                var _Section__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("4oCX");
                /* harmony import */
                var _FadeInComp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("mRbc");
                /* harmony import */
                var _CTAButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("G+it");






                function Web3Ease() {
                    var t = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__ /* .useTranslation */ .$G)();
                    return /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
                        children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Section__WEBPACK_IMPORTED_MODULE_3__ /* .Section */ .$, {
                            className: "mt-12 md:mt-20 lg:mt-30 mb-20 md:mb-[120px]",
                            children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_FadeInComp__WEBPACK_IMPORTED_MODULE_4__ /* .FadeInComp */ .O, {
                                children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                    className: "light-line-border flex flex-col items-center rounded-2xl border px-6 py-12 lg:flex-row lg:items-center lg:justify-between lg:px-[120px] lg:py-[80px]",
                                    children: [
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                                            className: "flex flex-col items-center lg:max-w-[332px] lg:items-start",
                                            children: [
                                                /*#__PURE__*/
                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                    className: "t-primary-hover subtitle-1 lg:headline-6 mb-2",
                                                    children: t("defi-wallet", {
                                                        defaultValue: "Binance Web3 Wallet"
                                                    })
                                                }),
                                                /*#__PURE__*/
                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h4", {
                                                    className: "headline-6 md:headline-3 lg:headline-2 t-primary mb-6 text-center lg:mb-12 lg:!text-left",
                                                    children: t("web3-easier", {
                                                        defaultValue: "Web3 is easier with Binance"
                                                    })
                                                }),
                                                /*#__PURE__*/
                                                (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                                    className: "mb-12 lg:mb-0",
                                                    children: /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_CTAButton__WEBPACK_IMPORTED_MODULE_5__ /* .CTAButton */ .m3, {})
                                                })
                                            ]
                                        }),
                                        /*#__PURE__*/
                                        (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
                                            className: "w-[253px] md:w-[478px] lg:w-[535px]",
                                            src: "".concat(_constants__WEBPACK_IMPORTED_MODULE_1__ /* .IMG_URL */ .bV, "/phones.png")
                                        })
                                    ]
                                })
                            })
                        })
                    });
                }


                /***/
            }),

        /***/
        "4LV3":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "K": () => ( /* binding */ enableScroll),
                    /* harmony export */
                    "X": () => ( /* binding */ disableScroll)
                    /* harmony export */
                });
                // left: 37, up: 38, right: 39, down: 40,
                // spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
                var keys = {
                    37: 1,
                    38: 1,
                    39: 1,
                    40: 1
                };

                function preventDefault(e) {
                    e.preventDefault();
                }

                function preventDefaultForScrollKeys(e) {
                    if (keys[e.keyCode]) {
                        preventDefault(e);
                        return false;
                    }
                }
                // call this to Disable
                function disableScroll() {
                    // modern Chrome requires { passive: false } when adding event
                    var supportsPassive = false;
                    try {
                        // @ts-ignore-next-line: Upgrade pika 0.2.6 -> 0.3.57
                        window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                            get: function get() {
                                supportsPassive = true;
                            }
                        }));
                    } catch (e) {}
                    var wheelOpt = supportsPassive ? {
                        passive: false
                    } : false;
                    var wheelEvent = "onwheel" in (document === null || document === void 0 ? void 0 : document.createElement("div")) ? "wheel" : "mousewheel";
                    window.addEventListener("DOMMouseScroll", preventDefault, false) // older FF
                    ;
                    window.addEventListener(wheelEvent, preventDefault, wheelOpt) // modern desktop
                    ;
                    window.addEventListener("touchmove", preventDefault, wheelOpt) // mobile
                    ;
                    window.addEventListener("keydown", preventDefaultForScrollKeys, false);
                }

                function enableScroll() {
                    var supportsPassive = false;
                    try {
                        // @ts-ignore-next-line: Upgrade pika 0.2.6 -> 0.3.57
                        window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                            get: function get() {
                                supportsPassive = true;
                            }
                        }));
                    } catch (e) {}
                    var wheelOpt = supportsPassive ? {
                        passive: false
                    } : false;
                    var wheelEvent = "onwheel" in (document === null || document === void 0 ? void 0 : document.createElement("div")) ? "wheel" : "mousewheel";
                    window.removeEventListener("DOMMouseScroll", preventDefault, false) // older FF
                    ;
                    // @ts-ignore-next-line: Upgrade pika 0.2.6 -> 0.3.57
                    window.removeEventListener(wheelEvent, preventDefault, wheelOpt) // modern desktop
                    ;
                    // @ts-ignore-next-line: Upgrade pika 0.2.6 -> 0.3.57
                    window.removeEventListener("touchmove", preventDefault, wheelOpt) // mobile
                    ;
                    window.removeEventListener("keydown", preventDefaultForScrollKeys, false);
                }


                /***/
            }),

        /***/
        "ZztR":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "j": () => ( /* reexport */ track)
                });

                // UNUSED EXPORTS: getSensors, login

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread.mjs
                var _object_spread = __webpack_require__("ys0/");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_spread_props.mjs
                var _object_spread_props = __webpack_require__("L2LL");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_object_without_properties.mjs + 1 modules
                var _object_without_properties = __webpack_require__("Cmqe");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_to_consumable_array.mjs + 2 modules
                var _to_consumable_array = __webpack_require__("pE0Y");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+utils@2.13.192_@types+react@18.0.28_react@18.2.0/node_modules/@binance/utils/dist/esm/ssr.js
                var ssr = __webpack_require__("VphZ");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+utils@2.13.192_@types+react@18.0.28_react@18.2.0/node_modules/@binance/utils/dist/esm/cookies.js
                var cookies = __webpack_require__("ZhE5");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+client-type@1.0.2/node_modules/@binance/client-type/src/index.js
                var src = __webpack_require__("P37B");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+react-bridge-methods@1.0.3/node_modules/@binance/react-bridge-methods/src/index.js + 2 modules
                var react_bridge_methods_src = __webpack_require__("mU8w");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+bridge-core@1.1.7/node_modules/@binance/bridge-core/src/index.js + 8 modules
                var bridge_core_src = __webpack_require__("0X8O");; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+bridge@0.1.11/node_modules/@binance/bridge/src/utils.js
                const clone = (arr, n) => {
                    const copy = new Array(n)
                    for (let i = 0; i < n; ++i) {
                        copy[i] = arr[i]
                    }

                    return copy
                }

                const splice = (list, index) => {
                    for (; index + 1 < list.length; index++) {
                        list[index] = list[index + 1]
                    }

                    list.pop()
                }

                const isOk = status => status >= 200 && status < 300

                const isArray = a => Object.prototype.toString.call(a) === '[object Array]'

                const isString = a => typeof a === 'string'; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+bridge@0.1.11/node_modules/@binance/bridge/src/methods.js



                const {
                    isHybrid
                } = (0, src /* client */ .L)()

                // - base `Bridge` bridge core which created by adapter
                // - client `Object` the return value of `@binance/client-type`
                /* harmony default export */
                const methods = (base => {
                    const bridge = Object.create(null)

                    bridge.back = (amount = 1) => base.invoke('back', {
                        amount
                    })
                    bridge.setTitle = title => base.invoke('setTitle', {
                        title
                    })
                    bridge.broadcast = data => base.invoke('broadcast', {
                        data
                    })
                    bridge.toast = text => base.invoke('toast', {
                        text
                    })
                    bridge.open = (options) => {
                        if (options.withNavigationBar === undefined) {
                            options.withNavigationBar = true
                        }
                        base.invoke('open', options)
                    }

                    const VOID_METHODS_WITH_NO_DATA = [
                        'notExistBridge', // for test, it's necessary!
                        'stopLoading',
                        'ensureLogged',
                        'isLogged',
                        'getUserInfo',
                    ]

                    const PROMISE_METHODS_WITH_OBJ_PARAMS = [
                        'alert',
                        'addDebitCard', // US App 1.0.0
                    ]

                    VOID_METHODS_WITH_NO_DATA.forEach(name => {
                        bridge[name] = () => base.invoke(name)
                    })

                    PROMISE_METHODS_WITH_OBJ_PARAMS.forEach(name => {
                        bridge[name] = params => base.invoke(name, params)
                    })


                    const LISTENERS = Object.create(null)

                    const initListener = name => {
                        LISTENERS[name] = Object.create({
                            listened: false,
                            events: []
                        })
                    }

                    initListener('back')
                    initListener('broadcast')

                    const arrayRemove = (array, item) => {
                        const index = array.indexOf(item)

                        if (~index) {
                            splice(array, index)
                        }
                    }

                    const wrapOnce = (events, callback) => {
                        const handler = (...args) => {
                            arrayRemove(events, handler)
                            callback(...args)
                        }

                        return handler
                    }

                    const addListener = (name, callback, once) => {
                        const listener = LISTENERS[name]
                        if (!listener) {
                            return
                        }

                        const {
                            events
                        } = listener
                        if (!listener.listened) {
                            listener.listened = true
                            base.handler(name, e => {
                                // Clone events to handle once handler
                                clone(events, events.length).forEach(handler => handler(e))
                            })
                        }

                        events.push(
                            once ?
                            wrapOnce(events, callback) :
                            callback
                        )
                    }

                    bridge.on = (name, callback) => addListener(name, callback)
                    bridge.once = (name, callback) => addListener(name, callback, true)

                    bridge.off = function removeListener(name, callback) {
                        const listener = LISTENERS[name]
                        if (!listener) {
                            return
                        }

                        const {
                            events
                        } = listener

                        // Remove all handlers of event `name`
                        if (arguments.length === 1) {
                            events.length = 0
                            return
                        }

                        arrayRemove(events, callback)
                    }

                    bridge.fetch = (url, {
                        method = 'GET',
                        body = '',
                        headers = {},
                        credentials, // web only
                    } = {}) => base.invoke('fetch', {
                        url,
                        method,
                        body,
                        headers,
                        credentials,
                    }).then(({
                        error,
                        response
                    }) => {
                        // web only
                        if (!isHybrid) {
                            if (error) {
                                return Promise.reject(error)
                            }
                            return Promise.resolve(response)
                        }

                        if (error) {
                            // TODO: we need to handle different network errors
                            const err = new TypeError('Failed to fetch')
                            Object.assign(err, error)
                            throw err
                        }

                        const {
                            status,
                            headers: resHeaders,
                            body: resBody,
                            statusText = '',
                        } = response

                        // Android headers value type is array, in Web it's string.
                        // Take array as standard.
                        const formatHeaders = {}
                        Object.keys(resHeaders).forEach((key) => {
                            const value = resHeaders[key]
                            formatHeaders[key] = isString(value) ? [value] : value
                        })

                        const ok = isOk(status)

                        return {
                            url,
                            ok,
                            status,
                            statusText,
                            json() {
                                return new Promise((resolve, reject) => {
                                    try {
                                        resolve(JSON.parse(resBody))
                                    } catch (err) {
                                        reject(err)
                                    }
                                })
                            },
                            text() {
                                return Promise.resolve(resBody)
                            },
                            headers: formatHeaders,
                        }
                    })

                    ///////////////////////////////////////////////////////
                    // Always comes at the bottom
                    base.ready()

                    return bridge
                });

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+bridge@0.1.11/node_modules/@binance/bridge/src/index.js
                /* provided dependency */
                var process = __webpack_require__("FXEK");




                const create = (adapter = bridge_core_src /* adapterFake */ .Im) =>
                    new bridge_core_src /* BridgeFactory */ .mH()
                    .register({
                        test: ({
                            clientType
                        }) => clientType === 'iOS' || clientType === 'MacOS',
                        adapter: bridge_core_src /* adapterIOS */ .T9
                    })
                    .register({
                        test: ({
                            clientType
                        }) => clientType === 'Android',
                        adapter: bridge_core_src /* adapterAndroid */ .Sc
                    })
                    .default(adapter)
                    .create(methods, getUserAgent())

                const createBrowserAdapter = browserMethods => {
                    const factory = new bridge_core_src /* BrowserAdapterFactory */ .$()
                    Object.keys(browserMethods).forEach(name => {
                        factory.add(name, browserMethods[name])
                    })

                    return factory.create('BrowserFakeBridge')
                }

                function getUserAgent() {
                    const isBrowser =
                        true &&
                        typeof window.document !== 'undefined'
                    const isNode =
                        typeof process !== 'undefined' &&
                        process.versions != null &&
                        process.versions.node != null

                    let userAgent = ''

                    if (isBrowser) {
                        userAgent = window.navigator.userAgent
                    }
                    if (isNode) {
                        userAgent = `node ${process.versions.node}`
                    }
                    return userAgent
                }



                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/checkFields.js
                var checkFields = __webpack_require__("jUbx");
                // EXTERNAL MODULE: ./node_modules/.pnpm/ua-parser-js@0.7.40/node_modules/ua-parser-js/src/ua-parser.js
                var ua_parser = __webpack_require__("kxow");; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/utils.js


                var utils_isHybrid = (0, src /* client */ .L)().isHybrid;
                var joinNameVersion = function(name, version) {
                    return "".concat(name, " ").concat(version);
                };
                var ClientType;
                (function(ClientType) {
                    ClientType["Electron"] = "electron";
                    ClientType["Hybrid"] = "Hybrid";
                    ClientType["Web"] = "Web";
                })(ClientType || (ClientType = {}));
                var getClientType = function() {
                    if (/electron/i.test(navigator.userAgent)) {
                        return ClientType.Electron;
                    }
                    return utils_isHybrid ? ClientType.Hybrid : ClientType.Web;
                };
                var getDeviceBaseInfo = function() {
                    var parser = new UAParser();
                    var result = parser.getResult();
                    var deviceInfo = {
                        browser: joinNameVersion(result.browser.name, result.browser.version),
                        os: joinNameVersion(result.os.name, result.os.version),
                        clientType: getClientType(),
                        screenHeight: window.screen.height,
                        screenWidth: window.screen.width,
                        userAgent: navigator.userAgent
                    };
                    return deviceInfo;
                };
                var generatorBaseInfo = function() {
                    return {
                        localTime: +new Date(),
                        referrerURL: document.referrer,
                        url: window.location.href
                    };
                };
                var loadScript = function(link, callback) {
                    var scriptEl = document.createElement("script");
                    // prevent OneTrust block js
                    scriptEl.setAttribute("data-ot-ignore", "true");
                    scriptEl.setAttribute("class", "optanon-category-C0001");
                    var firstScriptEl = document.getElementsByTagName("script")[0];
                    scriptEl.async = true;
                    scriptEl.src = link;
                    scriptEl.onload = callback;
                    if (firstScriptEl === null || firstScriptEl === void 0 ? void 0 : firstScriptEl.parentNode) {
                        firstScriptEl.parentNode.insertBefore(scriptEl, firstScriptEl);
                    } else {
                        document.body.appendChild(scriptEl);
                    }
                };

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/shared.js
                var PAGE_VIEW_EVENT = "pageView";
                var PAGE_QUIT_EVENT = "pageQuit";
                var WEB_CLICK_EVENT = "webClick";
                var ELEMENT_SHOW_EVENT = "elementShow";
                var DEFAULT_OTHER_DISABLE_EVENTS = [];
                var DEFAULT_SENSOR_ADDRESS = "https://bin.bnbstatic.com/static/sensors/sensorsdata@1.15.26.js";
                var DEFAULT_SENSORHEATMAP_ADDRESS = "https://bin.bnbstatic.com/static/sensors/heatmap@1.15.26.js";
                // export const DEFAULT_SENSOR_ADDRESS = 'https://bin.bnbstatic.com/static/sensors/sensorsdata@1.15.1.min.js'
                var GOOGLE_SDK_ADDRESS = "https://www.google-analytics.com/analytics.js";
                var GOOGLE_TRACK_ID = "UA-162512367-1";

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/sensors.js










                var _sensor;
                var SENSOR_API = [
                    "track",
                    "quick",
                    "register",
                    "registerPage",
                    "registerOnce",
                    "clearAllRegister",
                    "trackSignup",
                    "trackAbtest",
                    "setProfile",
                    "setOnceProfile",
                    "appendProfile",
                    "incrementProfile",
                    "deleteProfile",
                    "unsetProfile",
                    "identify",
                    "login",
                    "logout",
                    "trackLink",
                    "use",
                ];
                var sensors_isHybrid = (0, src /* client */ .L)().isHybrid;
                var bridge = create(createBrowserAdapter(react_bridge_methods_src));
                var init = function(para) {
                    var _sdk_url = para.sdk_url,
                        sdk_url = _sdk_url === void 0 ? DEFAULT_SENSOR_ADDRESS : _sdk_url,
                        _heatmap_url = para.heatmap_url,
                        heatmap_url = _heatmap_url === void 0 ? DEFAULT_SENSORHEATMAP_ADDRESS : _heatmap_url,
                        _name = para.name,
                        name = _name === void 0 ? "sensor" : _name,
                        rest = (0, _object_without_properties /* default */ .Z)(para, [
                            "sdk_url",
                            "heatmap_url",
                            "name"
                        ]);
                    sdk_url = sdk_url.replace("sensorsdata@1.15.1.min", "sensorsdata@1.15.26");
                    heatmap_url = heatmap_url.replace("sensorsdata@1.15.1.min", "sensorsdata@1.15.26");
                    window.sensorsDataAnalytic201505 = name;
                    if (window[name]) return;
                    window[name] = window[name] || function(handlerName) {
                        return function() {
                            for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
                                arg[_key] = arguments[_key];
                            }
                            (window[name]._q = window[name]._q || []).push([
                                handlerName,
                                arg
                            ]);
                        };
                    };
                    _sensor = window[name];
                    for (var i = 0; i < SENSOR_API.length; i++) {
                        _sensor[SENSOR_API[i]] = _sensor.call(null, SENSOR_API[i]);
                    }
                    if (!_sensor._t) {
                        loadScript(sdk_url, function() {
                            return _sensor = window[name];
                        });
                        _sensor.para = (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({}, rest), {
                            heatmap_url: heatmap_url
                        });
                    }
                };
                var createProxySensorApiObj = function() {
                    var sensorHandlerObj = Object.create(null);
                    SENSOR_API.forEach(function(key) {
                        sensorHandlerObj[key] = {
                            configurable: true,
                            get: function() {
                                if (_sensor) {
                                    return _sensor[key];
                                }
                                if (ssr /* isClient */ .C) {
                                    // eslint-disable-next-line no-console
                                    console.error("error: run ".concat(key, " handler after init"));
                                }
                                console.log("empty", _sensor);
                                return function() {};
                            }
                        };
                    });
                    var sensors = Object.create(null);
                    Object.defineProperties(sensors, sensorHandlerObj);
                    sensors.init = ssr /* isClient */ .C ? init : function() {};
                    return sensors;
                };
                var createSensor = function() {
                    // proxy sensorApi
                    var proxySensorApiObj = createProxySensorApiObj();
                    return proxySensorApiObj;
                };
                var registerPage = function(sensors, publicParams) {
                    if (!ssr /* isClient */ .C) return;
                    (0, checkFields /* checkFields */ .d)(publicParams);
                    var reg = /\/([a-z]{2}(-[a-zA-Z]{2})?)(\/)?/;
                    var _location = window.location,
                        pathname = _location.pathname,
                        hash = _location.hash;
                    var matches = pathname.match(reg);
                    var df_1 = ClientType.Web;
                    var df_2 = matches ? matches[1] : String();
                    if (getClientType() === ClientType.Electron) {
                        matches = hash.match(reg);
                        df_2 = matches ? matches[1] : String();
                        df_1 = ClientType.Electron;
                    }
                    if (sensors_isHybrid) {
                        var waitAsync = true;
                        var taskList = [];
                        var _quick = sensors.quick;
                        Object.defineProperty(sensors, "quick", {
                            get: function() {
                                return function(params) {
                                    if (waitAsync) {
                                        taskList.push(function() {
                                            return _quick(params);
                                        });
                                    } else {
                                        _quick(params);
                                    }
                                };
                            }
                        });
                        bridge.getAppConfig().then(function(param) {
                            var project_type = param.project_type;
                            waitAsync = false;
                            sensors.registerPage((0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                                $url: window.location.href,
                                $bot_name: cookies /* cookies.read */ .Q.read("bnc-uuid"),
                                df_1: project_type,
                                df_fvideoid: cookies /* cookies.read */ .Q.read("BNC_FV_KEY")
                            }, publicParams), {
                                df_2: df_2,
                                theme: cookies /* cookies.read */ .Q.read("theme")
                            }));
                            taskList.forEach(function(i) {
                                return i();
                            });
                        });
                    } else {
                        sensors.registerPage((0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({
                            $url: window.location.href,
                            $bot_name: cookies /* cookies.read */ .Q.read("bnc-uuid"),
                            df_1: df_1,
                            df_fvideoid: cookies /* cookies.read */ .Q.read("BNC_FV_KEY")
                        }, publicParams), {
                            df_2: df_2,
                            theme: cookies /* cookies.read */ .Q.read("theme")
                        }));
                    }
                };

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/ga.js




                var _ga;
                var ssrHandler = function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    var _console;
                    (_console = console).log.apply(_console, [
                        "ssr call"
                    ].concat((0, _to_consumable_array /* default */ .Z)(args)));
                };
                var checkIsDisable = function() {
                    if (cookies /* cookies.read */ .Q.read("data_opt_out") === "y") {
                        window["ga-disable-".concat(GOOGLE_TRACK_ID)] = true;
                    } else {
                        window["ga-disable-".concat(GOOGLE_TRACK_ID)] = false;
                    }
                };
                var ga_init = function(para) {
                    var _sdk_url = para.sdk_url,
                        sdk_url = _sdk_url === void 0 ? GOOGLE_SDK_ADDRESS : _sdk_url,
                        _name = para.name,
                        name = _name === void 0 ? "ga" : _name;
                    window.GoogleAnalyticsObject = name;
                    if (!window[name]) {
                        window[name] = window[name] || function() {
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            (window[name].q = window[name].q || []).push(args);
                        };
                        window[name].l = +new Date();
                    }
                    if (!document.querySelector("script[src*=analytics]")) loadScript(sdk_url, function() {
                        return _ga = window[name];
                    });
                    _ga = window[name];
                    _ga("create", GOOGLE_TRACK_ID, "auto");
                };
                var createGA = function() {
                    var para = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    if (ssr /* isClient */ .C) {
                        checkIsDisable();
                        ga_init(para);
                        var ga = function() {
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            _ga.apply(void 0, (0, _to_consumable_array /* default */ .Z)(args));
                        };
                        ga.track = function(eventName, params, callback) {
                            _ga("send", {
                                hitType: "event",
                                eventCategory: eventName,
                                eventAction: params === null || params === void 0 ? void 0 : params.elementID,
                                eventLabel: window.location,
                                custom_dimension: params,
                                hitCallback: callback
                            });
                        };
                        ga.login = function(userId) {
                            _ga("set", "userId", userId);
                        };
                        return ga;
                    }
                    var ga1 = function() {};
                    ga1.track = ssrHandler;
                    ga1.login = ssrHandler;
                    return ga1;
                };
                /* harmony default export */
                const esm_ga = (createGA);

                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/trackGroup.js
                var esm_trackGroup = __webpack_require__("3mgh");; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/loginGroup.js
                var _loginGroup = function(id) {
                    console.warn("You login ".concat(id, ",but never init sensor or ga"));
                };
                var setLoginGroup = function(loginGroup) {
                    _loginGroup = loginGroup;
                };
                var loginCustom = function(id) {
                    return _loginGroup(id);
                };
                /* harmony default export */
                const loginGroup = (loginCustom);

                // EXTERNAL MODULE: ./node_modules/.pnpm/@swc+helpers@0.4.3/node_modules/@swc/helpers/src/_async_to_generator.mjs
                var _async_to_generator = __webpack_require__("ttNT");
                // EXTERNAL MODULE: external "regeneratorRuntime"
                var external_regeneratorRuntime_ = __webpack_require__("Pz56");
                var external_regeneratorRuntime_default = /*#__PURE__*/ __webpack_require__.n(external_regeneratorRuntime_);
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+api@1.18.153_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/api/dist/esm/authcenter/auth.js + 2 modules
                var auth = __webpack_require__("/i8T");
                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+api@1.18.153_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/api/dist/esm/account/user.js
                var user = __webpack_require__("SeXF");; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/gtm.js






                var setDataLayer = function(params) {
                    if (!ssr /* isClient */ .C) return;
                    var host = window.location.host;
                    if (host.includes("qa1fdg") || host.includes("devfdg") || host.includes("localhost")) console.info("datalayer", params);
                    window.dataLayer = window.dataLayer || [];
                    var gtmOptOut = cookies /* cookies.read */ .Q.read("data_opt_out") === "y";
                    if (gtmOptOut) {
                        return;
                    }
                    window.dataLayer.push(params);
                };
                var setLoginLogic = function() {
                    var _ref = (0, _async_to_generator /* default */ .Z)(external_regeneratorRuntime_default().mark(function _callee(pageViewLayerConfig, autoLogin) {
                        var getUserId, cancel, extraParams, matches, pageName, params, loginStatus, userId;
                        return external_regeneratorRuntime_default().wrap(function _callee$(_ctx) {
                            while (1) switch (_ctx.prev = _ctx.next) {
                                case 0:
                                    getUserId = pageViewLayerConfig.getUserId, cancel = pageViewLayerConfig.cancel, extraParams = pageViewLayerConfig.extraParams;
                                    if (!(!ssr /* isClient */ .C || cancel || !autoLogin)) {
                                        _ctx.next = 3;
                                        break;
                                    }
                                    return _ctx.abrupt("return");
                                case 3:
                                    matches = window.location.pathname.match(/\/[a-z]{2}(-[a-zA-Z]{2})?(\/.*)?/);
                                    pageName = matches ? matches[2] : "/";
                                    params = {
                                        pageName: pageName,
                                        bncUUID: cookies /* cookies.read */ .Q.read("bnc-uuid")
                                    };
                                    if (!window.location.origin.startsWith("https")) {
                                        _ctx.next = 23;
                                        break;
                                    }
                                    _ctx.next = 9;
                                    return (0, auth /* authCenterAuth */ .g4)();
                                case 9:
                                    loginStatus = _ctx.sent;
                                    if (!loginStatus) {
                                        _ctx.next = 23;
                                        break;
                                    }
                                    if (!getUserId) {
                                        _ctx.next = 17;
                                        break;
                                    }
                                    _ctx.next = 14;
                                    return getUserId();
                                case 14:
                                    _ctx.t0 = _ctx.sent;
                                    _ctx.next = 20;
                                    break;
                                case 17:
                                    _ctx.next = 19;
                                    return (0, user /* accountUserBaseDetail */ .U2)();
                                case 19:
                                    _ctx.t0 = _ctx.sent.userId;
                                case 20:
                                    userId = _ctx.t0;
                                    params.userId = userId;
                                    loginGroup(userId);
                                case 23:
                                    params = (0, _object_spread /* default */ .Z)({}, params, typeof extraParams === "object" ? extraParams : {});
                                    setDataLayer({
                                        event: "page loading",
                                        page_load_info: params
                                    });
                                case 25:
                                case "end":
                                    return _ctx.stop();
                            }
                        }, _callee);
                    }));
                    return function setLoginLogic(pageViewLayerConfig, autoLogin) {
                        return _ref.apply(this, arguments);
                    };
                }();

                // EXTERNAL MODULE: ./node_modules/.pnpm/qs@6.13.1/node_modules/qs/lib/index.js
                var lib = __webpack_require__("oeLA");
                var lib_default = /*#__PURE__*/ __webpack_require__.n(lib);; // CONCATENATED MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/initTrackFunc.js



                /* eslint-disable lines-around-comment */






                var otherAbleTrack = function(eventName, otherDisabledEvent) {
                    return !Array.isArray(otherDisabledEvent) || !otherDisabledEvent.find(function(eName) {
                        return eName === eventName;
                    });
                };
                var generatorCheckItemAbleTrack = function() {
                    var funcNameMapToDisabledKey = {
                        gaTrack: "gaDisabled",
                        bTrack: "bTrackDisabled",
                        sensorsTrack: "sensorsDisabled"
                    };
                    return function(funcName, options) {
                        return !options[funcNameMapToDisabledKey[funcName]];
                    };
                };
                // gaDisabled sensorsDisabled bTrackDisabled
                var generateHandlerPromise = function(eventName, otherInfo, handler) {
                    return new Promise(function(resolve) {
                        handler(eventName, (0, _object_spread /* default */ .Z)({}, otherInfo), function(success) {
                            return resolve({
                                type: handler.name,
                                success: typeof success === "boolean" ? success : true
                            });
                        });
                        setTimeout(function() {
                            resolve({
                                type: handler.name,
                                success: false
                            });
                        }, 5000);
                    });
                };
                var initTrackFunc = function(param) {
                    var sensorsConfig = param.sensorsConfig,
                        /**
                         * Enable / Disable Google Analytics
                         */
                        ableGA = param.ableGA,
                        _otherDisabledEvent = param.otherDisabledEvent,
                        otherDisabledEvent = _otherDisabledEvent === void 0 ? DEFAULT_OTHER_DISABLE_EVENTS : _otherDisabledEvent,
                        _pageViewLayerConfig = param.pageViewLayerConfig,
                        pageViewLayerConfig = _pageViewLayerConfig === void 0 ? {} : _pageViewLayerConfig,
                        _autoLogin = param.autoLogin,
                        autoLogin = _autoLogin === void 0 ? true : _autoLogin;
                    deprecatedWarning();
                    var otherTrack = [];
                    var sensors;
                    var ga;
                    var sensorsTrack = function(eventName, otherInfo, callback) {
                        if (otherInfo === null || otherInfo === void 0 ? void 0 : otherInfo.elementId) {
                            otherInfo.elementID = otherInfo.elementId;
                            delete otherInfo.elementId;
                        }
                        if (otherInfo === null || otherInfo === void 0 ? void 0 : otherInfo.extraInfo) otherInfo.extraInfo = JSON.stringify(otherInfo.extraInfo);
                        if (location.origin.includes("localhost")) {
                            if (eventName.startsWith("$")) throw new Error('event name must not start with "$"');
                            if (Number.isInteger(eventName[0])) throw new Error("event name cannot start with a number");
                            if (!/^[0-9a-zA-Z_\$]+$/.test(eventName)) throw new Error("event name can only contain numbers/letters/underscores/$");
                        }
                        sensors.track(eventName, otherInfo, callback);
                    };
                    try {
                        if (true) {
                            if (window.__PIKA_TRACK__) {
                                sensors = window.__PIKA_TRACK__.sensors;
                                otherTrack.push(sensorsTrack);
                            }
                        }
                    } catch (e) {}
                    if ((false || !window.__PIKA_TRACK__) && sensorsConfig) {
                        var staticHost = sensorsConfig.staticHost,
                            update = sensorsConfig.update,
                            old = sensorsConfig.old,
                            test = sensorsConfig.test,
                            publicParams = sensorsConfig.publicParams,
                            initParams = sensorsConfig.initParams,
                            reset = (0, _object_without_properties /* default */ .Z)(sensorsConfig, [
                                "staticHost",
                                "update",
                                "old",
                                "test",
                                "publicParams",
                                "initParams"
                            ]);
                        sensors = createSensor();
                        var params = (0, _object_spread /* default */ .Z)({
                            name: "SensorsSdk",
                            send_type: "beacon",
                            use_client_time: true,
                            datasend_timeout: 10000,
                            is_track_single_page: true,
                            app_js_bridge: {
                                white_list: // Remove duplicate
                                    (0, _to_consumable_array /* default */ .Z)(new Set([
                                        reset === null || reset === void 0 ? void 0 : reset.server_url,
                                        "https://sensors.binance.cloud/sa?project=binance",
                                        "https://api.saasexch.com/bapi/fe/usd/sa?project=binance",
                                        "https://api.saasexch.cc/bapi/fe/usd/sa?project=binance",
                                        "https://api.saasexch.co/bapi/fe/usd/sa?project=binance",
                                    ].filter(Boolean)))
                            },
                            show_log: false,
                            heatmap: {
                                collect_tags: {
                                    div: true
                                }
                            }
                        }, reset);
                        if (staticHost) {
                            if (old) {
                                Object.assign(params, {
                                    sdk_url: "".concat(staticHost, "/static/sensors/sensorsdata@1.15.26.js"),
                                    heatmap_url: "".concat(staticHost, "/static/sensors/heatmap@1.15.26.js"),
                                    vtrack_url: "".concat(staticHost, "/static/sensors/vtrack.min.js")
                                });
                            } else {
                                Object.assign(params, {
                                    sdk_url: "".concat(staticHost, "/static/sensors/sensorsdata@1.26.12.js"),
                                    heatmap_url: "".concat(staticHost, "/static/sensors/heatmap@1.26.12.js"),
                                    vtrack_url: "".concat(staticHost, "/static/sensors/vtrack@1.26.12.js")
                                });
                            }
                        }
                        try {
                            var ref, ref1;
                            var web_url;
                            var search = ((ref1 = reset === null || reset === void 0 ? void 0 : (ref = reset.server_url) === null || ref === void 0 ? void 0 : ref.split("?")) === null || ref1 === void 0 ? void 0 : ref1[1]) || "";
                            var project = lib_default().parse(search).project;
                            if (project) web_url = "https://ss.datasconsole.com?project=".concat(project);
                            if (web_url) params.web_url = web_url;
                        } catch (e) {}
                        if (initParams) {
                            Object.assign(params, initParams);
                        }
                        sensors.init(params);
                        registerPage(sensors, publicParams);
                        sensors.use("PageLeave", {
                            custom_props: {},
                            heartbeat_interval_time: 5
                        });
                        otherTrack.push(sensorsTrack);
                    }
                    // Pika track does not support GA, should not use __PIKA_TRACK__ to skip GA init
                    // If developers want to use GA, they need to init the @binance/track with ableGA = true
                    if (ableGA) {
                        var _ga;
                        ga = esm_ga();
                        var gaTrack = function() {
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            return (_ga = ga).track.apply(_ga, (0, _to_consumable_array /* default */ .Z)(args));
                        };
                        otherTrack.push(gaTrack);
                    }
                    if (otherTrack.length) {
                        var trackGroup = function(eventName, otherInfo, options) {
                            var promises = [];
                            var checkItemAbleTrack = generatorCheckItemAbleTrack();
                            if (otherAbleTrack(eventName, otherDisabledEvent)) {
                                otherTrack.forEach(function(func) {
                                    if (checkItemAbleTrack(func.name, options)) {
                                        promises.push(generateHandlerPromise(eventName, otherInfo, func));
                                    }
                                });
                            }
                            Promise.all(promises).then(options === null || options === void 0 ? void 0 : options.callback);
                            return promises[promises.length - 1];
                        };
                        trackGroup && (0, esm_trackGroup /* setTrackGroup */ .N)(trackGroup);
                        setLoginGroup(function(id) {
                            sensors && sensors.login(id);
                            ga && ga.login(id);
                        });
                    }
                    try {
                        if (true) {
                            if (window.__PIKA_TRACK__) {
                                return window.__PIKA_TRACK__;
                            }
                        }
                    } catch (e1) {}
                    setLoginLogic(pageViewLayerConfig, autoLogin);
                    try {
                        if (true) {
                            var _sensors = Object.create(sensors);
                            Object.defineProperty(_sensors, "quick", {
                                configurable: true,
                                value: function() {}
                            });
                            window.__PIKA_TRACK__ = {
                                sensors: _sensors,
                                ga: ga
                            };
                        }
                    } catch (e2) {}
                    return {
                        sensors: sensors,
                        ga: ga
                    };
                };
                var deprecatedWarning = function() {
                    var packName = "@binance/track",
                        time = "2023-12-31";
                    if (false) {}
                };
                /* harmony default export */
                const esm_initTrackFunc = (initTrackFunc);

                // EXTERNAL MODULE: ./node_modules/.pnpm/@binance+track@0.1.105_@types+react@18.0.28_react-dom@16.14.0_react@18.2.0/node_modules/@binance/track/dist/esm/index.js
                var esm = __webpack_require__("lAoq");
                // EXTERNAL MODULE: ./src/constants/index.ts + 1 modules
                var constants = __webpack_require__("CW2u");; // CONCATENATED MODULE: ./node_modules/.pnpm/@babt+utils@0.1.3/node_modules/@babt/utils/dist/report.js
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }

                function _objectSpread(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === "function") {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                var track = {
                    // @ts-ignore
                    report: function(types, params) {},
                    extraParams: {},
                    click: function click(eventName, params) {
                        this.report("df_mpclick", _objectSpread({
                            eventName: eventName
                        }, params, this.extraParams));
                    },
                    view: function view(eventName, params) {
                        this.report("df_mpviewscreen", _objectSpread({
                            eventName: eventName
                        }, params, this.extraParams));
                    }
                };
                var EVENT_IDS;
                (function(EVENT_IDS) {
                    EVENT_IDS[ // PV_NEW_COME = 'mp_viewscreen_page_home_newcome',
                        "PV_RESTRICTED"] = "mp_viewscreen_page_home_restricted";
                    EVENT_IDS["PV_MINTED"] = "mp_viewscreen_page_home_minted";
                    EVENT_IDS["PV_SOURCE"] = "mp_viewscreen_source";
                    EVENT_IDS["CLICK_LOGIN"] = "mp_click_babt_login";
                    EVENT_IDS["CLICK_LOGIN_SUCCESS"] = "mp_click_babt_login_success";
                    EVENT_IDS["CLICK_LOGIN_FAIL"] = "mp_click_babt_login_failure";
                    EVENT_IDS["CLICK_VERIFY"] = "mp_click_babt_verify";
                    EVENT_IDS["CLICK_VERIFY_SUCCESS"] = "mp_click_babt_verify_success";
                    EVENT_IDS["CLICK_VERIFY_FAIL"] = "mp_click_babt_verify_failure";
                    EVENT_IDS["CLICK_CONNECT_WALLET"] = "mp_click_babt_connect_to_wallet";
                    EVENT_IDS["CLICK_CONNECT_WALLET_SUCCESS"] = "mp_click_babt_connect_to_wallet_success";
                    EVENT_IDS["CLICK_CONNECT_MP_WALLET_SUCCESS"] = "mp_click_babt_connect_to_mp_wallet_success";
                    EVENT_IDS["CLICK_CONNECT_WALLET_FAIL"] = "mp_click_babt_connect_to_wallet_failure";
                    EVENT_IDS["CLICK_CONNECT_OTHER_WALLET_SUCCESS"] = "mp_click_babt_connect_to_other_wallets_success";
                    EVENT_IDS["CLICK_WALLET_SIGN"] = "mp_click_babt_wallet_signature";
                    EVENT_IDS["CLICK_WALLET_SIGN_SUCCESS"] = "mp_click_babt_wallet_signature_success";
                    EVENT_IDS["CLICK_WALLET_SIGN_FAIL"] = "mp_click_babt_wallet_signature_failure";
                    EVENT_IDS["CLICK_PAYMENT"] = "mp_click_babt_request_payment";
                    EVENT_IDS["CLICK_PAYMENY_SUCCESS"] = "mp_click_babt_request_payment_success";
                    EVENT_IDS["CLICK_PAYMENT_FAIL"] = "mp_click_babt_request_payment_failure";
                    EVENT_IDS["CLICK_ATTEST"] = "mp_click_babt_attest";
                    EVENT_IDS["CLICK_ATTEST_SUCCESS"] = "mp_click_babt_attest_success";
                    EVENT_IDS["CLICK_ATTEST_FAIL"] = "mp_click_babt_attest_failure";
                    EVENT_IDS["CLICK_REVOKE"] = "mp_click_babt_revoke";
                    EVENT_IDS["CLICK_REVOKE_SUCCESS"] = "mp_click_babt_revoke_success";
                    EVENT_IDS["CLICK_REVOKE_FAIL"] = "mp_click_babt_revoke_failure";
                })(EVENT_IDS || (EVENT_IDS = {}));

                ; // CONCATENATED MODULE: ./src/utils/initSensors.js





                var sensors = null;

                function initSensor() {
                    if (false) {}
                    var rs = esm_initTrackFunc({
                        sensorsConfig: {
                            staticHost: constants /* STATIC_HOST */ .Xs,
                            server_url: constants /* SENSORS_SERVER_HOST */ .yB,
                            is_track_single_page: function() {
                                return {
                                    canary: "gamma"
                                };
                            }
                        },
                        ableGA: false,
                        otherDisabledEvent: [
                            "pageView"
                        ]
                    });
                    sensors = rs.sensors;
                    sensors.quick("autoTrack") // 设置后，自动收集页面浏览事件，以及设置初始来源
                    ;
                    // internalTrack.report = track
                    // pageViewSend({ df_12: source })
                    track.extraParams = {
                        elementID: "buw-homepage",
                        pageName: "buw-homepage"
                    };
                    track.click = function(eventName, params) {
                        (0, esm /* default */ .ZP)("df_mpclick", (0, _object_spread_props /* default */ .Z)((0, _object_spread /* default */ .Z)({}, track.extraParams, params), {
                            elementID: eventName,
                            eventName: eventName
                        }));
                    };
                    track.view = function(eventName, params) {
                        (0, esm /* default */ .ZP)("df_mpviewscreen", (0, _object_spread /* default */ .Z)({
                            eventName: eventName
                        }, params, track.extraParams));
                    };
                }
                initSensor();

                function getSensors() {
                    return sensors;
                }
                var login = function(userId) {
                    if (sensors) {
                        sensors.login(userId);
                    }
                };



                /***/
            }),

        /***/
        "ykqw":
            /***/
            ((__unused_webpack_module, exports) => {

                "use strict";


                exports.byteLength = byteLength
                exports.toByteArray = toByteArray
                exports.fromByteArray = fromByteArray

                var lookup = []
                var revLookup = []
                var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

                var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
                for (var i = 0, len = code.length; i < len; ++i) {
                    lookup[i] = code[i]
                    revLookup[code.charCodeAt(i)] = i
                }

                // Support decoding URL-safe base64 strings, as Node.js does.
                // See: https://en.wikipedia.org/wiki/Base64#URL_applications
                revLookup['-'.charCodeAt(0)] = 62
                revLookup['_'.charCodeAt(0)] = 63

                function getLens(b64) {
                    var len = b64.length

                    if (len % 4 > 0) {
                        throw new Error('Invalid string. Length must be a multiple of 4')
                    }

                    // Trim off extra bytes after placeholder bytes are found
                    // See: https://github.com/beatgammit/base64-js/issues/42
                    var validLen = b64.indexOf('=')
                    if (validLen === -1) validLen = len

                    var placeHoldersLen = validLen === len ?
                        0 :
                        4 - (validLen % 4)

                    return [validLen, placeHoldersLen]
                }

                // base64 is 4/3 + up to two characters of the original data
                function byteLength(b64) {
                    var lens = getLens(b64)
                    var validLen = lens[0]
                    var placeHoldersLen = lens[1]
                    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
                }

                function _byteLength(b64, validLen, placeHoldersLen) {
                    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
                }

                function toByteArray(b64) {
                    var tmp
                    var lens = getLens(b64)
                    var validLen = lens[0]
                    var placeHoldersLen = lens[1]

                    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

                    var curByte = 0

                    // if there are placeholders, only get up to the last complete 4 chars
                    var len = placeHoldersLen > 0 ?
                        validLen - 4 :
                        validLen

                    var i
                    for (i = 0; i < len; i += 4) {
                        tmp =
                            (revLookup[b64.charCodeAt(i)] << 18) |
                            (revLookup[b64.charCodeAt(i + 1)] << 12) |
                            (revLookup[b64.charCodeAt(i + 2)] << 6) |
                            revLookup[b64.charCodeAt(i + 3)]
                        arr[curByte++] = (tmp >> 16) & 0xFF
                        arr[curByte++] = (tmp >> 8) & 0xFF
                        arr[curByte++] = tmp & 0xFF
                    }

                    if (placeHoldersLen === 2) {
                        tmp =
                            (revLookup[b64.charCodeAt(i)] << 2) |
                            (revLookup[b64.charCodeAt(i + 1)] >> 4)
                        arr[curByte++] = tmp & 0xFF
                    }

                    if (placeHoldersLen === 1) {
                        tmp =
                            (revLookup[b64.charCodeAt(i)] << 10) |
                            (revLookup[b64.charCodeAt(i + 1)] << 4) |
                            (revLookup[b64.charCodeAt(i + 2)] >> 2)
                        arr[curByte++] = (tmp >> 8) & 0xFF
                        arr[curByte++] = tmp & 0xFF
                    }

                    return arr
                }

                function tripletToBase64(num) {
                    return lookup[num >> 18 & 0x3F] +
                        lookup[num >> 12 & 0x3F] +
                        lookup[num >> 6 & 0x3F] +
                        lookup[num & 0x3F]
                }

                function encodeChunk(uint8, start, end) {
                    var tmp
                    var output = []
                    for (var i = start; i < end; i += 3) {
                        tmp =
                            ((uint8[i] << 16) & 0xFF0000) +
                            ((uint8[i + 1] << 8) & 0xFF00) +
                            (uint8[i + 2] & 0xFF)
                        output.push(tripletToBase64(tmp))
                    }
                    return output.join('')
                }

                function fromByteArray(uint8) {
                    var tmp
                    var len = uint8.length
                    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
                    var parts = []
                    var maxChunkLength = 16383 // must be multiple of 3

                    // go through the array every three bytes, we'll deal with trailing stuff later
                    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
                    }

                    // pad the end with zeros, but make sure to not forget the extra bytes
                    if (extraBytes === 1) {
                        tmp = uint8[len - 1]
                        parts.push(
                            lookup[tmp >> 2] +
                            lookup[(tmp << 4) & 0x3F] +
                            '=='
                        )
                    } else if (extraBytes === 2) {
                        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
                        parts.push(
                            lookup[tmp >> 10] +
                            lookup[(tmp >> 4) & 0x3F] +
                            lookup[(tmp << 2) & 0x3F] +
                            '='
                        )
                    }

                    return parts.join('')
                }


                /***/
            }),

        /***/
        "pMyr":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                "use strict";
                /*!
                 * The buffer module from node.js, for the browser.
                 *
                 * @author   Feross Aboukhadijeh <https://feross.org>
                 * @license  MIT
                 */
                /* eslint-disable no-proto */



                const base64 = __webpack_require__("ykqw")
                const ieee754 = __webpack_require__("/IPs")
                const customInspectSymbol =
                    (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
                    ?
                    Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
                    :
                    null

                exports.Buffer = Buffer
                exports.SlowBuffer = SlowBuffer
                exports.INSPECT_MAX_BYTES = 50

                const K_MAX_LENGTH = 0x7fffffff
                exports.kMaxLength = K_MAX_LENGTH

                /**
                 * If `Buffer.TYPED_ARRAY_SUPPORT`:
                 *   === true    Use Uint8Array implementation (fastest)
                 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
                 *               implementation (most compatible, even IE6)
                 *
                 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
                 * Opera 11.6+, iOS 4.2+.
                 *
                 * We report that the browser does not support typed arrays if the are not subclassable
                 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
                 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
                 * for __proto__ and has a buggy typed array implementation.
                 */
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

                if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
                    typeof console.error === 'function') {
                    console.error(
                        'This browser lacks typed array (Uint8Array) support which is required by ' +
                        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
                    )
                }

                function typedArraySupport() {
                    // Can typed array instances can be augmented?
                    try {
                        const arr = new Uint8Array(1)
                        const proto = {
                            foo: function() {
                                return 42
                            }
                        }
                        Object.setPrototypeOf(proto, Uint8Array.prototype)
                        Object.setPrototypeOf(arr, proto)
                        return arr.foo() === 42
                    } catch (e) {
                        return false
                    }
                }

                Object.defineProperty(Buffer.prototype, 'parent', {
                    enumerable: true,
                    get: function() {
                        if (!Buffer.isBuffer(this)) return undefined
                        return this.buffer
                    }
                })

                Object.defineProperty(Buffer.prototype, 'offset', {
                    enumerable: true,
                    get: function() {
                        if (!Buffer.isBuffer(this)) return undefined
                        return this.byteOffset
                    }
                })

                function createBuffer(length) {
                    if (length > K_MAX_LENGTH) {
                        throw new RangeError('The value "' + length + '" is invalid for option "size"')
                    }
                    // Return an augmented `Uint8Array` instance
                    const buf = new Uint8Array(length)
                    Object.setPrototypeOf(buf, Buffer.prototype)
                    return buf
                }

                /**
                 * The Buffer constructor returns instances of `Uint8Array` that have their
                 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                 * returns a single octet.
                 *
                 * The `Uint8Array` prototype remains unmodified.
                 */

                function Buffer(arg, encodingOrOffset, length) {
                    // Common case.
                    if (typeof arg === 'number') {
                        if (typeof encodingOrOffset === 'string') {
                            throw new TypeError(
                                'The "string" argument must be of type string. Received type number'
                            )
                        }
                        return allocUnsafe(arg)
                    }
                    return from(arg, encodingOrOffset, length)
                }

                Buffer.poolSize = 8192 // not used by this implementation

                function from(value, encodingOrOffset, length) {
                    if (typeof value === 'string') {
                        return fromString(value, encodingOrOffset)
                    }

                    if (ArrayBuffer.isView(value)) {
                        return fromArrayView(value)
                    }

                    if (value == null) {
                        throw new TypeError(
                            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                            'or Array-like Object. Received type ' + (typeof value)
                        )
                    }

                    if (isInstance(value, ArrayBuffer) ||
                        (value && isInstance(value.buffer, ArrayBuffer))) {
                        return fromArrayBuffer(value, encodingOrOffset, length)
                    }

                    if (typeof SharedArrayBuffer !== 'undefined' &&
                        (isInstance(value, SharedArrayBuffer) ||
                            (value && isInstance(value.buffer, SharedArrayBuffer)))) {
                        return fromArrayBuffer(value, encodingOrOffset, length)
                    }

                    if (typeof value === 'number') {
                        throw new TypeError(
                            'The "value" argument must not be of type number. Received type number'
                        )
                    }

                    const valueOf = value.valueOf && value.valueOf()
                    if (valueOf != null && valueOf !== value) {
                        return Buffer.from(valueOf, encodingOrOffset, length)
                    }

                    const b = fromObject(value)
                    if (b) return b

                    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
                        typeof value[Symbol.toPrimitive] === 'function') {
                        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
                    }

                    throw new TypeError(
                        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                        'or Array-like Object. Received type ' + (typeof value)
                    )
                }

                /**
                 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                 * if value is a number.
                 * Buffer.from(str[, encoding])
                 * Buffer.from(array)
                 * Buffer.from(buffer)
                 * Buffer.from(arrayBuffer[, byteOffset[, length]])
                 **/
                Buffer.from = function(value, encodingOrOffset, length) {
                    return from(value, encodingOrOffset, length)
                }

                // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
                // https://github.com/feross/buffer/pull/148
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
                Object.setPrototypeOf(Buffer, Uint8Array)

                function assertSize(size) {
                    if (typeof size !== 'number') {
                        throw new TypeError('"size" argument must be of type number')
                    } else if (size < 0) {
                        throw new RangeError('The value "' + size + '" is invalid for option "size"')
                    }
                }

                function alloc(size, fill, encoding) {
                    assertSize(size)
                    if (size <= 0) {
                        return createBuffer(size)
                    }
                    if (fill !== undefined) {
                        // Only pay attention to encoding if it's a string. This
                        // prevents accidentally sending in a number that would
                        // be interpreted as a start offset.
                        return typeof encoding === 'string' ?
                            createBuffer(size).fill(fill, encoding) :
                            createBuffer(size).fill(fill)
                    }
                    return createBuffer(size)
                }

                /**
                 * Creates a new filled Buffer instance.
                 * alloc(size[, fill[, encoding]])
                 **/
                Buffer.alloc = function(size, fill, encoding) {
                    return alloc(size, fill, encoding)
                }

                function allocUnsafe(size) {
                    assertSize(size)
                    return createBuffer(size < 0 ? 0 : checked(size) | 0)
                }

                /**
                 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                 * */
                Buffer.allocUnsafe = function(size) {
                    return allocUnsafe(size)
                }
                /**
                 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                 */
                Buffer.allocUnsafeSlow = function(size) {
                    return allocUnsafe(size)
                }

                function fromString(string, encoding) {
                    if (typeof encoding !== 'string' || encoding === '') {
                        encoding = 'utf8'
                    }

                    if (!Buffer.isEncoding(encoding)) {
                        throw new TypeError('Unknown encoding: ' + encoding)
                    }

                    const length = byteLength(string, encoding) | 0
                    let buf = createBuffer(length)

                    const actual = buf.write(string, encoding)

                    if (actual !== length) {
                        // Writing a hex string, for example, that contains invalid characters will
                        // cause everything after the first invalid character to be ignored. (e.g.
                        // 'abxxcd' will be treated as 'ab')
                        buf = buf.slice(0, actual)
                    }

                    return buf
                }

                function fromArrayLike(array) {
                    const length = array.length < 0 ? 0 : checked(array.length) | 0
                    const buf = createBuffer(length)
                    for (let i = 0; i < length; i += 1) {
                        buf[i] = array[i] & 255
                    }
                    return buf
                }

                function fromArrayView(arrayView) {
                    if (isInstance(arrayView, Uint8Array)) {
                        const copy = new Uint8Array(arrayView)
                        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
                    }
                    return fromArrayLike(arrayView)
                }

                function fromArrayBuffer(array, byteOffset, length) {
                    if (byteOffset < 0 || array.byteLength < byteOffset) {
                        throw new RangeError('"offset" is outside of buffer bounds')
                    }

                    if (array.byteLength < byteOffset + (length || 0)) {
                        throw new RangeError('"length" is outside of buffer bounds')
                    }

                    let buf
                    if (byteOffset === undefined && length === undefined) {
                        buf = new Uint8Array(array)
                    } else if (length === undefined) {
                        buf = new Uint8Array(array, byteOffset)
                    } else {
                        buf = new Uint8Array(array, byteOffset, length)
                    }

                    // Return an augmented `Uint8Array` instance
                    Object.setPrototypeOf(buf, Buffer.prototype)

                    return buf
                }

                function fromObject(obj) {
                    if (Buffer.isBuffer(obj)) {
                        const len = checked(obj.length) | 0
                        const buf = createBuffer(len)

                        if (buf.length === 0) {
                            return buf
                        }

                        obj.copy(buf, 0, 0, len)
                        return buf
                    }

                    if (obj.length !== undefined) {
                        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                            return createBuffer(0)
                        }
                        return fromArrayLike(obj)
                    }

                    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                        return fromArrayLike(obj.data)
                    }
                }

                function checked(length) {
                    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
                    // length is NaN (which is otherwise coerced to zero.)
                    if (length >= K_MAX_LENGTH) {
                        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
                    }
                    return length | 0
                }

                function SlowBuffer(length) {
                    if (+length != length) { // eslint-disable-line eqeqeq
                        length = 0
                    }
                    return Buffer.alloc(+length)
                }

                Buffer.isBuffer = function isBuffer(b) {
                    return b != null && b._isBuffer === true &&
                        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
                }

                Buffer.compare = function compare(a, b) {
                    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
                    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                        throw new TypeError(
                            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                        )
                    }

                    if (a === b) return 0

                    let x = a.length
                    let y = b.length

                    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
                        if (a[i] !== b[i]) {
                            x = a[i]
                            y = b[i]
                            break
                        }
                    }

                    if (x < y) return -1
                    if (y < x) return 1
                    return 0
                }

                Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                        case 'hex':
                        case 'utf8':
                        case 'utf-8':
                        case 'ascii':
                        case 'latin1':
                        case 'binary':
                        case 'base64':
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return true
                        default:
                            return false
                    }
                }

                Buffer.concat = function concat(list, length) {
                    if (!Array.isArray(list)) {
                        throw new TypeError('"list" argument must be an Array of Buffers')
                    }

                    if (list.length === 0) {
                        return Buffer.alloc(0)
                    }

                    let i
                    if (length === undefined) {
                        length = 0
                        for (i = 0; i < list.length; ++i) {
                            length += list[i].length
                        }
                    }

                    const buffer = Buffer.allocUnsafe(length)
                    let pos = 0
                    for (i = 0; i < list.length; ++i) {
                        let buf = list[i]
                        if (isInstance(buf, Uint8Array)) {
                            if (pos + buf.length > buffer.length) {
                                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
                                buf.copy(buffer, pos)
                            } else {
                                Uint8Array.prototype.set.call(
                                    buffer,
                                    buf,
                                    pos
                                )
                            }
                        } else if (!Buffer.isBuffer(buf)) {
                            throw new TypeError('"list" argument must be an Array of Buffers')
                        } else {
                            buf.copy(buffer, pos)
                        }
                        pos += buf.length
                    }
                    return buffer
                }

                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) {
                        return string.length
                    }
                    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                        return string.byteLength
                    }
                    if (typeof string !== 'string') {
                        throw new TypeError(
                            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                            'Received type ' + typeof string
                        )
                    }

                    const len = string.length
                    const mustMatch = (arguments.length > 2 && arguments[2] === true)
                    if (!mustMatch && len === 0) return 0

                    // Use a for loop to avoid recursion
                    let loweredCase = false
                    for (;;) {
                        switch (encoding) {
                            case 'ascii':
                            case 'latin1':
                            case 'binary':
                                return len
                            case 'utf8':
                            case 'utf-8':
                                return utf8ToBytes(string).length
                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return len * 2
                            case 'hex':
                                return len >>> 1
                            case 'base64':
                                return base64ToBytes(string).length
                            default:
                                if (loweredCase) {
                                    return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                                }
                                encoding = ('' + encoding).toLowerCase()
                                loweredCase = true
                        }
                    }
                }
                Buffer.byteLength = byteLength

                function slowToString(encoding, start, end) {
                    let loweredCase = false

                    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                    // property of a typed array.

                    // This behaves neither like String nor Uint8Array in that we set start/end
                    // to their upper/lower bounds if the value passed is out of range.
                    // undefined is handled specially as per ECMA-262 6th Edition,
                    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                    if (start === undefined || start < 0) {
                        start = 0
                    }
                    // Return early if start > this.length. Done here to prevent potential uint32
                    // coercion fail below.
                    if (start > this.length) {
                        return ''
                    }

                    if (end === undefined || end > this.length) {
                        end = this.length
                    }

                    if (end <= 0) {
                        return ''
                    }

                    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
                    end >>>= 0
                    start >>>= 0

                    if (end <= start) {
                        return ''
                    }

                    if (!encoding) encoding = 'utf8'

                    while (true) {
                        switch (encoding) {
                            case 'hex':
                                return hexSlice(this, start, end)

                            case 'utf8':
                            case 'utf-8':
                                return utf8Slice(this, start, end)

                            case 'ascii':
                                return asciiSlice(this, start, end)

                            case 'latin1':
                            case 'binary':
                                return latin1Slice(this, start, end)

                            case 'base64':
                                return base64Slice(this, start, end)

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return utf16leSlice(this, start, end)

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                                encoding = (encoding + '').toLowerCase()
                                loweredCase = true
                        }
                    }
                }

                // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
                // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
                // reliably in a browserify context because there could be multiple different
                // copies of the 'buffer' package in use. This method works even for Buffer
                // instances that were created from another copy of the `buffer` package.
                // See: https://github.com/feross/buffer/issues/154
                Buffer.prototype._isBuffer = true

                function swap(b, n, m) {
                    const i = b[n]
                    b[n] = b[m]
                    b[m] = i
                }

                Buffer.prototype.swap16 = function swap16() {
                    const len = this.length
                    if (len % 2 !== 0) {
                        throw new RangeError('Buffer size must be a multiple of 16-bits')
                    }
                    for (let i = 0; i < len; i += 2) {
                        swap(this, i, i + 1)
                    }
                    return this
                }

                Buffer.prototype.swap32 = function swap32() {
                    const len = this.length
                    if (len % 4 !== 0) {
                        throw new RangeError('Buffer size must be a multiple of 32-bits')
                    }
                    for (let i = 0; i < len; i += 4) {
                        swap(this, i, i + 3)
                        swap(this, i + 1, i + 2)
                    }
                    return this
                }

                Buffer.prototype.swap64 = function swap64() {
                    const len = this.length
                    if (len % 8 !== 0) {
                        throw new RangeError('Buffer size must be a multiple of 64-bits')
                    }
                    for (let i = 0; i < len; i += 8) {
                        swap(this, i, i + 7)
                        swap(this, i + 1, i + 6)
                        swap(this, i + 2, i + 5)
                        swap(this, i + 3, i + 4)
                    }
                    return this
                }

                Buffer.prototype.toString = function toString() {
                    const length = this.length
                    if (length === 0) return ''
                    if (arguments.length === 0) return utf8Slice(this, 0, length)
                    return slowToString.apply(this, arguments)
                }

                Buffer.prototype.toLocaleString = Buffer.prototype.toString

                Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                    if (this === b) return true
                    return Buffer.compare(this, b) === 0
                }

                Buffer.prototype.inspect = function inspect() {
                    let str = ''
                    const max = exports.INSPECT_MAX_BYTES
                    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
                    if (this.length > max) str += ' ... '
                    return '<Buffer ' + str + '>'
                }
                if (customInspectSymbol) {
                    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
                }

                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                    if (isInstance(target, Uint8Array)) {
                        target = Buffer.from(target, target.offset, target.byteLength)
                    }
                    if (!Buffer.isBuffer(target)) {
                        throw new TypeError(
                            'The "target" argument must be one of type Buffer or Uint8Array. ' +
                            'Received type ' + (typeof target)
                        )
                    }

                    if (start === undefined) {
                        start = 0
                    }
                    if (end === undefined) {
                        end = target ? target.length : 0
                    }
                    if (thisStart === undefined) {
                        thisStart = 0
                    }
                    if (thisEnd === undefined) {
                        thisEnd = this.length
                    }

                    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                        throw new RangeError('out of range index')
                    }

                    if (thisStart >= thisEnd && start >= end) {
                        return 0
                    }
                    if (thisStart >= thisEnd) {
                        return -1
                    }
                    if (start >= end) {
                        return 1
                    }

                    start >>>= 0
                    end >>>= 0
                    thisStart >>>= 0
                    thisEnd >>>= 0

                    if (this === target) return 0

                    let x = thisEnd - thisStart
                    let y = end - start
                    const len = Math.min(x, y)

                    const thisCopy = this.slice(thisStart, thisEnd)
                    const targetCopy = target.slice(start, end)

                    for (let i = 0; i < len; ++i) {
                        if (thisCopy[i] !== targetCopy[i]) {
                            x = thisCopy[i]
                            y = targetCopy[i]
                            break
                        }
                    }

                    if (x < y) return -1
                    if (y < x) return 1
                    return 0
                }

                // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
                // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
                //
                // Arguments:
                // - buffer - a Buffer to search
                // - val - a string, Buffer, or number
                // - byteOffset - an index into `buffer`; will be clamped to an int32
                // - encoding - an optional encoding, relevant is val is a string
                // - dir - true for indexOf, false for lastIndexOf
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    // Empty buffer means no match
                    if (buffer.length === 0) return -1

                    // Normalize byteOffset
                    if (typeof byteOffset === 'string') {
                        encoding = byteOffset
                        byteOffset = 0
                    } else if (byteOffset > 0x7fffffff) {
                        byteOffset = 0x7fffffff
                    } else if (byteOffset < -0x80000000) {
                        byteOffset = -0x80000000
                    }
                    byteOffset = +byteOffset // Coerce to Number.
                    if (numberIsNaN(byteOffset)) {
                        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                        byteOffset = dir ? 0 : (buffer.length - 1)
                    }

                    // Normalize byteOffset: negative offsets start from the end of the buffer
                    if (byteOffset < 0) byteOffset = buffer.length + byteOffset
                    if (byteOffset >= buffer.length) {
                        if (dir) return -1
                        else byteOffset = buffer.length - 1
                    } else if (byteOffset < 0) {
                        if (dir) byteOffset = 0
                        else return -1
                    }

                    // Normalize val
                    if (typeof val === 'string') {
                        val = Buffer.from(val, encoding)
                    }

                    // Finally, search either indexOf (if dir is true) or lastIndexOf
                    if (Buffer.isBuffer(val)) {
                        // Special case: looking for empty string/buffer always fails
                        if (val.length === 0) {
                            return -1
                        }
                        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                    } else if (typeof val === 'number') {
                        val = val & 0xFF // Search for a byte value [0-255]
                        if (typeof Uint8Array.prototype.indexOf === 'function') {
                            if (dir) {
                                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                            } else {
                                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                            }
                        }
                        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                    }

                    throw new TypeError('val must be string, number or Buffer')
                }

                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    let indexSize = 1
                    let arrLength = arr.length
                    let valLength = val.length

                    if (encoding !== undefined) {
                        encoding = String(encoding).toLowerCase()
                        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                            encoding === 'utf16le' || encoding === 'utf-16le') {
                            if (arr.length < 2 || val.length < 2) {
                                return -1
                            }
                            indexSize = 2
                            arrLength /= 2
                            valLength /= 2
                            byteOffset /= 2
                        }
                    }

                    function read(buf, i) {
                        if (indexSize === 1) {
                            return buf[i]
                        } else {
                            return buf.readUInt16BE(i * indexSize)
                        }
                    }

                    let i
                    if (dir) {
                        let foundIndex = -1
                        for (i = byteOffset; i < arrLength; i++) {
                            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                if (foundIndex === -1) foundIndex = i
                                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                            } else {
                                if (foundIndex !== -1) i -= i - foundIndex
                                foundIndex = -1
                            }
                        }
                    } else {
                        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
                        for (i = byteOffset; i >= 0; i--) {
                            let found = true
                            for (let j = 0; j < valLength; j++) {
                                if (read(arr, i + j) !== read(val, j)) {
                                    found = false
                                    break
                                }
                            }
                            if (found) return i
                        }
                    }

                    return -1
                }

                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                    return this.indexOf(val, byteOffset, encoding) !== -1
                }

                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
                }

                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
                }

                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0
                    const remaining = buf.length - offset
                    if (!length) {
                        length = remaining
                    } else {
                        length = Number(length)
                        if (length > remaining) {
                            length = remaining
                        }
                    }

                    const strLen = string.length

                    if (length > strLen / 2) {
                        length = strLen / 2
                    }
                    let i
                    for (i = 0; i < length; ++i) {
                        const parsed = parseInt(string.substr(i * 2, 2), 16)
                        if (numberIsNaN(parsed)) return i
                        buf[offset + i] = parsed
                    }
                    return i
                }

                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
                }

                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length)
                }

                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length)
                }

                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
                }

                Buffer.prototype.write = function write(string, offset, length, encoding) {
                    // Buffer#write(string)
                    if (offset === undefined) {
                        encoding = 'utf8'
                        length = this.length
                        offset = 0
                        // Buffer#write(string, encoding)
                    } else if (length === undefined && typeof offset === 'string') {
                        encoding = offset
                        length = this.length
                        offset = 0
                        // Buffer#write(string, offset[, length][, encoding])
                    } else if (isFinite(offset)) {
                        offset = offset >>> 0
                        if (isFinite(length)) {
                            length = length >>> 0
                            if (encoding === undefined) encoding = 'utf8'
                        } else {
                            encoding = length
                            length = undefined
                        }
                    } else {
                        throw new Error(
                            'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                        )
                    }

                    const remaining = this.length - offset
                    if (length === undefined || length > remaining) length = remaining

                    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                        throw new RangeError('Attempt to write outside buffer bounds')
                    }

                    if (!encoding) encoding = 'utf8'

                    let loweredCase = false
                    for (;;) {
                        switch (encoding) {
                            case 'hex':
                                return hexWrite(this, string, offset, length)

                            case 'utf8':
                            case 'utf-8':
                                return utf8Write(this, string, offset, length)

                            case 'ascii':
                            case 'latin1':
                            case 'binary':
                                return asciiWrite(this, string, offset, length)

                            case 'base64':
                                // Warning: maxLength not taken into account in base64Write
                                return base64Write(this, string, offset, length)

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return ucs2Write(this, string, offset, length)

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                                encoding = ('' + encoding).toLowerCase()
                                loweredCase = true
                        }
                    }
                }

                Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: 'Buffer',
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                }

                function base64Slice(buf, start, end) {
                    if (start === 0 && end === buf.length) {
                        return base64.fromByteArray(buf)
                    } else {
                        return base64.fromByteArray(buf.slice(start, end))
                    }
                }

                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end)
                    const res = []

                    let i = start
                    while (i < end) {
                        const firstByte = buf[i]
                        let codePoint = null
                        let bytesPerSequence = (firstByte > 0xEF) ?
                            4 :
                            (firstByte > 0xDF) ?
                            3 :
                            (firstByte > 0xBF) ?
                            2 :
                            1

                        if (i + bytesPerSequence <= end) {
                            let secondByte, thirdByte, fourthByte, tempCodePoint

                            switch (bytesPerSequence) {
                                case 1:
                                    if (firstByte < 0x80) {
                                        codePoint = firstByte
                                    }
                                    break
                                case 2:
                                    secondByte = buf[i + 1]
                                    if ((secondByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                        if (tempCodePoint > 0x7F) {
                                            codePoint = tempCodePoint
                                        }
                                    }
                                    break
                                case 3:
                                    secondByte = buf[i + 1]
                                    thirdByte = buf[i + 2]
                                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                            codePoint = tempCodePoint
                                        }
                                    }
                                    break
                                case 4:
                                    secondByte = buf[i + 1]
                                    thirdByte = buf[i + 2]
                                    fourthByte = buf[i + 3]
                                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                            codePoint = tempCodePoint
                                        }
                                    }
                            }
                        }

                        if (codePoint === null) {
                            // we did not generate a valid codePoint so insert a
                            // replacement char (U+FFFD) and advance only 1 byte
                            codePoint = 0xFFFD
                            bytesPerSequence = 1
                        } else if (codePoint > 0xFFFF) {
                            // encode to utf16 (surrogate pair dance)
                            codePoint -= 0x10000
                            res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                            codePoint = 0xDC00 | codePoint & 0x3FF
                        }

                        res.push(codePoint)
                        i += bytesPerSequence
                    }

                    return decodeCodePointsArray(res)
                }

                // Based on http://stackoverflow.com/a/22747272/680742, the browser with
                // the lowest limit is Chrome, with 0x10000 args.
                // We go 1 magnitude less, for safety
                const MAX_ARGUMENTS_LENGTH = 0x1000

                function decodeCodePointsArray(codePoints) {
                    const len = codePoints.length
                    if (len <= MAX_ARGUMENTS_LENGTH) {
                        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                    }

                    // Decode in chunks to avoid "call stack size exceeded".
                    let res = ''
                    let i = 0
                    while (i < len) {
                        res += String.fromCharCode.apply(
                            String,
                            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                        )
                    }
                    return res
                }

                function asciiSlice(buf, start, end) {
                    let ret = ''
                    end = Math.min(buf.length, end)

                    for (let i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i] & 0x7F)
                    }
                    return ret
                }

                function latin1Slice(buf, start, end) {
                    let ret = ''
                    end = Math.min(buf.length, end)

                    for (let i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i])
                    }
                    return ret
                }

                function hexSlice(buf, start, end) {
                    const len = buf.length

                    if (!start || start < 0) start = 0
                    if (!end || end < 0 || end > len) end = len

                    let out = ''
                    for (let i = start; i < end; ++i) {
                        out += hexSliceLookupTable[buf[i]]
                    }
                    return out
                }

                function utf16leSlice(buf, start, end) {
                    const bytes = buf.slice(start, end)
                    let res = ''
                    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
                    for (let i = 0; i < bytes.length - 1; i += 2) {
                        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
                    }
                    return res
                }

                Buffer.prototype.slice = function slice(start, end) {
                    const len = this.length
                    start = ~~start
                    end = end === undefined ? len : ~~end

                    if (start < 0) {
                        start += len
                        if (start < 0) start = 0
                    } else if (start > len) {
                        start = len
                    }

                    if (end < 0) {
                        end += len
                        if (end < 0) end = 0
                    } else if (end > len) {
                        end = len
                    }

                    if (end < start) end = start

                    const newBuf = this.subarray(start, end)
                    // Return an augmented `Uint8Array` instance
                    Object.setPrototypeOf(newBuf, Buffer.prototype)

                    return newBuf
                }

                /*
                 * Need to make sure that buffer isn't trying to write out of bounds.
                 */
                function checkOffset(offset, ext, length) {
                    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
                }

                Buffer.prototype.readUintLE =
                    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                        offset = offset >>> 0
                        byteLength = byteLength >>> 0
                        if (!noAssert) checkOffset(offset, byteLength, this.length)

                        let val = this[offset]
                        let mul = 1
                        let i = 0
                        while (++i < byteLength && (mul *= 0x100)) {
                            val += this[offset + i] * mul
                        }

                        return val
                    }

                Buffer.prototype.readUintBE =
                    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                        offset = offset >>> 0
                        byteLength = byteLength >>> 0
                        if (!noAssert) {
                            checkOffset(offset, byteLength, this.length)
                        }

                        let val = this[offset + --byteLength]
                        let mul = 1
                        while (byteLength > 0 && (mul *= 0x100)) {
                            val += this[offset + --byteLength] * mul
                        }

                        return val
                    }

                Buffer.prototype.readUint8 =
                    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                        offset = offset >>> 0
                        if (!noAssert) checkOffset(offset, 1, this.length)
                        return this[offset]
                    }

                Buffer.prototype.readUint16LE =
                    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                        offset = offset >>> 0
                        if (!noAssert) checkOffset(offset, 2, this.length)
                        return this[offset] | (this[offset + 1] << 8)
                    }

                Buffer.prototype.readUint16BE =
                    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                        offset = offset >>> 0
                        if (!noAssert) checkOffset(offset, 2, this.length)
                        return (this[offset] << 8) | this[offset + 1]
                    }

                Buffer.prototype.readUint32LE =
                    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                        offset = offset >>> 0
                        if (!noAssert) checkOffset(offset, 4, this.length)

                        return ((this[offset]) |
                                (this[offset + 1] << 8) |
                                (this[offset + 2] << 16)) +
                            (this[offset + 3] * 0x1000000)
                    }

                Buffer.prototype.readUint32BE =
                    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                        offset = offset >>> 0
                        if (!noAssert) checkOffset(offset, 4, this.length)

                        return (this[offset] * 0x1000000) +
                            ((this[offset + 1] << 16) |
                                (this[offset + 2] << 8) |
                                this[offset + 3])
                    }

                Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
                    offset = offset >>> 0
                    validateNumber(offset, 'offset')
                    const first = this[offset]
                    const last = this[offset + 7]
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8)
                    }

                    const lo = first +
                        this[++offset] * 2 ** 8 +
                        this[++offset] * 2 ** 16 +
                        this[++offset] * 2 ** 24

                    const hi = this[++offset] +
                        this[++offset] * 2 ** 8 +
                        this[++offset] * 2 ** 16 +
                        last * 2 ** 24

                    return BigInt(lo) + (BigInt(hi) << BigInt(32))
                })

                Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
                    offset = offset >>> 0
                    validateNumber(offset, 'offset')
                    const first = this[offset]
                    const last = this[offset + 7]
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8)
                    }

                    const hi = first * 2 ** 24 +
                        this[++offset] * 2 ** 16 +
                        this[++offset] * 2 ** 8 +
                        this[++offset]

                    const lo = this[++offset] * 2 ** 24 +
                        this[++offset] * 2 ** 16 +
                        this[++offset] * 2 ** 8 +
                        last

                    return (BigInt(hi) << BigInt(32)) + BigInt(lo)
                })

                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset = offset >>> 0
                    byteLength = byteLength >>> 0
                    if (!noAssert) checkOffset(offset, byteLength, this.length)

                    let val = this[offset]
                    let mul = 1
                    let i = 0
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul
                    }
                    mul *= 0x80

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                    return val
                }

                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset = offset >>> 0
                    byteLength = byteLength >>> 0
                    if (!noAssert) checkOffset(offset, byteLength, this.length)

                    let i = byteLength
                    let mul = 1
                    let val = this[offset + --i]
                    while (i > 0 && (mul *= 0x100)) {
                        val += this[offset + --i] * mul
                    }
                    mul *= 0x80

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                    return val
                }

                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 1, this.length)
                    if (!(this[offset] & 0x80)) return (this[offset])
                    return ((0xff - this[offset] + 1) * -1)
                }

                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 2, this.length)
                    const val = this[offset] | (this[offset + 1] << 8)
                    return (val & 0x8000) ? val | 0xFFFF0000 : val
                }

                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 2, this.length)
                    const val = this[offset + 1] | (this[offset] << 8)
                    return (val & 0x8000) ? val | 0xFFFF0000 : val
                }

                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 4, this.length)

                    return (this[offset]) |
                        (this[offset + 1] << 8) |
                        (this[offset + 2] << 16) |
                        (this[offset + 3] << 24)
                }

                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 4, this.length)

                    return (this[offset] << 24) |
                        (this[offset + 1] << 16) |
                        (this[offset + 2] << 8) |
                        (this[offset + 3])
                }

                Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
                    offset = offset >>> 0
                    validateNumber(offset, 'offset')
                    const first = this[offset]
                    const last = this[offset + 7]
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8)
                    }

                    const val = this[offset + 4] +
                        this[offset + 5] * 2 ** 8 +
                        this[offset + 6] * 2 ** 16 +
                        (last << 24) // Overflow

                    return (BigInt(val) << BigInt(32)) +
                        BigInt(first +
                            this[++offset] * 2 ** 8 +
                            this[++offset] * 2 ** 16 +
                            this[++offset] * 2 ** 24)
                })

                Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
                    offset = offset >>> 0
                    validateNumber(offset, 'offset')
                    const first = this[offset]
                    const last = this[offset + 7]
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8)
                    }

                    const val = (first << 24) + // Overflow
                        this[++offset] * 2 ** 16 +
                        this[++offset] * 2 ** 8 +
                        this[++offset]

                    return (BigInt(val) << BigInt(32)) +
                        BigInt(this[++offset] * 2 ** 24 +
                            this[++offset] * 2 ** 16 +
                            this[++offset] * 2 ** 8 +
                            last)
                })

                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 4, this.length)
                    return ieee754.read(this, offset, true, 23, 4)
                }

                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 4, this.length)
                    return ieee754.read(this, offset, false, 23, 4)
                }

                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 8, this.length)
                    return ieee754.read(this, offset, true, 52, 8)
                }

                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    offset = offset >>> 0
                    if (!noAssert) checkOffset(offset, 8, this.length)
                    return ieee754.read(this, offset, false, 52, 8)
                }

                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                    if (offset + ext > buf.length) throw new RangeError('Index out of range')
                }

                Buffer.prototype.writeUintLE =
                    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        byteLength = byteLength >>> 0
                        if (!noAssert) {
                            const maxBytes = Math.pow(2, 8 * byteLength) - 1
                            checkInt(this, value, offset, byteLength, maxBytes, 0)
                        }

                        let mul = 1
                        let i = 0
                        this[offset] = value & 0xFF
                        while (++i < byteLength && (mul *= 0x100)) {
                            this[offset + i] = (value / mul) & 0xFF
                        }

                        return offset + byteLength
                    }

                Buffer.prototype.writeUintBE =
                    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        byteLength = byteLength >>> 0
                        if (!noAssert) {
                            const maxBytes = Math.pow(2, 8 * byteLength) - 1
                            checkInt(this, value, offset, byteLength, maxBytes, 0)
                        }

                        let i = byteLength - 1
                        let mul = 1
                        this[offset + i] = value & 0xFF
                        while (--i >= 0 && (mul *= 0x100)) {
                            this[offset + i] = (value / mul) & 0xFF
                        }

                        return offset + byteLength
                    }

                Buffer.prototype.writeUint8 =
                    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                        this[offset] = (value & 0xff)
                        return offset + 1
                    }

                Buffer.prototype.writeUint16LE =
                    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                        this[offset] = (value & 0xff)
                        this[offset + 1] = (value >>> 8)
                        return offset + 2
                    }

                Buffer.prototype.writeUint16BE =
                    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                        this[offset] = (value >>> 8)
                        this[offset + 1] = (value & 0xff)
                        return offset + 2
                    }

                Buffer.prototype.writeUint32LE =
                    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                        this[offset + 3] = (value >>> 24)
                        this[offset + 2] = (value >>> 16)
                        this[offset + 1] = (value >>> 8)
                        this[offset] = (value & 0xff)
                        return offset + 4
                    }

                Buffer.prototype.writeUint32BE =
                    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                        value = +value
                        offset = offset >>> 0
                        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                        this[offset] = (value >>> 24)
                        this[offset + 1] = (value >>> 16)
                        this[offset + 2] = (value >>> 8)
                        this[offset + 3] = (value & 0xff)
                        return offset + 4
                    }

                function wrtBigUInt64LE(buf, value, offset, min, max) {
                    checkIntBI(value, min, max, buf, offset, 7)

                    let lo = Number(value & BigInt(0xffffffff))
                    buf[offset++] = lo
                    lo = lo >> 8
                    buf[offset++] = lo
                    lo = lo >> 8
                    buf[offset++] = lo
                    lo = lo >> 8
                    buf[offset++] = lo
                    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
                    buf[offset++] = hi
                    hi = hi >> 8
                    buf[offset++] = hi
                    hi = hi >> 8
                    buf[offset++] = hi
                    hi = hi >> 8
                    buf[offset++] = hi
                    return offset
                }

                function wrtBigUInt64BE(buf, value, offset, min, max) {
                    checkIntBI(value, min, max, buf, offset, 7)

                    let lo = Number(value & BigInt(0xffffffff))
                    buf[offset + 7] = lo
                    lo = lo >> 8
                    buf[offset + 6] = lo
                    lo = lo >> 8
                    buf[offset + 5] = lo
                    lo = lo >> 8
                    buf[offset + 4] = lo
                    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
                    buf[offset + 3] = hi
                    hi = hi >> 8
                    buf[offset + 2] = hi
                    hi = hi >> 8
                    buf[offset + 1] = hi
                    hi = hi >> 8
                    buf[offset] = hi
                    return offset + 8
                }

                Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
                    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
                })

                Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
                    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
                })

                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) {
                        const limit = Math.pow(2, (8 * byteLength) - 1)

                        checkInt(this, value, offset, byteLength, limit - 1, -limit)
                    }

                    let i = 0
                    let mul = 1
                    let sub = 0
                    this[offset] = value & 0xFF
                    while (++i < byteLength && (mul *= 0x100)) {
                        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                            sub = 1
                        }
                        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                    }

                    return offset + byteLength
                }

                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) {
                        const limit = Math.pow(2, (8 * byteLength) - 1)

                        checkInt(this, value, offset, byteLength, limit - 1, -limit)
                    }

                    let i = byteLength - 1
                    let mul = 1
                    let sub = 0
                    this[offset + i] = value & 0xFF
                    while (--i >= 0 && (mul *= 0x100)) {
                        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                            sub = 1
                        }
                        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                    }

                    return offset + byteLength
                }

                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                    if (value < 0) value = 0xff + value + 1
                    this[offset] = (value & 0xff)
                    return offset + 1
                }

                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                    return offset + 2
                }

                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                    return offset + 2
                }

                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 3] = (value >>> 24)
                    return offset + 4
                }

                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                    if (value < 0) value = 0xffffffff + value + 1
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                    return offset + 4
                }

                Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
                    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
                })

                Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
                    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
                })

                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (offset + ext > buf.length) throw new RangeError('Index out of range')
                    if (offset < 0) throw new RangeError('Index out of range')
                }

                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                    }
                    ieee754.write(buf, value, offset, littleEndian, 23, 4)
                    return offset + 4
                }

                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert)
                }

                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert)
                }

                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    value = +value
                    offset = offset >>> 0
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                    }
                    ieee754.write(buf, value, offset, littleEndian, 52, 8)
                    return offset + 8
                }

                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert)
                }

                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert)
                }

                // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
                    if (!start) start = 0
                    if (!end && end !== 0) end = this.length
                    if (targetStart >= target.length) targetStart = target.length
                    if (!targetStart) targetStart = 0
                    if (end > 0 && end < start) end = start

                    // Copy 0 bytes; we're done
                    if (end === start) return 0
                    if (target.length === 0 || this.length === 0) return 0

                    // Fatal error conditions
                    if (targetStart < 0) {
                        throw new RangeError('targetStart out of bounds')
                    }
                    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
                    if (end < 0) throw new RangeError('sourceEnd out of bounds')

                    // Are we oob?
                    if (end > this.length) end = this.length
                    if (target.length - targetStart < end - start) {
                        end = target.length - targetStart + start
                    }

                    const len = end - start

                    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
                        // Use built-in when available, missing from IE11
                        this.copyWithin(targetStart, start, end)
                    } else {
                        Uint8Array.prototype.set.call(
                            target,
                            this.subarray(start, end),
                            targetStart
                        )
                    }

                    return len
                }

                // Usage:
                //    buffer.fill(number[, offset[, end]])
                //    buffer.fill(buffer[, offset[, end]])
                //    buffer.fill(string[, offset[, end]][, encoding])
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                    // Handle string cases:
                    if (typeof val === 'string') {
                        if (typeof start === 'string') {
                            encoding = start
                            start = 0
                            end = this.length
                        } else if (typeof end === 'string') {
                            encoding = end
                            end = this.length
                        }
                        if (encoding !== undefined && typeof encoding !== 'string') {
                            throw new TypeError('encoding must be a string')
                        }
                        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                            throw new TypeError('Unknown encoding: ' + encoding)
                        }
                        if (val.length === 1) {
                            const code = val.charCodeAt(0)
                            if ((encoding === 'utf8' && code < 128) ||
                                encoding === 'latin1') {
                                // Fast path: If `val` fits into a single byte, use that numeric value.
                                val = code
                            }
                        }
                    } else if (typeof val === 'number') {
                        val = val & 255
                    } else if (typeof val === 'boolean') {
                        val = Number(val)
                    }

                    // Invalid ranges are not set to a default, so can range check early.
                    if (start < 0 || this.length < start || this.length < end) {
                        throw new RangeError('Out of range index')
                    }

                    if (end <= start) {
                        return this
                    }

                    start = start >>> 0
                    end = end === undefined ? this.length : end >>> 0

                    if (!val) val = 0

                    let i
                    if (typeof val === 'number') {
                        for (i = start; i < end; ++i) {
                            this[i] = val
                        }
                    } else {
                        const bytes = Buffer.isBuffer(val) ?
                            val :
                            Buffer.from(val, encoding)
                        const len = bytes.length
                        if (len === 0) {
                            throw new TypeError('The value "' + val +
                                '" is invalid for argument "value"')
                        }
                        for (i = 0; i < end - start; ++i) {
                            this[i + start] = bytes[i % len]
                        }
                    }

                    return this
                }

                // CUSTOM ERRORS
                // =============

                // Simplified versions from Node, changed for Buffer-only usage
                const errors = {}

                function E(sym, getMessage, Base) {
                    errors[sym] = class NodeError extends Base {
                        constructor() {
                            super()

                            Object.defineProperty(this, 'message', {
                                value: getMessage.apply(this, arguments),
                                writable: true,
                                configurable: true
                            })

                            // Add the error code to the name to include it in the stack trace.
                            this.name = `${this.name} [${sym}]`
                            // Access the stack to generate the error message including the error code
                            // from the name.
                            this.stack // eslint-disable-line no-unused-expressions
                            // Reset the name to the actual name.
                            delete this.name
                        }

                        get code() {
                            return sym
                        }

                        set code(value) {
                            Object.defineProperty(this, 'code', {
                                configurable: true,
                                enumerable: true,
                                value,
                                writable: true
                            })
                        }

                        toString() {
                            return `${this.name} [${sym}]: ${this.message}`
                        }
                    }
                }

                E('ERR_BUFFER_OUT_OF_BOUNDS',
                    function(name) {
                        if (name) {
                            return `${name} is outside of buffer bounds`
                        }

                        return 'Attempt to access memory outside buffer bounds'
                    }, RangeError)
                E('ERR_INVALID_ARG_TYPE',
                    function(name, actual) {
                        return `The "${name}" argument must be of type number. Received type ${typeof actual}`
                    }, TypeError)
                E('ERR_OUT_OF_RANGE',
                    function(str, range, input) {
                        let msg = `The value of "${str}" is out of range.`
                        let received = input
                        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                            received = addNumericalSeparator(String(input))
                        } else if (typeof input === 'bigint') {
                            received = String(input)
                            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                                received = addNumericalSeparator(received)
                            }
                            received += 'n'
                        }
                        msg += ` It must be ${range}. Received ${received}`
                        return msg
                    }, RangeError)

                function addNumericalSeparator(val) {
                    let res = ''
                    let i = val.length
                    const start = val[0] === '-' ? 1 : 0
                    for (; i >= start + 4; i -= 3) {
                        res = `_${val.slice(i - 3, i)}${res}`
                    }
                    return `${val.slice(0, i)}${res}`
                }

                // CHECK FUNCTIONS
                // ===============

                function checkBounds(buf, offset, byteLength) {
                    validateNumber(offset, 'offset')
                    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
                        boundsError(offset, buf.length - (byteLength + 1))
                    }
                }

                function checkIntBI(value, min, max, buf, offset, byteLength) {
                    if (value > max || value < min) {
                        const n = typeof min === 'bigint' ? 'n' : ''
                        let range
                        if (byteLength > 3) {
                            if (min === 0 || min === BigInt(0)) {
                                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
                            } else {
                                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                                    `${(byteLength + 1) * 8 - 1}${n}`
                            }
                        } else {
                            range = `>= ${min}${n} and <= ${max}${n}`
                        }
                        throw new errors.ERR_OUT_OF_RANGE('value', range, value)
                    }
                    checkBounds(buf, offset, byteLength)
                }

                function validateNumber(value, name) {
                    if (typeof value !== 'number') {
                        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
                    }
                }

                function boundsError(value, length, type) {
                    if (Math.floor(value) !== value) {
                        validateNumber(value, type)
                        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
                    }

                    if (length < 0) {
                        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
                    }

                    throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                        `>= ${type ? 1 : 0} and <= ${length}`,
                        value)
                }

                // HELPER FUNCTIONS
                // ================

                const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

                function base64clean(str) {
                    // Node takes equal signs as end of the Base64 encoding
                    str = str.split('=')[0]
                    // Node strips out invalid characters like \n and \t from the string, base64-js does not
                    str = str.trim().replace(INVALID_BASE64_RE, '')
                    // Node converts strings with length < 2 to ''
                    if (str.length < 2) return ''
                    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                    while (str.length % 4 !== 0) {
                        str = str + '='
                    }
                    return str
                }

                function utf8ToBytes(string, units) {
                    units = units || Infinity
                    let codePoint
                    const length = string.length
                    let leadSurrogate = null
                    const bytes = []

                    for (let i = 0; i < length; ++i) {
                        codePoint = string.charCodeAt(i)

                        // is surrogate component
                        if (codePoint > 0xD7FF && codePoint < 0xE000) {
                            // last char was a lead
                            if (!leadSurrogate) {
                                // no lead yet
                                if (codePoint > 0xDBFF) {
                                    // unexpected trail
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                    continue
                                } else if (i + 1 === length) {
                                    // unpaired lead
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                    continue
                                }

                                // valid lead
                                leadSurrogate = codePoint

                                continue
                            }

                            // 2 leads in a row
                            if (codePoint < 0xDC00) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                leadSurrogate = codePoint
                                continue
                            }

                            // valid surrogate pair
                            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                        } else if (leadSurrogate) {
                            // valid bmp char, but last char was a lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        }

                        leadSurrogate = null

                        // encode utf8
                        if (codePoint < 0x80) {
                            if ((units -= 1) < 0) break
                            bytes.push(codePoint)
                        } else if (codePoint < 0x800) {
                            if ((units -= 2) < 0) break
                            bytes.push(
                                codePoint >> 0x6 | 0xC0,
                                codePoint & 0x3F | 0x80
                            )
                        } else if (codePoint < 0x10000) {
                            if ((units -= 3) < 0) break
                            bytes.push(
                                codePoint >> 0xC | 0xE0,
                                codePoint >> 0x6 & 0x3F | 0x80,
                                codePoint & 0x3F | 0x80
                            )
                        } else if (codePoint < 0x110000) {
                            if ((units -= 4) < 0) break
                            bytes.push(
                                codePoint >> 0x12 | 0xF0,
                                codePoint >> 0xC & 0x3F | 0x80,
                                codePoint >> 0x6 & 0x3F | 0x80,
                                codePoint & 0x3F | 0x80
                            )
                        } else {
                            throw new Error('Invalid code point')
                        }
                    }

                    return bytes
                }

                function asciiToBytes(str) {
                    const byteArray = []
                    for (let i = 0; i < str.length; ++i) {
                        // Node's code seems to be doing this and not & 0x7F..
                        byteArray.push(str.charCodeAt(i) & 0xFF)
                    }
                    return byteArray
                }

                function utf16leToBytes(str, units) {
                    let c, hi, lo
                    const byteArray = []
                    for (let i = 0; i < str.length; ++i) {
                        if ((units -= 2) < 0) break

                        c = str.charCodeAt(i)
                        hi = c >> 8
                        lo = c % 256
                        byteArray.push(lo)
                        byteArray.push(hi)
                    }

                    return byteArray
                }

                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str))
                }

                function blitBuffer(src, dst, offset, length) {
                    let i
                    for (i = 0; i < length; ++i) {
                        if ((i + offset >= dst.length) || (i >= src.length)) break
                        dst[i + offset] = src[i]
                    }
                    return i
                }

                // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
                // the `instanceof` check but they should be treated as of that type.
                // See: https://github.com/feross/buffer/issues/166
                function isInstance(obj, type) {
                    return obj instanceof type ||
                        (obj != null && obj.constructor != null && obj.constructor.name != null &&
                            obj.constructor.name === type.name)
                }

                function numberIsNaN(obj) {
                    // For IE11 support
                    return obj !== obj // eslint-disable-line no-self-compare
                }

                // Create lookup table for `toString('hex')`
                // See: https://github.com/feross/buffer/issues/219
                const hexSliceLookupTable = (function() {
                    const alphabet = '0123456789abcdef'
                    const table = new Array(256)
                    for (let i = 0; i < 16; ++i) {
                        const i16 = i * 16
                        for (let j = 0; j < 16; ++j) {
                            table[i16 + j] = alphabet[i] + alphabet[j]
                        }
                    }
                    return table
                })()

                // Return not function with Error if BigInt not supported
                function defineBigIntMethod(fn) {
                    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
                }

                function BufferBigIntNotDefined() {
                    throw new Error('BigInt not supported')
                }


                /***/
            }),

        /***/
        "dRwo":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var bind = __webpack_require__("5Shc");

                var $apply = __webpack_require__("W0t0");
                var $call = __webpack_require__("sFbD");
                var $reflectApply = __webpack_require__("JhPh");

                /** @type {import('./actualApply')} */
                module.exports = $reflectApply || bind.call($call, $apply);


                /***/
            }),

        /***/
        "W0t0":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./functionApply')} */
                module.exports = Function.prototype.apply;


                /***/
            }),

        /***/
        "sFbD":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./functionCall')} */
                module.exports = Function.prototype.call;


                /***/
            }),

        /***/
        "QM6E":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var bind = __webpack_require__("5Shc");
                var $TypeError = __webpack_require__("c2Eb");

                var $call = __webpack_require__("sFbD");
                var $actualApply = __webpack_require__("dRwo");

                /** @type {import('.')} */
                module.exports = function callBindBasic(args) {
                    if (args.length < 1 || typeof args[0] !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    return $actualApply(bind, $call, args);
                };


                /***/
            }),

        /***/
        "JhPh":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./reflectApply')} */
                module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


                /***/
            }),

        /***/
        "zGPW":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var GetIntrinsic = __webpack_require__("PQUF");

                var callBindBasic = __webpack_require__("QM6E");

                /** @type {(thisArg: string, searchString: string, position?: number) => number} */
                var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

                /** @type {import('.')} */
                module.exports = function callBoundIntrinsic(name, allowMissing) {
                    // eslint-disable-next-line no-extra-parens
                    var intrinsic = /** @type {Parameters<typeof callBindBasic>[0][0]} */ (GetIntrinsic(name, !!allowMissing));
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBindBasic([intrinsic]);
                    }
                    return intrinsic;
                };


                /***/
            }),

        /***/
        "OyDd":
            /***/
            ((module) => {

                "use strict";


                /******************************************************************************
                 * Created 2008-08-19.
                 *
                 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
                 *
                 * Copyright (C) 2008
                 *   Wyatt Baldwin <self@wyattbaldwin.com>
                 *   All rights reserved
                 *
                 * Licensed under the MIT license.
                 *
                 *   http://www.opensource.org/licenses/mit-license.php
                 *
                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                 * THE SOFTWARE.
                 *****************************************************************************/
                var dijkstra = {
                    single_source_shortest_paths: function(graph, s, d) {
                        // Predecessor map for each node that has been encountered.
                        // node ID => predecessor node ID
                        var predecessors = {};

                        // Costs of shortest paths from s to all nodes encountered.
                        // node ID => cost
                        var costs = {};
                        costs[s] = 0;

                        // Costs of shortest paths from s to all nodes encountered; differs from
                        // `costs` in that it provides easy access to the node that currently has
                        // the known shortest path from s.
                        // XXX: Do we actually need both `costs` and `open`?
                        var open = dijkstra.PriorityQueue.make();
                        open.push(s, 0);

                        var closest,
                            u, v,
                            cost_of_s_to_u,
                            adjacent_nodes,
                            cost_of_e,
                            cost_of_s_to_u_plus_cost_of_e,
                            cost_of_s_to_v,
                            first_visit;
                        while (!open.empty()) {
                            // In the nodes remaining in graph that have a known cost from s,
                            // find the node, u, that currently has the shortest path from s.
                            closest = open.pop();
                            u = closest.value;
                            cost_of_s_to_u = closest.cost;

                            // Get nodes adjacent to u...
                            adjacent_nodes = graph[u] || {};

                            // ...and explore the edges that connect u to those nodes, updating
                            // the cost of the shortest paths to any or all of those nodes as
                            // necessary. v is the node across the current edge from u.
                            for (v in adjacent_nodes) {
                                if (adjacent_nodes.hasOwnProperty(v)) {
                                    // Get the cost of the edge running from u to v.
                                    cost_of_e = adjacent_nodes[v];

                                    // Cost of s to u plus the cost of u to v across e--this is *a*
                                    // cost from s to v that may or may not be less than the current
                                    // known cost to v.
                                    cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

                                    // If we haven't visited v yet OR if the current known cost from s to
                                    // v is greater than the new cost we just found (cost of s to u plus
                                    // cost of u to v across e), update v's cost in the cost list and
                                    // update v's predecessor in the predecessor list (it's now u).
                                    cost_of_s_to_v = costs[v];
                                    first_visit = (typeof costs[v] === 'undefined');
                                    if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                                        costs[v] = cost_of_s_to_u_plus_cost_of_e;
                                        open.push(v, cost_of_s_to_u_plus_cost_of_e);
                                        predecessors[v] = u;
                                    }
                                }
                            }
                        }

                        if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
                            var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
                            throw new Error(msg);
                        }

                        return predecessors;
                    },

                    extract_shortest_path_from_predecessor_list: function(predecessors, d) {
                        var nodes = [];
                        var u = d;
                        var predecessor;
                        while (u) {
                            nodes.push(u);
                            predecessor = predecessors[u];
                            u = predecessors[u];
                        }
                        nodes.reverse();
                        return nodes;
                    },

                    find_path: function(graph, s, d) {
                        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
                        return dijkstra.extract_shortest_path_from_predecessor_list(
                            predecessors, d);
                    },

                    /**
                     * A very naive priority queue implementation.
                     */
                    PriorityQueue: {
                        make: function(opts) {
                            var T = dijkstra.PriorityQueue,
                                t = {},
                                key;
                            opts = opts || {};
                            for (key in T) {
                                if (T.hasOwnProperty(key)) {
                                    t[key] = T[key];
                                }
                            }
                            t.queue = [];
                            t.sorter = opts.sorter || T.default_sorter;
                            return t;
                        },

                        default_sorter: function(a, b) {
                            return a.cost - b.cost;
                        },

                        /**
                         * Add a new item to the queue and ensure the highest priority element
                         * is at the front of the queue.
                         */
                        push: function(value, cost) {
                            var item = {
                                value: value,
                                cost: cost
                            };
                            this.queue.push(item);
                            this.queue.sort(this.sorter);
                        },

                        /**
                         * Return the highest priority element in the queue.
                         */
                        pop: function() {
                            return this.queue.shift();
                        },

                        empty: function() {
                            return this.queue.length === 0;
                        }
                    }
                };


                // node.js module exports
                if (true) {
                    module.exports = dijkstra;
                }


                /***/
            }),

        /***/
        "8xyI":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var callBind = __webpack_require__("QM6E");
                var gOPD = __webpack_require__("1e4R");

                var hasProtoAccessor;
                try {
                    // eslint-disable-next-line no-extra-parens, no-proto
                    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
                } catch (e) {
                    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
                        throw e;
                    }
                }

                // eslint-disable-next-line no-extra-parens
                var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

                var $Object = Object;
                var $getPrototypeOf = $Object.getPrototypeOf;

                /** @type {import('./get')} */
                module.exports = desc && typeof desc.get === 'function' ?
                    callBind([desc.get]) :
                    typeof $getPrototypeOf === 'function' ?
                    /** @type {import('./get')} */ function getDunder(value) {
                        // eslint-disable-next-line eqeqeq
                        return $getPrototypeOf(value == null ? value : $Object(value));
                    } :
                    false;


                /***/
            }),

        /***/
        "1CsF":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('.')} */
                var $defineProperty = Object.defineProperty || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }

                module.exports = $defineProperty;


                /***/
            }),

        /***/
        "HNVt":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./eval')} */
                module.exports = EvalError;


                /***/
            }),

        /***/
        "80l6":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('.')} */
                module.exports = Error;


                /***/
            }),

        /***/
        "rZZv":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./range')} */
                module.exports = RangeError;


                /***/
            }),

        /***/
        "PxMZ":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./ref')} */
                module.exports = ReferenceError;


                /***/
            }),

        /***/
        "Lm6L":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./syntax')} */
                module.exports = SyntaxError;


                /***/
            }),

        /***/
        "c2Eb":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./type')} */
                module.exports = TypeError;


                /***/
            }),

        /***/
        "xNP6":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./uri')} */
                module.exports = URIError;


                /***/
            }),

        /***/
        "Cdrc":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('.')} */
                module.exports = Object;


                /***/
            }),

        /***/
        "M6q6":
            /***/
            ((module) => {

                "use strict";


                // do not edit .js files directly - edit src/index.jst


                var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';


                module.exports = function equal(a, b) {
                    if (a === b) return true;

                    if (a && b && typeof a == 'object' && typeof b == 'object') {
                        if (a.constructor !== b.constructor) return false;

                        var length, i, keys;
                        if (Array.isArray(a)) {
                            length = a.length;
                            if (length != b.length) return false;
                            for (i = length; i-- !== 0;)
                                if (!equal(a[i], b[i])) return false;
                            return true;
                        }


                        if ((a instanceof Map) && (b instanceof Map)) {
                            if (a.size !== b.size) return false;
                            for (i of a.entries())
                                if (!b.has(i[0])) return false;
                            for (i of a.entries())
                                if (!equal(i[1], b.get(i[0]))) return false;
                            return true;
                        }

                        if ((a instanceof Set) && (b instanceof Set)) {
                            if (a.size !== b.size) return false;
                            for (i of a.entries())
                                if (!b.has(i[0])) return false;
                            return true;
                        }

                        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
                            length = a.length;
                            if (length != b.length) return false;
                            for (i = length; i-- !== 0;)
                                if (a[i] !== b[i]) return false;
                            return true;
                        }


                        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
                        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
                        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

                        keys = Object.keys(a);
                        length = keys.length;
                        if (length !== Object.keys(b).length) return false;

                        for (i = length; i-- !== 0;)
                            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

                        for (i = length; i-- !== 0;) {
                            var key = keys[i];

                            if (key === '_owner' && a.$$typeof) {
                                // React-specific: avoid traversing React elements' _owner.
                                //  _owner contains circular references
                                // and is not needed when comparing the actual elements (and not their owners)
                                continue;
                            }

                            if (!equal(a[key], b[key])) return false;
                        }

                        return true;
                    }

                    // true if both NaN, false otherwise
                    return a !== a && b !== b;
                };


                /***/
            }),

        /***/
        "D9+X":
            /***/
            ((module) => {

                "use strict";


                /* eslint no-invalid-this: 1 */

                var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';

                var concatty = function concatty(a, b) {
                    var arr = [];

                    for (var i = 0; i < a.length; i += 1) {
                        arr[i] = a[i];
                    }
                    for (var j = 0; j < b.length; j += 1) {
                        arr[j + a.length] = b[j];
                    }

                    return arr;
                };

                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };

                var joiny = function(arr, joiner) {
                    var str = '';
                    for (var i = 0; i < arr.length; i += 1) {
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };

                module.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);

                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(
                                this,
                                concatty(args, arguments)
                            );
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(
                            that,
                            concatty(args, arguments)
                        );

                    };

                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for (var i = 0; i < boundLength; i++) {
                        boundArgs[i] = '$' + i;
                    }

                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }

                    return bound;
                };


                /***/
            }),

        /***/
        "5Shc":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var implementation = __webpack_require__("D9+X");

                module.exports = Function.prototype.bind || implementation;


                /***/
            }),

        /***/
        "PQUF":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var undefined;

                var $Object = __webpack_require__("Cdrc");

                var $Error = __webpack_require__("80l6");
                var $EvalError = __webpack_require__("HNVt");
                var $RangeError = __webpack_require__("rZZv");
                var $ReferenceError = __webpack_require__("PxMZ");
                var $SyntaxError = __webpack_require__("Lm6L");
                var $TypeError = __webpack_require__("c2Eb");
                var $URIError = __webpack_require__("xNP6");

                var abs = __webpack_require__("R89B");
                var floor = __webpack_require__("HLEs");
                var max = __webpack_require__("OfPJ");
                var min = __webpack_require__("bpVC");
                var pow = __webpack_require__("1dpo");
                var round = __webpack_require__("8b6j");
                var sign = __webpack_require__("c2fp");

                var $Function = Function;

                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };

                var $gOPD = __webpack_require__("1e4R");
                var $defineProperty = __webpack_require__("1CsF");

                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ?
                    (function() {
                        try {
                            // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                            arguments.callee; // IE 8 does not throw here
                            return throwTypeError;
                        } catch (calleeThrows) {
                            try {
                                // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                                return $gOPD(arguments, 'callee').get;
                            } catch (gOPDthrows) {
                                return throwTypeError;
                            }
                        }
                    }()) :
                    throwTypeError;

                var hasSymbols = __webpack_require__("JpGc")();

                var getProto = __webpack_require__("8Jwl");
                var $ObjectGPO = __webpack_require__("6VCL");
                var $ReflectGPO = __webpack_require__("2FE/");

                var $apply = __webpack_require__("W0t0");
                var $call = __webpack_require__("sFbD");

                var needsEval = {};

                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
                    '%AsyncFromSyncIteratorPrototype%': undefined,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval, // eslint-disable-line no-eval
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
                    '%Map%': typeof Map === 'undefined' ? undefined : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': $Object,
                    '%Object.getOwnPropertyDescriptor%': $gOPD,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto('' [Symbol.iterator]()) : undefined,
                    '%Symbol%': hasSymbols ? Symbol : undefined,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

                    '%Function.prototype.call%': $call,
                    '%Function.prototype.apply%': $apply,
                    '%Object.defineProperty%': $defineProperty,
                    '%Object.getPrototypeOf%': $ObjectGPO,
                    '%Math.abs%': abs,
                    '%Math.floor%': floor,
                    '%Math.max%': max,
                    '%Math.min%': min,
                    '%Math.pow%': pow,
                    '%Math.round%': round,
                    '%Math.sign%': sign,
                    '%Reflect.getPrototypeOf%': $ReflectGPO
                };

                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }

                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }

                    INTRINSICS[name] = value;

                    return value;
                };

                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
                    '%ArrayPrototype%': ['Array', 'prototype'],
                    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
                    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
                    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
                    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
                    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
                    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
                    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
                    '%BooleanPrototype%': ['Boolean', 'prototype'],
                    '%DataViewPrototype%': ['DataView', 'prototype'],
                    '%DatePrototype%': ['Date', 'prototype'],
                    '%ErrorPrototype%': ['Error', 'prototype'],
                    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
                    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
                    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
                    '%FunctionPrototype%': ['Function', 'prototype'],
                    '%Generator%': ['GeneratorFunction', 'prototype'],
                    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
                    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
                    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
                    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
                    '%JSONParse%': ['JSON', 'parse'],
                    '%JSONStringify%': ['JSON', 'stringify'],
                    '%MapPrototype%': ['Map', 'prototype'],
                    '%NumberPrototype%': ['Number', 'prototype'],
                    '%ObjectPrototype%': ['Object', 'prototype'],
                    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
                    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
                    '%PromisePrototype%': ['Promise', 'prototype'],
                    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
                    '%Promise_all%': ['Promise', 'all'],
                    '%Promise_reject%': ['Promise', 'reject'],
                    '%Promise_resolve%': ['Promise', 'resolve'],
                    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
                    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
                    '%RegExpPrototype%': ['RegExp', 'prototype'],
                    '%SetPrototype%': ['Set', 'prototype'],
                    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
                    '%StringPrototype%': ['String', 'prototype'],
                    '%SymbolPrototype%': ['Symbol', 'prototype'],
                    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
                    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
                    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
                    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
                    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
                    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
                    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
                    '%URIErrorPrototype%': ['URIError', 'prototype'],
                    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
                    '%WeakSetPrototype%': ['WeakSet', 'prototype']
                };

                var bind = __webpack_require__("5Shc");
                var hasOwn = __webpack_require__("Tin7");
                var $concat = bind.call($call, Array.prototype.concat);
                var $spliceApply = bind.call($apply, Array.prototype.splice);
                var $replace = bind.call($call, String.prototype.replace);
                var $strSlice = bind.call($call, String.prototype.slice);
                var $exec = bind.call($call, RegExp.prototype.exec);

                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
                var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */

                var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }

                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }

                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }

                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };

                module.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }

                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;

                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([0, 1], alias));
                    }

                    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if (
                            (
                                (first === '"' || first === "'" || first === '`') ||
                                (last === '"' || last === "'" || last === '`')
                            ) &&
                            first !== last
                        ) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }

                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';

                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined;
                            }
                            if ($gOPD && (i + 1) >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;

                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }

                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };


                /***/
            }),

        /***/
        "6VCL":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var $Object = __webpack_require__("Cdrc");

                /** @type {import('./Object.getPrototypeOf')} */
                module.exports = $Object.getPrototypeOf || null;


                /***/
            }),

        /***/
        "2FE/":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./Reflect.getPrototypeOf')} */
                module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


                /***/
            }),

        /***/
        "8Jwl":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var reflectGetProto = __webpack_require__("2FE/");
                var originalGetProto = __webpack_require__("6VCL");

                var getDunderProto = __webpack_require__("8xyI");

                /** @type {import('.')} */
                module.exports = reflectGetProto ?
                    function getProto(O) {
                        // @ts-expect-error TS can't narrow inside a closure, for some reason
                        return reflectGetProto(O);
                    } :
                    originalGetProto ?
                    function getProto(O) {
                        if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
                            throw new TypeError('getProto: not an object');
                        }
                        // @ts-expect-error TS can't narrow inside a closure, for some reason
                        return originalGetProto(O);
                    } :
                    getDunderProto ?
                    function getProto(O) {
                        // @ts-expect-error TS can't narrow inside a closure, for some reason
                        return getDunderProto(O);
                    } :
                    null;


                /***/
            }),

        /***/
        "Vytp":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./gOPD')} */
                module.exports = Object.getOwnPropertyDescriptor;


                /***/
            }),

        /***/
        "1e4R":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                /** @type {import('.')} */
                var $gOPD = __webpack_require__("Vytp");

                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }

                module.exports = $gOPD;


                /***/
            }),

        /***/
        "r3S0":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Z": () => ( /* binding */ ScrollToPlugin)
                    /* harmony export */
                });
                /* unused harmony export ScrollToPlugin */
                /*!
                 * ScrollToPlugin 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */

                /* eslint-disable */
                var gsap,
                    _coreInitted,
                    _window,
                    _docEl,
                    _body,
                    _toArray,
                    _config,
                    ScrollTrigger,
                    _windowExists = function _windowExists() {
                        return "object" !== "undefined";
                    },
                    _getGSAP = function _getGSAP() {
                        return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
                    },
                    _isString = function _isString(value) {
                        return typeof value === "string";
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function";
                    },
                    _max = function _max(element, axis) {
                        var dim = axis === "x" ? "Width" : "Height",
                            scroll = "scroll" + dim,
                            client = "client" + dim;
                        return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
                    },
                    _buildGetter = function _buildGetter(e, axis) {
                        //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
                        var p = "scroll" + (axis === "x" ? "Left" : "Top");

                        if (e === _window) {
                            if (e.pageXOffset != null) {
                                p = "page" + axis.toUpperCase() + "Offset";
                            } else {
                                e = _docEl[p] != null ? _docEl : _body;
                            }
                        }

                        return function() {
                            return e[p];
                        };
                    },
                    _clean = function _clean(value, index, target, targets) {
                        _isFunction(value) && (value = value(index, target, targets));

                        if (typeof value !== "object") {
                            return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
                                x: value,
                                y: value
                            } : {
                                y: value
                            }; //if we don't receive an object as the parameter, assume the user intends "y".
                        } else if (value.nodeType) {
                            return {
                                y: value,
                                x: value
                            };
                        } else {
                            var result = {},
                                p;

                            for (p in value) {
                                result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
                            }

                            return result;
                        }
                    },
                    _getOffset = function _getOffset(element, container) {
                        element = _toArray(element)[0];

                        if (!element || !element.getBoundingClientRect) {
                            return console.warn("scrollTo target doesn't exist. Using 0") || {
                                x: 0,
                                y: 0
                            };
                        }

                        var rect = element.getBoundingClientRect(),
                            isRoot = !container || container === _window || container === _body,
                            cRect = isRoot ? {
                                top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
                                left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
                            } : container.getBoundingClientRect(),
                            offsets = {
                                x: rect.left - cRect.left,
                                y: rect.top - cRect.top
                            };

                        if (!isRoot && container) {
                            //only add the current scroll position if it's not the window/body.
                            offsets.x += _buildGetter(container, "x")();
                            offsets.y += _buildGetter(container, "y")();
                        }

                        return offsets;
                    },
                    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
                        return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
                    },
                    _initCore = function _initCore() {
                        gsap = _getGSAP();

                        if (_windowExists() && gsap && typeof document !== "undefined" && document.body) {
                            _window = window;
                            _body = document.body;
                            _docEl = document.documentElement;
                            _toArray = gsap.utils.toArray;
                            gsap.config({
                                autoKillThreshold: 7
                            });
                            _config = gsap.config();
                            _coreInitted = 1;
                        }
                    };

                var ScrollToPlugin = {
                    version: "3.12.5",
                    name: "scrollTo",
                    rawVars: 1,
                    register: function register(core) {
                        gsap = core;

                        _initCore();
                    },
                    init: function init(target, value, tween, index, targets) {
                        _coreInitted || _initCore();
                        var data = this,
                            snapType = gsap.getProperty(target, "scrollSnapType");
                        data.isWin = target === _window;
                        data.target = target;
                        data.tween = tween;
                        value = _clean(value, index, target, targets);
                        data.vars = value;
                        data.autoKill = !!value.autoKill;
                        data.getX = _buildGetter(target, "x");
                        data.getY = _buildGetter(target, "y");
                        data.x = data.xPrev = data.getX();
                        data.y = data.yPrev = data.getY();
                        ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);
                        gsap.getProperty(target, "scrollBehavior") === "smooth" && gsap.set(target, {
                            scrollBehavior: "auto"
                        });

                        if (snapType && snapType !== "none") {
                            // disable scroll snapping to avoid strange behavior
                            data.snap = 1;
                            data.snapInline = target.style.scrollSnapType;
                            target.style.scrollSnapType = "none";
                        }

                        if (value.x != null) {
                            data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

                            data._props.push("scrollTo_x");
                        } else {
                            data.skipX = 1;
                        }

                        if (value.y != null) {
                            data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

                            data._props.push("scrollTo_y");
                        } else {
                            data.skipY = 1;
                        }
                    },
                    render: function render(ratio, data) {
                        var pt = data._pt,
                            target = data.target,
                            tween = data.tween,
                            autoKill = data.autoKill,
                            xPrev = data.xPrev,
                            yPrev = data.yPrev,
                            isWin = data.isWin,
                            snap = data.snap,
                            snapInline = data.snapInline,
                            x,
                            y,
                            yDif,
                            xDif,
                            threshold;

                        while (pt) {
                            pt.r(ratio, pt.d);
                            pt = pt._next;
                        }

                        x = isWin || !data.skipX ? data.getX() : xPrev;
                        y = isWin || !data.skipY ? data.getY() : yPrev;
                        yDif = y - yPrev;
                        xDif = x - xPrev;
                        threshold = _config.autoKillThreshold;

                        if (data.x < 0) {
                            //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
                            data.x = 0;
                        }

                        if (data.y < 0) {
                            data.y = 0;
                        }

                        if (autoKill) {
                            //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
                            if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
                                data.skipX = 1; //if the user scrolls separately, we should stop tweening!
                            }

                            if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
                                data.skipY = 1; //if the user scrolls separately, we should stop tweening!
                            }

                            if (data.skipX && data.skipY) {
                                tween.kill();
                                data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
                            }
                        }

                        if (isWin) {
                            _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
                        } else {
                            data.skipY || (target.scrollTop = data.y);
                            data.skipX || (target.scrollLeft = data.x);
                        }

                        if (snap && (ratio === 1 || ratio === 0)) {
                            y = target.scrollTop;
                            x = target.scrollLeft;
                            snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
                            target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.

                            target.scrollLeft = x + 1;
                            target.scrollTop = y;
                            target.scrollLeft = x;
                        }

                        data.xPrev = data.x;
                        data.yPrev = data.y;
                        ScrollTrigger && ScrollTrigger.update();
                    },
                    kill: function kill(property) {
                        var both = property === "scrollTo",
                            i = this._props.indexOf(property);

                        if (both || property === "scrollTo_x") {
                            this.skipX = 1;
                        }

                        if (both || property === "scrollTo_y") {
                            this.skipY = 1;
                        }

                        i > -1 && this._props.splice(i, 1);
                        return !this._props.length;
                    }
                };
                ScrollToPlugin.max = _max;
                ScrollToPlugin.getOffset = _getOffset;
                ScrollToPlugin.buildGetter = _buildGetter;
                _getGSAP() && gsap.registerPlugin(ScrollToPlugin);


                /***/
            }),

        /***/
        "a8Ch":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "Z": () => ( /* binding */ ScrollTrigger_ScrollTrigger)
                });

                // UNUSED EXPORTS: ScrollTrigger

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }

                /*!
                 * Observer 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */

                /* eslint-disable */
                var gsap,
                    _coreInitted,
                    _clamp,
                    _win,
                    _doc,
                    _docEl,
                    _body,
                    _isTouch,
                    _pointerType,
                    ScrollTrigger,
                    _root,
                    _normalizer,
                    _eventTypes,
                    _context,
                    _getGSAP = function _getGSAP() {
                        return gsap || true && (gsap = window.gsap) && gsap.registerPlugin && gsap;
                    },
                    _startup = 1,
                    _observers = [],
                    _scrollers = [],
                    _proxies = [],
                    _getTime = Date.now,
                    _bridge = function _bridge(name, value) {
                        return value;
                    },
                    _integrate = function _integrate() {
                        var core = ScrollTrigger.core,
                            data = core.bridge || {},
                            scrollers = core._scrollers,
                            proxies = core._proxies;
                        scrollers.push.apply(scrollers, _scrollers);
                        proxies.push.apply(proxies, _proxies);
                        _scrollers = scrollers;
                        _proxies = proxies;

                        _bridge = function _bridge(name, value) {
                            return data[name](value);
                        };
                    },
                    _getProxyProp = function _getProxyProp(element, property) {
                        return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
                    },
                    _isViewport = function _isViewport(el) {
                        return !!~_root.indexOf(el);
                    },
                    _addListener = function _addListener(element, type, func, passive, capture) {
                        return element.addEventListener(type, func, {
                            passive: passive !== false,
                            capture: !!capture
                        });
                    },
                    _removeListener = function _removeListener(element, type, func, capture) {
                        return element.removeEventListener(type, func, !!capture);
                    },
                    _scrollLeft = "scrollLeft",
                    _scrollTop = "scrollTop",
                    _onScroll = function _onScroll() {
                        return _normalizer && _normalizer.isPressed || _scrollers.cache++;
                    },
                    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
                        var cachingFunc = function cachingFunc(value) {
                            // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
                            if (value || value === 0) {
                                _startup && (_win.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

                                var isNormalizing = _normalizer && _normalizer.isPressed;
                                value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

                                f(value);
                                cachingFunc.cacheID = _scrollers.cache;
                                isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
                            } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
                                cachingFunc.cacheID = _scrollers.cache;
                                cachingFunc.v = f();
                            }

                            return cachingFunc.v + cachingFunc.offset;
                        };

                        cachingFunc.offset = 0;
                        return f && cachingFunc;
                    },
                    _horizontal = {
                        s: _scrollLeft,
                        p: "left",
                        p2: "Left",
                        os: "right",
                        os2: "Right",
                        d: "width",
                        d2: "Width",
                        a: "x",
                        sc: _scrollCacheFunc(function(value) {
                            return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
                        })
                    },
                    _vertical = {
                        s: _scrollTop,
                        p: "top",
                        p2: "Top",
                        os: "bottom",
                        os2: "Bottom",
                        d: "height",
                        d2: "Height",
                        a: "y",
                        op: _horizontal,
                        sc: _scrollCacheFunc(function(value) {
                            return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
                        })
                    },
                    _getTarget = function _getTarget(t, self) {
                        return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
                    },
                    _getScrollFunc = function _getScrollFunc(element, _ref) {
                        var s = _ref.s,
                            sc = _ref.sc;
                        // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
                        _isViewport(element) && (element = _doc.scrollingElement || _docEl);

                        var i = _scrollers.indexOf(element),
                            offset = sc === _vertical.sc ? 1 : 2;

                        !~i && (i = _scrollers.push(element) - 1);
                        _scrollers[i + offset] || _addListener(element, "scroll", _onScroll); // clear the cache when a scroll occurs

                        var prev = _scrollers[i + offset],
                            func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
                                return arguments.length ? element[s] = value : element[s];
                            })));
                        func.target = element;
                        prev || (func.smooth = gsap.getProperty(element, "scrollBehavior") === "smooth"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.

                        return func;
                    },
                    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
                        var v1 = value,
                            v2 = value,
                            t1 = _getTime(),
                            t2 = t1,
                            min = minTimeRefresh || 50,
                            dropToZeroTime = Math.max(500, min * 3),
                            update = function update(value, force) {
                                var t = _getTime();

                                if (force || t - t1 > min) {
                                    v2 = v1;
                                    v1 = value;
                                    t2 = t1;
                                    t1 = t;
                                } else if (useDelta) {
                                    v1 += value;
                                } else {
                                    // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
                                    v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
                                }
                            },
                            reset = function reset() {
                                v2 = v1 = useDelta ? 0 : v1;
                                t2 = t1 = 0;
                            },
                            getVelocity = function getVelocity(latestValue) {
                                var tOld = t2,
                                    vOld = v2,
                                    t = _getTime();

                                (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
                                return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
                            };

                        return {
                            update: update,
                            reset: reset,
                            getVelocity: getVelocity
                        };
                    },
                    _getEvent = function _getEvent(e, preventDefault) {
                        preventDefault && !e._gsapAllow && e.preventDefault();
                        return e.changedTouches ? e.changedTouches[0] : e;
                    },
                    _getAbsoluteMax = function _getAbsoluteMax(a) {
                        var max = Math.max.apply(Math, a),
                            min = Math.min.apply(Math, a);
                        return Math.abs(max) >= Math.abs(min) ? max : min;
                    },
                    _setScrollTrigger = function _setScrollTrigger() {
                        ScrollTrigger = gsap.core.globals().ScrollTrigger;
                        ScrollTrigger && ScrollTrigger.core && _integrate();
                    },
                    _initCore = function _initCore(core) {
                        gsap = core || _getGSAP();

                        if (!_coreInitted && gsap && typeof document !== "undefined" && document.body) {
                            _win = window;
                            _doc = document;
                            _docEl = _doc.documentElement;
                            _body = _doc.body;
                            _root = [_win, _doc, _docEl, _body];
                            _clamp = gsap.utils.clamp;

                            _context = gsap.core.context || function() {};

                            _pointerType = "onpointerenter" in _body ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

                            _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
                            _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
                            setTimeout(function() {
                                return _startup = 0;
                            }, 500);

                            _setScrollTrigger();

                            _coreInitted = 1;
                        }

                        return _coreInitted;
                    };

                _horizontal.op = _vertical;
                _scrollers.cache = 0;
                var Observer = /*#__PURE__*/ function() {
                    function Observer(vars) {
                        this.init(vars);
                    }

                    var _proto = Observer.prototype;

                    _proto.init = function init(vars) {
                        _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
                        ScrollTrigger || _setScrollTrigger();
                        var tolerance = vars.tolerance,
                            dragMinimum = vars.dragMinimum,
                            type = vars.type,
                            target = vars.target,
                            lineHeight = vars.lineHeight,
                            debounce = vars.debounce,
                            preventDefault = vars.preventDefault,
                            onStop = vars.onStop,
                            onStopDelay = vars.onStopDelay,
                            ignore = vars.ignore,
                            wheelSpeed = vars.wheelSpeed,
                            event = vars.event,
                            onDragStart = vars.onDragStart,
                            onDragEnd = vars.onDragEnd,
                            onDrag = vars.onDrag,
                            onPress = vars.onPress,
                            onRelease = vars.onRelease,
                            onRight = vars.onRight,
                            onLeft = vars.onLeft,
                            onUp = vars.onUp,
                            onDown = vars.onDown,
                            onChangeX = vars.onChangeX,
                            onChangeY = vars.onChangeY,
                            onChange = vars.onChange,
                            onToggleX = vars.onToggleX,
                            onToggleY = vars.onToggleY,
                            onHover = vars.onHover,
                            onHoverEnd = vars.onHoverEnd,
                            onMove = vars.onMove,
                            ignoreCheck = vars.ignoreCheck,
                            isNormalizer = vars.isNormalizer,
                            onGestureStart = vars.onGestureStart,
                            onGestureEnd = vars.onGestureEnd,
                            onWheel = vars.onWheel,
                            onEnable = vars.onEnable,
                            onDisable = vars.onDisable,
                            onClick = vars.onClick,
                            scrollSpeed = vars.scrollSpeed,
                            capture = vars.capture,
                            allowClicks = vars.allowClicks,
                            lockAxis = vars.lockAxis,
                            onLockAxis = vars.onLockAxis;
                        this.target = target = _getTarget(target) || _docEl;
                        this.vars = vars;
                        ignore && (ignore = gsap.utils.toArray(ignore));
                        tolerance = tolerance || 1e-9;
                        dragMinimum = dragMinimum || 0;
                        wheelSpeed = wheelSpeed || 1;
                        scrollSpeed = scrollSpeed || 1;
                        type = type || "wheel,touch,pointer";
                        debounce = debounce !== false;
                        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report "normal", so default to 22.

                        var id,
                            onStopDelayedCall,
                            dragged,
                            moved,
                            wheeled,
                            locked,
                            axis,
                            self = this,
                            prevDeltaX = 0,
                            prevDeltaY = 0,
                            passive = vars.passive || !preventDefault,
                            scrollFuncX = _getScrollFunc(target, _horizontal),
                            scrollFuncY = _getScrollFunc(target, _vertical),
                            scrollX = scrollFuncX(),
                            scrollY = scrollFuncY(),
                            limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
                            // for devices that accommodate mouse events and touch events, we need to distinguish.
                            isViewport = _isViewport(target),
                            ownerDoc = target.ownerDocument || _doc,
                            deltaX = [0, 0, 0],
                            // wheel, scroll, pointer/touch
                            deltaY = [0, 0, 0],
                            onClickTime = 0,
                            clickCapture = function clickCapture() {
                                return onClickTime = _getTime();
                            },
                            _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
                                return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
                            },
                            onStopFunc = function onStopFunc() {
                                self._vx.reset();

                                self._vy.reset();

                                onStopDelayedCall.pause();
                                onStop && onStop(self);
                            },
                            update = function update() {
                                var dx = self.deltaX = _getAbsoluteMax(deltaX),
                                    dy = self.deltaY = _getAbsoluteMax(deltaY),
                                    changedX = Math.abs(dx) >= tolerance,
                                    changedY = Math.abs(dy) >= tolerance;

                                onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

                                if (changedX) {
                                    onRight && self.deltaX > 0 && onRight(self);
                                    onLeft && self.deltaX < 0 && onLeft(self);
                                    onChangeX && onChangeX(self);
                                    onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
                                    prevDeltaX = self.deltaX;
                                    deltaX[0] = deltaX[1] = deltaX[2] = 0;
                                }

                                if (changedY) {
                                    onDown && self.deltaY > 0 && onDown(self);
                                    onUp && self.deltaY < 0 && onUp(self);
                                    onChangeY && onChangeY(self);
                                    onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
                                    prevDeltaY = self.deltaY;
                                    deltaY[0] = deltaY[1] = deltaY[2] = 0;
                                }

                                if (moved || dragged) {
                                    onMove && onMove(self);

                                    if (dragged) {
                                        onDrag(self);
                                        dragged = false;
                                    }

                                    moved = false;
                                }

                                locked && !(locked = false) && onLockAxis && onLockAxis(self);

                                if (wheeled) {
                                    onWheel(self);
                                    wheeled = false;
                                }

                                id = 0;
                            },
                            onDelta = function onDelta(x, y, index) {
                                deltaX[index] += x;
                                deltaY[index] += y;

                                self._vx.update(x);

                                self._vy.update(y);

                                debounce ? id || (id = requestAnimationFrame(update)) : update();
                            },
                            onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
                                if (lockAxis && !axis) {
                                    self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
                                    locked = true;
                                }

                                if (axis !== "y") {
                                    deltaX[2] += x;

                                    self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

                                }

                                if (axis !== "x") {
                                    deltaY[2] += y;

                                    self._vy.update(y, true);
                                }

                                debounce ? id || (id = requestAnimationFrame(update)) : update();
                            },
                            _onDrag = function _onDrag(e) {
                                if (_ignoreCheck(e, 1)) {
                                    return;
                                }

                                e = _getEvent(e, preventDefault);
                                var x = e.clientX,
                                    y = e.clientY,
                                    dx = x - self.x,
                                    dy = y - self.y,
                                    isDragging = self.isDragging;
                                self.x = x;
                                self.y = y;

                                if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
                                    onDrag && (dragged = true);
                                    isDragging || (self.isDragging = true);
                                    onTouchOrPointerDelta(dx, dy);
                                    isDragging || onDragStart && onDragStart(self);
                                }
                            },
                            _onPress = self.onPress = function(e) {
                                if (_ignoreCheck(e, 1) || e && e.button) {
                                    return;
                                }

                                self.axis = axis = null;
                                onStopDelayedCall.pause();
                                self.isPressed = true;
                                e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

                                prevDeltaX = prevDeltaY = 0;
                                self.startX = self.x = e.clientX;
                                self.startY = self.y = e.clientY;

                                self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


                                self._vy.reset();

                                _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);

                                self.deltaX = self.deltaY = 0;
                                onPress && onPress(self);
                            },
                            _onRelease = self.onRelease = function(e) {
                                if (_ignoreCheck(e, 1)) {
                                    return;
                                }

                                _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

                                var isTrackingDrag = !isNaN(self.y - self.startY),
                                    wasDragging = self.isDragging,
                                    isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
                                    // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
                                    eventData = _getEvent(e);

                                if (!isDragNotClick && isTrackingDrag) {
                                    self._vx.reset();

                                    self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.


                                    if (preventDefault && allowClicks) {
                                        gsap.delayedCall(0.08, function() {
                                            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
                                            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                                                if (e.target.click) {
                                                    //some browsers (like mobile Safari) don't properly trigger the click event
                                                    e.target.click();
                                                } else if (ownerDoc.createEvent) {
                                                    var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                                                    syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                                                    e.target.dispatchEvent(syntheticEvent);
                                                }
                                            }
                                        });
                                    }
                                }

                                self.isDragging = self.isGesturing = self.isPressed = false;
                                onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
                                onDragEnd && wasDragging && onDragEnd(self);
                                onRelease && onRelease(self, isDragNotClick);
                            },
                            _onGestureStart = function _onGestureStart(e) {
                                return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
                            },
                            _onGestureEnd = function _onGestureEnd() {
                                return (self.isGesturing = false) || onGestureEnd(self);
                            },
                            onScroll = function onScroll(e) {
                                if (_ignoreCheck(e)) {
                                    return;
                                }

                                var x = scrollFuncX(),
                                    y = scrollFuncY();
                                onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
                                scrollX = x;
                                scrollY = y;
                                onStop && onStopDelayedCall.restart(true);
                            },
                            _onWheel = function _onWheel(e) {
                                if (_ignoreCheck(e)) {
                                    return;
                                }

                                e = _getEvent(e, preventDefault);
                                onWheel && (wheeled = true);
                                var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
                                onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
                                onStop && !isNormalizer && onStopDelayedCall.restart(true);
                            },
                            _onMove = function _onMove(e) {
                                if (_ignoreCheck(e)) {
                                    return;
                                }

                                var x = e.clientX,
                                    y = e.clientY,
                                    dx = x - self.x,
                                    dy = y - self.y;
                                self.x = x;
                                self.y = y;
                                moved = true;
                                onStop && onStopDelayedCall.restart(true);
                                (dx || dy) && onTouchOrPointerDelta(dx, dy);
                            },
                            _onHover = function _onHover(e) {
                                self.event = e;
                                onHover(self);
                            },
                            _onHoverEnd = function _onHoverEnd(e) {
                                self.event = e;
                                onHoverEnd(self);
                            },
                            _onClick = function _onClick(e) {
                                return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
                            };

                        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
                        self.deltaX = self.deltaY = 0;
                        self._vx = _getVelocityProp(0, 50, true);
                        self._vy = _getVelocityProp(0, 50, true);
                        self.scrollX = scrollFuncX;
                        self.scrollY = scrollFuncY;
                        self.isDragging = self.isGesturing = self.isPressed = false;

                        _context(this);

                        self.enable = function(e) {
                            if (!self.isEnabled) {
                                _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

                                type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
                                type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);

                                if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
                                    _addListener(target, _eventTypes[0], _onPress, passive, capture);

                                    _addListener(ownerDoc, _eventTypes[2], _onRelease);

                                    _addListener(ownerDoc, _eventTypes[3], _onRelease);

                                    allowClicks && _addListener(target, "click", clickCapture, true, true);
                                    onClick && _addListener(target, "click", _onClick);
                                    onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
                                    onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
                                    onHover && _addListener(target, _pointerType + "enter", _onHover);
                                    onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
                                    onMove && _addListener(target, _pointerType + "move", _onMove);
                                }

                                self.isEnabled = true;
                                e && e.type && _onPress(e);
                                onEnable && onEnable(self);
                            }

                            return self;
                        };

                        self.disable = function() {
                            if (self.isEnabled) {
                                // only remove the _onScroll listener if there aren't any others that rely on the functionality.
                                _observers.filter(function(o) {
                                    return o !== self && _isViewport(o.target);
                                }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

                                if (self.isPressed) {
                                    self._vx.reset();

                                    self._vy.reset();

                                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
                                }

                                _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

                                _removeListener(target, "wheel", _onWheel, capture);

                                _removeListener(target, _eventTypes[0], _onPress, capture);

                                _removeListener(ownerDoc, _eventTypes[2], _onRelease);

                                _removeListener(ownerDoc, _eventTypes[3], _onRelease);

                                _removeListener(target, "click", clickCapture, true);

                                _removeListener(target, "click", _onClick);

                                _removeListener(ownerDoc, "gesturestart", _onGestureStart);

                                _removeListener(ownerDoc, "gestureend", _onGestureEnd);

                                _removeListener(target, _pointerType + "enter", _onHover);

                                _removeListener(target, _pointerType + "leave", _onHoverEnd);

                                _removeListener(target, _pointerType + "move", _onMove);

                                self.isEnabled = self.isPressed = self.isDragging = false;
                                onDisable && onDisable(self);
                            }
                        };

                        self.kill = self.revert = function() {
                            self.disable();

                            var i = _observers.indexOf(self);

                            i >= 0 && _observers.splice(i, 1);
                            _normalizer === self && (_normalizer = 0);
                        };

                        _observers.push(self);

                        isNormalizer && _isViewport(target) && (_normalizer = self);
                        self.enable(event);
                    };

                    _createClass(Observer, [{
                        key: "velocityX",
                        get: function get() {
                            return this._vx.getVelocity();
                        }
                    }, {
                        key: "velocityY",
                        get: function get() {
                            return this._vy.getVelocity();
                        }
                    }]);

                    return Observer;
                }();
                Observer.version = "3.12.5";

                Observer.create = function(vars) {
                    return new Observer(vars);
                };

                Observer.register = _initCore;

                Observer.getAll = function() {
                    return _observers.slice();
                };

                Observer.getById = function(id) {
                    return _observers.filter(function(o) {
                        return o.vars.id === id;
                    })[0];
                };

                _getGSAP() && gsap.registerPlugin(Observer);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js
                /*!
                 * ScrollTrigger 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */

                /* eslint-disable */


                var ScrollTrigger_gsap,
                    ScrollTrigger_coreInitted,
                    ScrollTrigger_win,
                    ScrollTrigger_doc,
                    ScrollTrigger_docEl,
                    ScrollTrigger_body,
                    ScrollTrigger_root,
                    _resizeDelay,
                    _toArray,
                    ScrollTrigger_clamp,
                    _time2,
                    _syncInterval,
                    _refreshing,
                    _pointerIsDown,
                    _transformProp,
                    _i,
                    _prevWidth,
                    _prevHeight,
                    _autoRefresh,
                    _sort,
                    _suppressOverwrites,
                    _ignoreResize,
                    ScrollTrigger_normalizer,
                    _ignoreMobileResize,
                    _baseScreenHeight,
                    _baseScreenWidth,
                    _fixIOSBug,
                    ScrollTrigger_context,
                    _scrollRestoration,
                    _div100vh,
                    _100vh,
                    _isReverted,
                    _clampingMax,
                    _limitCallbacks,
                    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
                    ScrollTrigger_startup = 1,
                    ScrollTrigger_getTime = Date.now,
                    _time1 = ScrollTrigger_getTime(),
                    _lastScrollTime = 0,
                    _enabled = 0,
                    _parseClamp = function _parseClamp(value, type, self) {
                        var clamp = _isString(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
                        self["_" + type + "Clamp"] = clamp;
                        return clamp ? value.substr(6, value.length - 7) : value;
                    },
                    _keepClamp = function _keepClamp(value, clamp) {
                        return clamp && (!_isString(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
                    },
                    _rafBugFix = function _rafBugFix() {
                        return _enabled && requestAnimationFrame(_rafBugFix);
                    },
                    // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.
                    _pointerDownHandler = function _pointerDownHandler() {
                        return _pointerIsDown = 1;
                    },
                    _pointerUpHandler = function _pointerUpHandler() {
                        return _pointerIsDown = 0;
                    },
                    _passThrough = function _passThrough(v) {
                        return v;
                    },
                    _round = function _round(value) {
                        return Math.round(value * 100000) / 100000 || 0;
                    },
                    _windowExists = function _windowExists() {
                        return "object" !== "undefined";
                    },
                    ScrollTrigger_getGSAP = function _getGSAP() {
                        return ScrollTrigger_gsap || _windowExists() && (ScrollTrigger_gsap = window.gsap) && ScrollTrigger_gsap.registerPlugin && ScrollTrigger_gsap;
                    },
                    ScrollTrigger_isViewport = function _isViewport(e) {
                        return !!~ScrollTrigger_root.indexOf(e);
                    },
                    _getViewportDimension = function _getViewportDimension(dimensionProperty) {
                        return (dimensionProperty === "Height" ? _100vh : ScrollTrigger_win["inner" + dimensionProperty]) || ScrollTrigger_docEl["client" + dimensionProperty] || ScrollTrigger_body["client" + dimensionProperty];
                    },
                    _getBoundsFunc = function _getBoundsFunc(element) {
                        return _getProxyProp(element, "getBoundingClientRect") || (ScrollTrigger_isViewport(element) ? function() {
                            _winOffsets.width = ScrollTrigger_win.innerWidth;
                            _winOffsets.height = _100vh;
                            return _winOffsets;
                        } : function() {
                            return _getBounds(element);
                        });
                    },
                    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
                        var d = _ref.d,
                            d2 = _ref.d2,
                            a = _ref.a;
                        return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
                            return a()[d];
                        } : function() {
                            return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0;
                        };
                    },
                    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
                        return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
                            return _winOffsets;
                        };
                    },
                    _maxScroll = function _maxScroll(element, _ref2) {
                        var s = _ref2.s,
                            d2 = _ref2.d2,
                            d = _ref2.d,
                            a = _ref2.a;
                        return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : ScrollTrigger_isViewport(element) ? (ScrollTrigger_docEl[s] || ScrollTrigger_body[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2]);
                    },
                    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
                        for (var i = 0; i < _autoRefresh.length; i += 3) {
                            (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
                        }
                    },
                    _isString = function _isString(value) {
                        return typeof value === "string";
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function";
                    },
                    _isNumber = function _isNumber(value) {
                        return typeof value === "number";
                    },
                    _isObject = function _isObject(value) {
                        return typeof value === "object";
                    },
                    _endAnimation = function _endAnimation(animation, reversed, pause) {
                        return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
                    },
                    _callback = function _callback(self, func) {
                        if (self.enabled) {
                            var result = self._ctx ? self._ctx.add(function() {
                                return func(self);
                            }) : func(self);
                            result && result.totalTime && (self.callbackAnimation = result);
                        }
                    },
                    _abs = Math.abs,
                    _left = "left",
                    _top = "top",
                    _right = "right",
                    _bottom = "bottom",
                    _width = "width",
                    _height = "height",
                    _Right = "Right",
                    _Left = "Left",
                    _Top = "Top",
                    _Bottom = "Bottom",
                    _padding = "padding",
                    _margin = "margin",
                    _Width = "Width",
                    _Height = "Height",
                    _px = "px",
                    _getComputedStyle = function _getComputedStyle(element) {
                        return ScrollTrigger_win.getComputedStyle(element);
                    },
                    _makePositionable = function _makePositionable(element) {
                        // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
                        var position = _getComputedStyle(element).position;

                        element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
                    },
                    _setDefaults = function _setDefaults(obj, defaults) {
                        for (var p in defaults) {
                            p in obj || (obj[p] = defaults[p]);
                        }

                        return obj;
                    },
                    _getBounds = function _getBounds(element, withoutTransforms) {
                        var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && ScrollTrigger_gsap.to(element, {
                                x: 0,
                                y: 0,
                                xPercent: 0,
                                yPercent: 0,
                                rotation: 0,
                                rotationX: 0,
                                rotationY: 0,
                                scale: 1,
                                skewX: 0,
                                skewY: 0
                            }).progress(1),
                            bounds = element.getBoundingClientRect();
                        tween && tween.progress(0).kill();
                        return bounds;
                    },
                    _getSize = function _getSize(element, _ref3) {
                        var d2 = _ref3.d2;
                        return element["offset" + d2] || element["client" + d2] || 0;
                    },
                    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
                        var a = [],
                            labels = timeline.labels,
                            duration = timeline.duration(),
                            p;

                        for (p in labels) {
                            a.push(labels[p] / duration);
                        }

                        return a;
                    },
                    _getClosestLabel = function _getClosestLabel(animation) {
                        return function(value) {
                            return ScrollTrigger_gsap.utils.snap(_getLabelRatioArray(animation), value);
                        };
                    },
                    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
                        var snap = ScrollTrigger_gsap.utils.snap(snapIncrementOrArray),
                            a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a, b) {
                                return a - b;
                            });
                        return a ? function(value, direction, threshold) {
                            if (threshold === void 0) {
                                threshold = 1e-3;
                            }

                            var i;

                            if (!direction) {
                                return snap(value);
                            }

                            if (direction > 0) {
                                value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

                                for (i = 0; i < a.length; i++) {
                                    if (a[i] >= value) {
                                        return a[i];
                                    }
                                }

                                return a[i - 1];
                            } else {
                                i = a.length;
                                value += threshold;

                                while (i--) {
                                    if (a[i] <= value) {
                                        return a[i];
                                    }
                                }
                            }

                            return a[0];
                        } : function(value, direction, threshold) {
                            if (threshold === void 0) {
                                threshold = 1e-3;
                            }

                            var snapped = snap(value);
                            return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
                        };
                    },
                    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
                        return function(value, st) {
                            return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
                        };
                    },
                    _multiListener = function _multiListener(func, element, types, callback) {
                        return types.split(",").forEach(function(type) {
                            return func(element, type, callback);
                        });
                    },
                    ScrollTrigger_addListener = function _addListener(element, type, func, nonPassive, capture) {
                        return element.addEventListener(type, func, {
                            passive: !nonPassive,
                            capture: !!capture
                        });
                    },
                    ScrollTrigger_removeListener = function _removeListener(element, type, func, capture) {
                        return element.removeEventListener(type, func, !!capture);
                    },
                    _wheelListener = function _wheelListener(func, el, scrollFunc) {
                        scrollFunc = scrollFunc && scrollFunc.wheelHandler;

                        if (scrollFunc) {
                            func(el, "wheel", scrollFunc);
                            func(el, "touchmove", scrollFunc);
                        }
                    },
                    _markerDefaults = {
                        startColor: "green",
                        endColor: "red",
                        indent: 0,
                        fontSize: "16px",
                        fontWeight: "normal"
                    },
                    _defaults = {
                        toggleActions: "play",
                        anticipatePin: 0
                    },
                    _keywords = {
                        top: 0,
                        left: 0,
                        center: 0.5,
                        bottom: 1,
                        right: 1
                    },
                    _offsetToPx = function _offsetToPx(value, size) {
                        if (_isString(value)) {
                            var eqIndex = value.indexOf("="),
                                relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

                            if (~eqIndex) {
                                value.indexOf("%") > eqIndex && (relative *= size / 100);
                                value = value.substr(0, eqIndex - 1);
                            }

                            value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
                        }

                        return value;
                    },
                    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
                        var startColor = _ref4.startColor,
                            endColor = _ref4.endColor,
                            fontSize = _ref4.fontSize,
                            indent = _ref4.indent,
                            fontWeight = _ref4.fontWeight;

                        var e = ScrollTrigger_doc.createElement("div"),
                            useFixedPosition = ScrollTrigger_isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
                            isScroller = type.indexOf("scroller") !== -1,
                            parent = useFixedPosition ? ScrollTrigger_body : container,
                            isStart = type.indexOf("start") !== -1,
                            color = isStart ? startColor : endColor,
                            css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

                        css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
                        (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
                        matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
                        e._isStart = isStart;
                        e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
                        e.style.cssText = css;
                        e.innerText = name || name === 0 ? type + "-" + name : type;
                        parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
                        e._offset = e["offset" + direction.op.d2];

                        _positionMarker(e, 0, direction, isStart);

                        return e;
                    },
                    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
                        var vars = {
                                display: "block"
                            },
                            side = direction[flipped ? "os2" : "p2"],
                            oppositeSide = direction[flipped ? "p2" : "os2"];
                        marker._isFlipped = flipped;
                        vars[direction.a + "Percent"] = flipped ? -100 : 0;
                        vars[direction.a] = flipped ? "1px" : 0;
                        vars["border" + side + _Width] = 1;
                        vars["border" + oppositeSide + _Width] = 0;
                        vars[direction.p] = start + "px";
                        ScrollTrigger_gsap.set(marker, vars);
                    },
                    _triggers = [],
                    _ids = {},
                    _rafID,
                    _sync = function _sync() {
                        return ScrollTrigger_getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
                    },
                    ScrollTrigger_onScroll = function _onScroll() {
                        // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
                        if (!ScrollTrigger_normalizer || !ScrollTrigger_normalizer.isPressed || ScrollTrigger_normalizer.startX > ScrollTrigger_body.clientWidth) {
                            // if the user is dragging the scrollbar, allow it.
                            _scrollers.cache++;

                            if (ScrollTrigger_normalizer) {
                                _rafID || (_rafID = requestAnimationFrame(_updateAll));
                            } else {
                                _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110

                            }

                            _lastScrollTime || _dispatch("scrollStart");
                            _lastScrollTime = ScrollTrigger_getTime();
                        }
                    },
                    _setBaseDimensions = function _setBaseDimensions() {
                        _baseScreenWidth = ScrollTrigger_win.innerWidth;
                        _baseScreenHeight = ScrollTrigger_win.innerHeight;
                    },
                    _onResize = function _onResize() {
                        _scrollers.cache++;
                        !_refreshing && !_ignoreResize && !ScrollTrigger_doc.fullscreenElement && !ScrollTrigger_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== ScrollTrigger_win.innerWidth || Math.abs(ScrollTrigger_win.innerHeight - _baseScreenHeight) > ScrollTrigger_win.innerHeight * 0.25) && _resizeDelay.restart(true);
                    },
                    // ignore resizes triggered by refresh()
                    _listeners = {},
                    _emptyArray = [],
                    _softRefresh = function _softRefresh() {
                        return ScrollTrigger_removeListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
                    },
                    _dispatch = function _dispatch(type) {
                        return _listeners[type] && _listeners[type].map(function(f) {
                            return f();
                        }) || _emptyArray;
                    },
                    _savedStyles = [],
                    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
                    _revertRecorded = function _revertRecorded(media) {
                        for (var i = 0; i < _savedStyles.length; i += 5) {
                            if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
                                _savedStyles[i].style.cssText = _savedStyles[i + 1];
                                _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
                                _savedStyles[i + 3].uncache = 1;
                            }
                        }
                    },
                    _revertAll = function _revertAll(kill, media) {
                        var trigger;

                        for (_i = 0; _i < _triggers.length; _i++) {
                            trigger = _triggers[_i];

                            if (trigger && (!media || trigger._ctx === media)) {
                                if (kill) {
                                    trigger.kill(1);
                                } else {
                                    trigger.revert(true, true);
                                }
                            }
                        }

                        _isReverted = true;
                        media && _revertRecorded(media);
                        media || _dispatch("revert");
                    },
                    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
                        // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
                        _scrollers.cache++;
                        (force || !_refreshingAll) && _scrollers.forEach(function(obj) {
                            return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);
                        });
                        _isString(scrollRestoration) && (ScrollTrigger_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);
                    },
                    _refreshingAll,
                    _refreshID = 0,
                    _queueRefreshID,
                    _queueRefreshAll = function _queueRefreshAll() {
                        // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's "load" or "DOMContentLoaded" events to trigger it.
                        if (_queueRefreshID !== _refreshID) {
                            var id = _queueRefreshID = _refreshID;
                            requestAnimationFrame(function() {
                                return id === _refreshID && _refreshAll(true);
                            });
                        }
                    },
                    _refresh100vh = function _refresh100vh() {
                        ScrollTrigger_body.appendChild(_div100vh);

                        _100vh = !ScrollTrigger_normalizer && _div100vh.offsetHeight || ScrollTrigger_win.innerHeight;

                        ScrollTrigger_body.removeChild(_div100vh);
                    },
                    _hideAllMarkers = function _hideAllMarkers(hide) {
                        return _toArray(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(el) {
                            return el.style.display = hide ? "none" : "block";
                        });
                    },
                    _refreshAll = function _refreshAll(force, skipRevert) {
                        if (_lastScrollTime && !force && !_isReverted) {
                            ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh);

                            return;
                        }

                        _refresh100vh();

                        _refreshingAll = ScrollTrigger_ScrollTrigger.isRefreshing = true;

                        _scrollers.forEach(function(obj) {
                            return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());
                        }); // force the clearing of the cache because some browsers take a little while to dispatch the "scroll" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away


                        var refreshInits = _dispatch("refreshInit");

                        _sort && ScrollTrigger_ScrollTrigger.sort();
                        skipRevert || _revertAll();

                        _scrollers.forEach(function(obj) {
                            if (_isFunction(obj)) {
                                obj.smooth && (obj.target.style.scrollBehavior = "auto"); // smooth scrolling interferes

                                obj(0);
                            }
                        });

                        _triggers.slice(0).forEach(function(t) {
                            return t.refresh();
                        }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


                        _isReverted = false;

                        _triggers.forEach(function(t) {
                            // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.
                            if (t._subPinOffset && t.pin) {
                                var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                    original = t.pin[prop];
                                t.revert(true, 1);
                                t.adjustPinSpacing(t.pin[prop] - original);
                                t.refresh();
                            }
                        });

                        _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.

                        _hideAllMarkers(true);

                        _triggers.forEach(function(t) {
                            // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max". Same for anything with a clamped end
                            var max = _maxScroll(t.scroller, t._dir),
                                endClamp = t.vars.end === "max" || t._endClamp && t.end > max,
                                startClamp = t._startClamp && t.start >= max;

                            (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);
                        });

                        _hideAllMarkers(false);

                        _clampingMax = 0;
                        refreshInits.forEach(function(result) {
                            return result && result.render && result.render(-1);
                        }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

                        _scrollers.forEach(function(obj) {
                            if (_isFunction(obj)) {
                                obj.smooth && requestAnimationFrame(function() {
                                    return obj.target.style.scrollBehavior = "smooth";
                                });
                                obj.rec && obj(obj.rec);
                            }
                        });

                        _clearScrollMemory(_scrollRestoration, 1);

                        _resizeDelay.pause();

                        _refreshID++;
                        _refreshingAll = 2;

                        _updateAll(2);

                        _triggers.forEach(function(t) {
                            return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);
                        });

                        _refreshingAll = ScrollTrigger_ScrollTrigger.isRefreshing = false;

                        _dispatch("refresh");
                    },
                    _lastScroll = 0,
                    _direction = 1,
                    _primary,
                    _updateAll = function _updateAll(force) {
                        if (force === 2 || !_refreshingAll && !_isReverted) {
                            // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.
                            ScrollTrigger_ScrollTrigger.isUpdating = true;
                            _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

                            var l = _triggers.length,
                                time = ScrollTrigger_getTime(),
                                recordVelocity = time - _time1 >= 50,
                                scroll = l && _triggers[0].scroll();

                            _direction = _lastScroll > scroll ? -1 : 1;
                            _refreshingAll || (_lastScroll = scroll);

                            if (recordVelocity) {
                                if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
                                    _lastScrollTime = 0;

                                    _dispatch("scrollEnd");
                                }

                                _time2 = _time1;
                                _time1 = time;
                            }

                            if (_direction < 0) {
                                _i = l;

                                while (_i-- > 0) {
                                    _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                                }

                                _direction = 1;
                            } else {
                                for (_i = 0; _i < l; _i++) {
                                    _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                                }
                            }

                            ScrollTrigger_ScrollTrigger.isUpdating = false;
                        }

                        _rafID = 0;
                    },
                    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
                    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
                    _swapPinOut = function _swapPinOut(pin, spacer, state) {
                        _setState(state);

                        var cache = pin._gsap;

                        if (cache.spacerIsNative) {
                            _setState(cache.spacerState);
                        } else if (pin._gsap.swappedIn) {
                            var parent = spacer.parentNode;

                            if (parent) {
                                parent.insertBefore(pin, spacer);
                                parent.removeChild(spacer);
                            }
                        }

                        pin._gsap.swappedIn = false;
                    },
                    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
                        if (!pin._gsap.swappedIn) {
                            var i = _propNamesToCopy.length,
                                spacerStyle = spacer.style,
                                pinStyle = pin.style,
                                p;

                            while (i--) {
                                p = _propNamesToCopy[i];
                                spacerStyle[p] = cs[p];
                            }

                            spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
                            cs.display === "inline" && (spacerStyle.display = "inline-block");
                            pinStyle[_bottom] = pinStyle[_right] = "auto";
                            spacerStyle.flexBasis = cs.flexBasis || "auto";
                            spacerStyle.overflow = "visible";
                            spacerStyle.boxSizing = "border-box";
                            spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
                            spacerStyle[_height] = _getSize(pin, _vertical) + _px;
                            spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

                            _setState(spacerState);

                            pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
                            pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
                            pinStyle[_padding] = cs[_padding];

                            if (pin.parentNode !== spacer) {
                                pin.parentNode.insertBefore(spacer, pin);
                                spacer.appendChild(pin);
                            }

                            pin._gsap.swappedIn = true;
                        }
                    },
                    _capsExp = /([A-Z])/g,
                    _setState = function _setState(state) {
                        if (state) {
                            var style = state.t.style,
                                l = state.length,
                                i = 0,
                                p,
                                value;
                            (state.t._gsap || ScrollTrigger_gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

                            for (; i < l; i += 2) {
                                value = state[i + 1];
                                p = state[i];

                                if (value) {
                                    style[p] = value;
                                } else if (style[p]) {
                                    style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
                                }
                            }
                        }
                    },
                    _getState = function _getState(element) {
                        // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
                        var l = _stateProps.length,
                            style = element.style,
                            state = [],
                            i = 0;

                        for (; i < l; i++) {
                            state.push(_stateProps[i], style[_stateProps[i]]);
                        }

                        state.t = element;
                        return state;
                    },
                    _copyState = function _copyState(state, override, omitOffsets) {
                        var result = [],
                            l = state.length,
                            i = omitOffsets ? 8 : 0,
                            // skip top, left, right, bottom if omitOffsets is true
                            p;

                        for (; i < l; i += 2) {
                            p = state[i];
                            result.push(p, p in override ? override[p] : state[i + 1]);
                        }

                        result.t = state.t;
                        return result;
                    },
                    _winOffsets = {
                        left: 0,
                        top: 0
                    },
                    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
                    // _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
                    // 	scroller = _getTarget(scroller || _win);
                    // 	let direction = horizontal ? _horizontal : _vertical,
                    // 		isViewport = _isViewport(scroller);
                    // 	_getSizeFunc(scroller, isViewport, direction);
                    // 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
                    // },
                    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
                        _isFunction(value) && (value = value(self));

                        if (_isString(value) && value.substr(0, 3) === "max") {
                            value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
                        }

                        var time = containerAnimation ? containerAnimation.time() : 0,
                            p1,
                            p2,
                            element;
                        containerAnimation && containerAnimation.seek(0);
                        isNaN(value) || (value = +value); // convert a string number like "45" to an actual number

                        if (!_isNumber(value)) {
                            _isFunction(trigger) && (trigger = trigger(self));
                            var offsets = (value || "0").split(" "),
                                bounds,
                                localOffset,
                                globalOffset,
                                display;
                            element = _getTarget(trigger, self) || ScrollTrigger_body;
                            bounds = _getBounds(element) || {};

                            if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
                                // if display is "none", it won't report getBoundingClientRect() properly
                                display = element.style.display;
                                element.style.display = "block";
                                bounds = _getBounds(element);
                                display ? element.style.display = display : element.style.removeProperty("display");
                            }

                            localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
                            globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
                            value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
                            markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
                            scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
                        } else {
                            containerAnimation && (value = ScrollTrigger_gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
                            markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
                        }

                        if (clampZeroProp) {
                            self[clampZeroProp] = value || -0.001;
                            value < 0 && (value = 0);
                        }

                        if (marker) {
                            var position = value + scrollerSize,
                                isStart = marker._isStart;
                            p1 = "scroll" + direction.d2;

                            _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(ScrollTrigger_body[p1], ScrollTrigger_docEl[p1]) : marker.parentNode[p1]) <= position + 1);

                            if (useFixedPosition) {
                                scrollerBounds = _getBounds(markerScroller);
                                useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
                            }
                        }

                        if (containerAnimation && element) {
                            p1 = _getBounds(element);
                            containerAnimation.seek(scrollerMax);
                            p2 = _getBounds(element);
                            containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
                            value = value / containerAnimation._caScrollDist * scrollerMax;
                        }

                        containerAnimation && containerAnimation.seek(time);
                        return containerAnimation ? value : Math.round(value);
                    },
                    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
                    _reparent = function _reparent(element, parent, top, left) {
                        if (element.parentNode !== parent) {
                            var style = element.style,
                                p,
                                cs;

                            if (parent === ScrollTrigger_body) {
                                element._stOrig = style.cssText; // record original inline styles so we can revert them later

                                cs = _getComputedStyle(element);

                                for (p in cs) {
                                    // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
                                    if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
                                        style[p] = cs[p];
                                    }
                                }

                                style.top = top;
                                style.left = left;
                            } else {
                                style.cssText = element._stOrig;
                            }

                            ScrollTrigger_gsap.core.getCache(element).uncache = 1;
                            parent.appendChild(element);
                        }
                    },
                    _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
                        var last1 = initialValue,
                            last2 = last1;
                        return function(value) {
                            var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.

                            if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
                                // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
                                value = current;
                                onInterrupt && onInterrupt();
                            }

                            last2 = last1;
                            last1 = value;
                            return value;
                        };
                    },
                    _shiftMarker = function _shiftMarker(marker, direction, value) {
                        var vars = {};
                        vars[direction.p] = "+=" + value;
                        ScrollTrigger_gsap.set(marker, vars);
                    },
                    // _mergeAnimations = animations => {
                    // 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
                    // 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
                    // 	tl.smoothChildTiming = false;
                    // 	return tl;
                    // },
                    // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
                    _getTweenCreator = function _getTweenCreator(scroller, direction) {
                        var getScroll = _getScrollFunc(scroller, direction),
                            prop = "_scroll" + direction.p2,
                            // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
                            getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
                                var tween = getTween.tween,
                                    onComplete = vars.onComplete,
                                    modifiers = {};
                                initialValue = initialValue || getScroll();

                                var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {
                                    tween.kill();
                                    getTween.tween = 0;
                                });

                                change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

                                change1 = change1 || scrollTo - initialValue;
                                tween && tween.kill();
                                vars[prop] = scrollTo;
                                vars.inherit = false;
                                vars.modifiers = modifiers;

                                modifiers[prop] = function() {
                                    return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
                                };

                                vars.onUpdate = function() {
                                    _scrollers.cache++;
                                    getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()
                                };

                                vars.onComplete = function() {
                                    getTween.tween = 0;
                                    onComplete && onComplete.call(tween);
                                };

                                tween = getTween.tween = ScrollTrigger_gsap.to(scroller, vars);
                                return tween;
                            };

                        scroller[prop] = getScroll;

                        getScroll.wheelHandler = function() {
                            return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
                        };

                        ScrollTrigger_addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


                        ScrollTrigger_ScrollTrigger.isTouch && ScrollTrigger_addListener(scroller, "touchmove", getScroll.wheelHandler);
                        return getTween;
                    };

                var ScrollTrigger_ScrollTrigger = /*#__PURE__*/ function() {
                    function ScrollTrigger(vars, animation) {
                        ScrollTrigger_coreInitted || ScrollTrigger.register(ScrollTrigger_gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");

                        ScrollTrigger_context(this);

                        this.init(vars, animation);
                    }

                    var _proto = ScrollTrigger.prototype;

                    _proto.init = function init(vars, animation) {
                        this.progress = this.start = 0;
                        this.vars && this.kill(true, true); // in case it's being initted again

                        if (!_enabled) {
                            this.update = this.refresh = this.kill = _passThrough;
                            return;
                        }

                        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
                            trigger: vars
                        } : vars, _defaults);

                        var _vars = vars,
                            onUpdate = _vars.onUpdate,
                            toggleClass = _vars.toggleClass,
                            id = _vars.id,
                            onToggle = _vars.onToggle,
                            onRefresh = _vars.onRefresh,
                            scrub = _vars.scrub,
                            trigger = _vars.trigger,
                            pin = _vars.pin,
                            pinSpacing = _vars.pinSpacing,
                            invalidateOnRefresh = _vars.invalidateOnRefresh,
                            anticipatePin = _vars.anticipatePin,
                            onScrubComplete = _vars.onScrubComplete,
                            onSnapComplete = _vars.onSnapComplete,
                            once = _vars.once,
                            snap = _vars.snap,
                            pinReparent = _vars.pinReparent,
                            pinSpacer = _vars.pinSpacer,
                            containerAnimation = _vars.containerAnimation,
                            fastScrollEnd = _vars.fastScrollEnd,
                            preventOverlaps = _vars.preventOverlaps,
                            direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
                            isToggle = !scrub && scrub !== 0,
                            scroller = _getTarget(vars.scroller || ScrollTrigger_win),
                            scrollerCache = ScrollTrigger_gsap.core.getCache(scroller),
                            isViewport = ScrollTrigger_isViewport(scroller),
                            useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
                            callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
                            toggleActions = isToggle && vars.toggleActions.split(" "),
                            markers = "markers" in vars ? vars.markers : _defaults.markers,
                            borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
                            self = this,
                            onRefreshInit = vars.onRefreshInit && function() {
                                return vars.onRefreshInit(self);
                            },
                            getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
                            getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
                            lastSnap = 0,
                            lastRefresh = 0,
                            prevProgress = 0,
                            scrollFunc = _getScrollFunc(scroller, direction),
                            tweenTo,
                            pinCache,
                            snapFunc,
                            scroll1,
                            scroll2,
                            start,
                            end,
                            markerStart,
                            markerEnd,
                            markerStartTrigger,
                            markerEndTrigger,
                            markerVars,
                            executingOnRefresh,
                            change,
                            pinOriginalState,
                            pinActiveState,
                            pinState,
                            spacer,
                            offset,
                            pinGetter,
                            pinSetter,
                            pinStart,
                            pinChange,
                            spacingStart,
                            spacerState,
                            markerStartSetter,
                            pinMoves,
                            markerEndSetter,
                            cs,
                            snap1,
                            snap2,
                            scrubTween,
                            scrubSmooth,
                            snapDurClamp,
                            snapDelayedCall,
                            prevScroll,
                            prevAnimProgress,
                            caMarkerSetter,
                            customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start="clamp(top bottom)" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.


                        self._startClamp = self._endClamp = false;
                        self._dir = direction;
                        anticipatePin *= 45;
                        self.scroller = scroller;
                        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
                        scroll1 = scrollFunc();
                        self.vars = vars;
                        animation = animation || vars.animation;

                        if ("refreshPriority" in vars) {
                            _sort = 1;
                            vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
                        }

                        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
                            top: _getTweenCreator(scroller, _vertical),
                            left: _getTweenCreator(scroller, _horizontal)
                        };
                        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

                        self.scrubDuration = function(value) {
                            scrubSmooth = _isNumber(value) && value;

                            if (!scrubSmooth) {
                                scrubTween && scrubTween.progress(1).kill();
                                scrubTween = 0;
                            } else {
                                scrubTween ? scrubTween.duration(value) : scrubTween = ScrollTrigger_gsap.to(animation, {
                                    ease: "expo",
                                    totalProgress: "+=0",
                                    inherit: false,
                                    duration: scrubSmooth,
                                    paused: true,
                                    onComplete: function onComplete() {
                                        return onScrubComplete && onScrubComplete(self);
                                    }
                                });
                            }
                        };

                        if (animation) {
                            animation.vars.lazy = false;
                            animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010

                            self.animation = animation.pause();
                            animation.scrollTrigger = self;
                            self.scrubDuration(scrub);
                            snap1 = 0;
                            id || (id = animation.vars.id);
                        }

                        if (snap) {
                            // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.
                            if (!_isObject(snap) || snap.push) {
                                snap = {
                                    snapTo: snap
                                };
                            }

                            "scrollBehavior" in ScrollTrigger_body.style && ScrollTrigger_gsap.set(isViewport ? [ScrollTrigger_body, ScrollTrigger_docEl] : scroller, {
                                scrollBehavior: "auto"
                            }); // smooth scrolling doesn't work with snap.

                            _scrollers.forEach(function(o) {
                                return _isFunction(o) && o.target === (isViewport ? ScrollTrigger_doc.scrollingElement || ScrollTrigger_docEl : scroller) && (o.smooth = false);
                            }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters


                            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {
                                return _snapDirectional(snap.snapTo)(value, ScrollTrigger_getTime() - lastRefresh < 500 ? 0 : st.direction);
                            } : ScrollTrigger_gsap.utils.snap(snap.snapTo);
                            snapDurClamp = snap.duration || {
                                min: 0.1,
                                max: 2
                            };
                            snapDurClamp = _isObject(snapDurClamp) ? ScrollTrigger_clamp(snapDurClamp.min, snapDurClamp.max) : ScrollTrigger_clamp(snapDurClamp, snapDurClamp);
                            snapDelayedCall = ScrollTrigger_gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {
                                var scroll = scrollFunc(),
                                    refreshedRecently = ScrollTrigger_getTime() - lastRefresh < 500,
                                    tween = tweenTo.tween;

                                if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
                                    var progress = (scroll - start) / change,
                                        totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                                        velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (ScrollTrigger_getTime() - _time2) * 1000 || 0,
                                        change1 = ScrollTrigger_gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
                                        naturalEnd = progress + (snap.inertia === false ? 0 : change1),
                                        endValue,
                                        endScroll,
                                        _snap = snap,
                                        onStart = _snap.onStart,
                                        _onInterrupt = _snap.onInterrupt,
                                        _onComplete = _snap.onComplete;
                                    endValue = snapFunc(naturalEnd, self);
                                    _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd

                                    endScroll = Math.round(start + endValue * change);

                                    if (scroll <= end && scroll >= start && endScroll !== scroll) {
                                        if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                                            // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
                                            return;
                                        }

                                        if (snap.inertia === false) {
                                            change1 = endValue - progress;
                                        }

                                        tweenTo(endScroll, {
                                            duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                                            ease: snap.ease || "power3",
                                            data: _abs(endScroll - scroll),
                                            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                                            onInterrupt: function onInterrupt() {
                                                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                                            },
                                            onComplete: function onComplete() {
                                                self.update();
                                                lastSnap = scrollFunc();

                                                if (animation) {
                                                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap
                                                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                                                }

                                                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                                                onSnapComplete && onSnapComplete(self);
                                                _onComplete && _onComplete(self);
                                            }
                                        }, scroll, change1 * change, endScroll - scroll - change1 * change);
                                        onStart && onStart(self, tweenTo.tween);
                                    }
                                } else if (self.isActive && lastSnap !== scroll) {
                                    snapDelayedCall.restart(true);
                                }
                            }).pause();
                        }

                        id && (_ids[id] = self);
                        trigger = self.trigger = _getTarget(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

                        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
                        customRevertReturn && (customRevertReturn = customRevertReturn(self));
                        pin = pin === true ? trigger : _getTarget(pin);
                        _isString(toggleClass) && (toggleClass = {
                            targets: trigger,
                            className: toggleClass
                        });

                        if (pin) {
                            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)

                            self.pin = pin;
                            pinCache = ScrollTrigger_gsap.core.getCache(pin);

                            if (!pinCache.spacer) {
                                // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
                                if (pinSpacer) {
                                    pinSpacer = _getTarget(pinSpacer);
                                    pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

                                    pinCache.spacerIsNative = !!pinSpacer;
                                    pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
                                }

                                pinCache.spacer = spacer = pinSpacer || ScrollTrigger_doc.createElement("div");
                                spacer.classList.add("pin-spacer");
                                id && spacer.classList.add("pin-spacer-" + id);
                                pinCache.pinState = pinOriginalState = _getState(pin);
                            } else {
                                pinOriginalState = pinCache.pinState;
                            }

                            vars.force3D !== false && ScrollTrigger_gsap.set(pin, {
                                force3D: true
                            });
                            self.spacer = spacer = pinCache.spacer;
                            cs = _getComputedStyle(pin);
                            spacingStart = cs[pinSpacing + direction.os2];
                            pinGetter = ScrollTrigger_gsap.getProperty(pin);
                            pinSetter = ScrollTrigger_gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

                            _swapPinIn(pin, spacer, cs);

                            pinState = _getState(pin);
                        }

                        if (markers) {
                            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
                            markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
                            markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
                            offset = markerStartTrigger["offset" + direction.op.d2];

                            var content = _getTarget(_getProxyProp(scroller, "content") || scroller);

                            markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
                            markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
                            containerAnimation && (caMarkerSetter = ScrollTrigger_gsap.quickSetter([markerStart, markerEnd], direction.a, _px));

                            if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
                                _makePositionable(isViewport ? ScrollTrigger_body : scroller);

                                ScrollTrigger_gsap.set([markerStartTrigger, markerEndTrigger], {
                                    force3D: true
                                });
                                markerStartSetter = ScrollTrigger_gsap.quickSetter(markerStartTrigger, direction.a, _px);
                                markerEndSetter = ScrollTrigger_gsap.quickSetter(markerEndTrigger, direction.a, _px);
                            }
                        }

                        if (containerAnimation) {
                            var oldOnUpdate = containerAnimation.vars.onUpdate,
                                oldParams = containerAnimation.vars.onUpdateParams;
                            containerAnimation.eventCallback("onUpdate", function() {
                                self.update(0, 0, 1);
                                oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
                            });
                        }

                        self.previous = function() {
                            return _triggers[_triggers.indexOf(self) - 1];
                        };

                        self.next = function() {
                            return _triggers[_triggers.indexOf(self) + 1];
                        };

                        self.revert = function(revert, temp) {
                            if (!temp) {
                                return self.kill(true);
                            } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()


                            var r = revert !== false || !self.enabled,
                                prevRefreshing = _refreshing;

                            if (r !== self.isReverted) {
                                if (r) {
                                    prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

                                    prevProgress = self.progress;
                                    prevAnimProgress = animation && animation.progress();
                                }

                                markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
                                    return m.style.display = r ? "none" : "block";
                                });

                                if (r) {
                                    _refreshing = self;
                                    self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out
                                }

                                if (pin && (!pinReparent || !self.isActive)) {
                                    if (r) {
                                        _swapPinOut(pin, spacer, pinOriginalState);
                                    } else {
                                        _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
                                    }
                                }

                                r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.

                                _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.

                                self.isReverted = r;
                            }
                        };

                        self.refresh = function(soft, force, position, pinOffset) {
                            // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects
                            if ((_refreshing || !self.enabled) && !force) {
                                return;
                            }

                            if (pin && soft && _lastScrollTime) {
                                ScrollTrigger_addListener(ScrollTrigger, "scrollEnd", _softRefresh);

                                return;
                            }

                            !_refreshingAll && onRefreshInit && onRefreshInit(self);
                            _refreshing = self;

                            if (tweenTo.tween && !position) {
                                // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.
                                tweenTo.tween.kill();
                                tweenTo.tween = 0;
                            }

                            scrubTween && scrubTween.pause();
                            invalidateOnRefresh && animation && animation.revert({
                                kill: false
                            }).invalidate();
                            self.isReverted || self.revert(true, true);
                            self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any

                            var size = getScrollerSize(),
                                scrollerBounds = getScrollerOffsets(),
                                max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
                                isFirstRefresh = change <= 0.01,
                                offset = 0,
                                otherPinOffset = pinOffset || 0,
                                parsedEnd = _isObject(position) ? position.end : vars.end,
                                parsedEndTrigger = vars.endTrigger || trigger,
                                parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
                                pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self),
                                triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
                                i = triggerIndex,
                                cs,
                                bounds,
                                scroll,
                                isVertical,
                                override,
                                curTrigger,
                                curPin,
                                oppositeScroll,
                                initted,
                                revertedPins,
                                forcedOverflow,
                                markerStartOffset,
                                markerEndOffset;

                            if (markers && _isObject(position)) {
                                // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.
                                markerStartOffset = ScrollTrigger_gsap.getProperty(markerStartTrigger, direction.p);
                                markerEndOffset = ScrollTrigger_gsap.getProperty(markerEndTrigger, direction.p);
                            }

                            while (i--) {
                                // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
                                curTrigger = _triggers[i];
                                curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

                                curPin = curTrigger.pin;

                                if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
                                    revertedPins || (revertedPins = []);
                                    revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

                                    curTrigger.revert(true, true);
                                }

                                if (curTrigger !== _triggers[i]) {
                                    // in case it got removed.
                                    triggerIndex--;
                                    i--;
                                }
                            }

                            _isFunction(parsedStart) && (parsedStart = parsedStart(self));
                            parsedStart = _parseClamp(parsedStart, "start", self);
                            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -0.001 : 0);
                            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

                            if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
                                if (~parsedEnd.indexOf(" ")) {
                                    parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
                                } else {
                                    offset = _offsetToPx(parsedEnd.substr(2), size);
                                    parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? ScrollTrigger_gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

                                    parsedEndTrigger = trigger;
                                }
                            }

                            parsedEnd = _parseClamp(parsedEnd, "end", self);
                            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -0.001;
                            offset = 0;
                            i = triggerIndex;

                            while (i--) {
                                curTrigger = _triggers[i];
                                curPin = curTrigger.pin;

                                if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
                                    cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);

                                    if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
                                        // numeric start values shouldn't be offset at all - treat them as absolute
                                        offset += cs * (1 - curTrigger.progress);
                                    }

                                    curPin === pin && (otherPinOffset += cs);
                                }
                            }

                            start += offset;
                            end += offset;
                            self._startClamp && (self._startClamp += offset);

                            if (self._endClamp && !_refreshingAll) {
                                self._endClamp = end || -0.001;
                                end = Math.min(end, _maxScroll(scroller, direction));
                            }

                            change = end - start || (start -= 0.01) && 0.001;

                            if (isFirstRefresh) {
                                // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.
                                prevProgress = ScrollTrigger_gsap.utils.clamp(0, 1, ScrollTrigger_gsap.utils.normalize(start, end, prevScroll));
                            }

                            self._pinPush = otherPinOffset;

                            if (markerStart && offset) {
                                // offset the markers if necessary
                                cs = {};
                                cs[direction.a] = "+=" + offset;
                                pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
                                ScrollTrigger_gsap.set([markerStart, markerEnd], cs);
                            }

                            if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {
                                cs = _getComputedStyle(pin);
                                isVertical = direction === _vertical;
                                scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

                                pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;

                                if (!max && end > 1) {
                                    // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
                                    forcedOverflow = (isViewport ? ScrollTrigger_doc.scrollingElement || ScrollTrigger_docEl : scroller).style;
                                    forcedOverflow = {
                                        style: forcedOverflow,
                                        value: forcedOverflow["overflow" + direction.a.toUpperCase()]
                                    };

                                    if (isViewport && _getComputedStyle(ScrollTrigger_body)["overflow" + direction.a.toUpperCase()] !== "scroll") {
                                        // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to "scroll"
                                        forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
                                    }
                                }

                                _swapPinIn(pin, spacer, cs);

                                pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

                                bounds = _getBounds(pin, true);
                                oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

                                if (pinSpacing) {
                                    spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
                                    spacerState.t = spacer;
                                    i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;

                                    if (i) {
                                        spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

                                        spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
                                    }

                                    _setState(spacerState);

                                    if (pinnedContainer) {
                                        // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.
                                        _triggers.forEach(function(t) {
                                            if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                                                t._subPinOffset = true;
                                            }
                                        });
                                    }

                                    useFixedPosition && scrollFunc(prevScroll);
                                } else {
                                    i = _getSize(pin, direction);
                                    i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
                                }

                                if (useFixedPosition) {
                                    override = {
                                        top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                                        left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    };
                                    override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
                                    override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
                                    override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
                                    override[_padding] = cs[_padding];
                                    override[_padding + _Top] = cs[_padding + _Top];
                                    override[_padding + _Right] = cs[_padding + _Right];
                                    override[_padding + _Bottom] = cs[_padding + _Bottom];
                                    override[_padding + _Left] = cs[_padding + _Left];
                                    pinActiveState = _copyState(pinOriginalState, override, pinReparent);
                                    _refreshingAll && scrollFunc(0);
                                }

                                if (animation) {
                                    // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
                                    initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

                                    _suppressOverwrites(1);

                                    animation.render(animation.duration(), true, true);
                                    pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
                                    pinMoves = Math.abs(change - pinChange) > 1;
                                    useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

                                    animation.render(0, true, true);
                                    initted || animation.invalidate(true);
                                    animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.

                                    _suppressOverwrites(0);
                                } else {
                                    pinChange = change;
                                }

                                forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
                            } else if (trigger && scrollFunc() && !containerAnimation) {
                                // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
                                bounds = trigger.parentNode;

                                while (bounds && bounds !== ScrollTrigger_body) {
                                    if (bounds._pinOffset) {
                                        start -= bounds._pinOffset;
                                        end -= bounds._pinOffset;
                                    }

                                    bounds = bounds.parentNode;
                                }
                            }

                            revertedPins && revertedPins.forEach(function(t) {
                                return t.revert(false, true);
                            });
                            self.start = start;
                            self.end = end;
                            scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity

                            if (!containerAnimation && !_refreshingAll) {
                                scroll1 < prevScroll && scrollFunc(prevScroll);
                                self.scroll.rec = 0;
                            }

                            self.revert(false, true);
                            lastRefresh = ScrollTrigger_getTime();

                            if (snapDelayedCall) {
                                lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value
                                // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.

                                snapDelayedCall.restart(true);
                            }

                            _refreshing = 0;
                            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

                            if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh) {
                                // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
                                animation && !isToggle && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? ScrollTrigger_gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

                                self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
                            }

                            pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
                            scrubTween && scrubTween.invalidate();

                            if (!isNaN(markerStartOffset)) {
                                // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like "top", "center", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.
                                markerStartOffset -= ScrollTrigger_gsap.getProperty(markerStartTrigger, direction.p);
                                markerEndOffset -= ScrollTrigger_gsap.getProperty(markerEndTrigger, direction.p);

                                _shiftMarker(markerStartTrigger, direction, markerStartOffset);

                                _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));

                                _shiftMarker(markerEndTrigger, direction, markerEndOffset);

                                _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
                            }

                            isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a "scroll" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.

                            if (onRefresh && !_refreshingAll && !executingOnRefresh) {
                                // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.
                                executingOnRefresh = true;
                                onRefresh(self);
                                executingOnRefresh = false;
                            }
                        };

                        self.getVelocity = function() {
                            return (scrollFunc() - scroll2) / (ScrollTrigger_getTime() - _time2) * 1000 || 0;
                        };

                        self.endAnimation = function() {
                            _endAnimation(self.callbackAnimation);

                            if (animation) {
                                scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
                            }
                        };

                        self.labelToScroll = function(label) {
                            return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
                        };

                        self.getTrailing = function(name) {
                            var i = _triggers.indexOf(self),
                                a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

                            return (_isString(name) ? a.filter(function(t) {
                                return t.vars.preventOverlaps === name;
                            }) : a).filter(function(t) {
                                return self.direction > 0 ? t.end <= start : t.start >= end;
                            });
                        };

                        self.update = function(reset, recordVelocity, forceFake) {
                            if (containerAnimation && !forceFake && !reset) {
                                return;
                            }

                            var scroll = _refreshingAll === true ? prevScroll : self.scroll(),
                                p = reset ? 0 : (scroll - start) / change,
                                clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
                                prevProgress = self.progress,
                                isActive,
                                wasActive,
                                toggleState,
                                action,
                                stateChanged,
                                toggled,
                                isAtMax,
                                isTakingAction;

                            if (recordVelocity) {
                                scroll2 = scroll1;
                                scroll1 = containerAnimation ? scrollFunc() : scroll;

                                if (snap) {
                                    snap2 = snap1;
                                    snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
                                }
                            } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


                            if (anticipatePin && pin && !_refreshing && !ScrollTrigger_startup && _lastScrollTime) {
                                if (!clipped && start < scroll + (scroll - scroll2) / (ScrollTrigger_getTime() - _time2) * anticipatePin) {
                                    clipped = 0.0001;
                                } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (ScrollTrigger_getTime() - _time2) * anticipatePin) {
                                    clipped = 0.9999;
                                }
                            }

                            if (clipped !== prevProgress && self.enabled) {
                                isActive = self.isActive = !!clipped && clipped < 1;
                                wasActive = !!prevProgress && prevProgress < 1;
                                toggled = isActive !== wasActive;
                                stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

                                self.direction = clipped > prevProgress ? 1 : -1;
                                self.progress = clipped;

                                if (stateChanged && !_refreshing) {
                                    toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

                                    if (isToggle) {
                                        action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

                                        isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
                                    }
                                }

                                preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {
                                    return t.endAnimation();
                                }));

                                if (!isToggle) {
                                    if (scrubTween && !_refreshing && !ScrollTrigger_startup) {
                                        scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

                                        if (scrubTween.resetTo) {
                                            scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
                                        } else {
                                            // legacy support (courtesy), before 3.10.0
                                            scrubTween.vars.totalProgress = clipped;
                                            scrubTween.invalidate().restart();
                                        }
                                    } else if (animation) {
                                        animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
                                    }
                                }

                                if (pin) {
                                    reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

                                    if (!useFixedPosition) {
                                        pinSetter(_round(pinStart + pinChange * clipped));
                                    } else if (stateChanged) {
                                        isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

                                        if (pinReparent) {
                                            if (!reset && (isActive || isAtMax)) {
                                                var bounds = _getBounds(pin, true),
                                                    _offset = scroll - start;

                                                _reparent(pin, ScrollTrigger_body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                                            } else {
                                                _reparent(pin, spacer);
                                            }
                                        }

                                        _setState(isActive || isAtMax ? pinActiveState : pinState);

                                        pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
                                    }
                                }

                                snap && !tweenTo.tween && !_refreshing && !ScrollTrigger_startup && snapDelayedCall.restart(true);
                                toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {
                                    return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
                                }); // classes could affect positioning, so do it even if reset or refreshing is true.

                                onUpdate && !isToggle && !reset && onUpdate(self);

                                if (stateChanged && !_refreshing) {
                                    if (isToggle) {
                                        if (isTakingAction) {
                                            if (action === "complete") {
                                                animation.pause().totalProgress(1);
                                            } else if (action === "reset") {
                                                animation.restart(true).pause();
                                            } else if (action === "restart") {
                                                animation.restart(true);
                                            } else {
                                                animation[action]();
                                            }
                                        }

                                        onUpdate && onUpdate(self);
                                    }

                                    if (toggled || !_limitCallbacks) {
                                        // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
                                        onToggle && toggled && _callback(self, onToggle);
                                        callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                                        once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

                                        if (!toggled) {
                                            // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
                                            toggleState = clipped === 1 ? 1 : 3;
                                            callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                                        }
                                    }

                                    if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                                        _endAnimation(self.callbackAnimation);

                                        scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
                                    }
                                } else if (isToggle && onUpdate && !_refreshing) {
                                    onUpdate(self);
                                }
                            } // update absolutely-positioned markers (only if the scroller isn't the viewport)


                            if (markerEndSetter) {
                                var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
                                markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
                                markerEndSetter(n);
                            }

                            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
                        };

                        self.enable = function(reset, refresh) {
                            if (!self.enabled) {
                                self.enabled = true;

                                ScrollTrigger_addListener(scroller, "resize", _onResize);

                                isViewport || ScrollTrigger_addListener(scroller, "scroll", ScrollTrigger_onScroll);
                                onRefreshInit && ScrollTrigger_addListener(ScrollTrigger, "refreshInit", onRefreshInit);

                                if (reset !== false) {
                                    self.progress = prevProgress = 0;
                                    scroll1 = scroll2 = lastSnap = scrollFunc();
                                }

                                refresh !== false && self.refresh();
                            }
                        };

                        self.getTween = function(snap) {
                            return snap && tweenTo ? tweenTo.tween : scrubTween;
                        };

                        self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
                            // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
                            if (containerAnimation) {
                                // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.
                                var st = containerAnimation.scrollTrigger,
                                    duration = containerAnimation.duration(),
                                    _change = st.end - st.start;

                                newStart = st.start + _change * newStart / duration;
                                newEnd = st.start + _change * newEnd / duration;
                            }

                            self.refresh(false, false, {
                                start: _keepClamp(newStart, keepClamp && !!self._startClamp),
                                end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
                            }, pinOffset);
                            self.update();
                        };

                        self.adjustPinSpacing = function(amount) {
                            if (spacerState && amount) {
                                var i = spacerState.indexOf(direction.d) + 1;
                                spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
                                spacerState[1] = parseFloat(spacerState[1]) + amount + _px;

                                _setState(spacerState);
                            }
                        };

                        self.disable = function(reset, allowAnimation) {
                            if (self.enabled) {
                                reset !== false && self.revert(true, true);
                                self.enabled = self.isActive = false;
                                allowAnimation || scrubTween && scrubTween.pause();
                                prevScroll = 0;
                                pinCache && (pinCache.uncache = 1);
                                onRefreshInit && ScrollTrigger_removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

                                if (snapDelayedCall) {
                                    snapDelayedCall.pause();
                                    tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
                                }

                                if (!isViewport) {
                                    var i = _triggers.length;

                                    while (i--) {
                                        if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                                            return; //don't remove the listeners if there are still other triggers referencing it.
                                        }
                                    }

                                    ScrollTrigger_removeListener(scroller, "resize", _onResize);

                                    isViewport || ScrollTrigger_removeListener(scroller, "scroll", ScrollTrigger_onScroll);
                                }
                            }
                        };

                        self.kill = function(revert, allowAnimation) {
                            self.disable(revert, allowAnimation);
                            scrubTween && !allowAnimation && scrubTween.kill();
                            id && delete _ids[id];

                            var i = _triggers.indexOf(self);

                            i >= 0 && _triggers.splice(i, 1);
                            i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
                            // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

                            i = 0;

                            _triggers.forEach(function(t) {
                                return t.scroller === self.scroller && (i = 1);
                            });

                            i || _refreshingAll || (self.scroll.rec = 0);

                            if (animation) {
                                animation.scrollTrigger = null;
                                revert && animation.revert({
                                    kill: false
                                });
                                allowAnimation || animation.kill();
                            }

                            markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
                                return m.parentNode && m.parentNode.removeChild(m);
                            });
                            _primary === self && (_primary = 0);

                            if (pin) {
                                pinCache && (pinCache.uncache = 1);
                                i = 0;

                                _triggers.forEach(function(t) {
                                    return t.pin === pin && i++;
                                });

                                i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
                            }

                            vars.onKill && vars.onKill(self);
                        };

                        _triggers.push(self);

                        self.enable(false, false);
                        customRevertReturn && customRevertReturn(self);

                        if (animation && animation.add && !change) {
                            // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
                            var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().

                            self.update = function() {
                                self.update = updateFunc;
                                start || end || self.refresh();
                            };

                            ScrollTrigger_gsap.delayedCall(0.01, self.update);
                            change = 0.01;
                            start = end = 0;
                        } else {
                            self.refresh();
                        }

                        pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()
                    };

                    ScrollTrigger.register = function register(core) {
                        if (!ScrollTrigger_coreInitted) {
                            ScrollTrigger_gsap = core || ScrollTrigger_getGSAP();
                            _windowExists() && window.document && ScrollTrigger.enable();
                            ScrollTrigger_coreInitted = _enabled;
                        }

                        return ScrollTrigger_coreInitted;
                    };

                    ScrollTrigger.defaults = function defaults(config) {
                        if (config) {
                            for (var p in config) {
                                _defaults[p] = config[p];
                            }
                        }

                        return _defaults;
                    };

                    ScrollTrigger.disable = function disable(reset, kill) {
                        _enabled = 0;

                        _triggers.forEach(function(trigger) {
                            return trigger[kill ? "kill" : "disable"](reset);
                        });

                        ScrollTrigger_removeListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll);

                        ScrollTrigger_removeListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll);

                        clearInterval(_syncInterval);

                        ScrollTrigger_removeListener(ScrollTrigger_doc, "touchcancel", _passThrough);

                        ScrollTrigger_removeListener(ScrollTrigger_body, "touchstart", _passThrough);

                        _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

                        _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);

                        _resizeDelay.kill();

                        _iterateAutoRefresh(ScrollTrigger_removeListener);

                        for (var i = 0; i < _scrollers.length; i += 3) {
                            _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);

                            _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
                        }
                    };

                    ScrollTrigger.enable = function enable() {
                        ScrollTrigger_win = window;
                        ScrollTrigger_doc = document;
                        ScrollTrigger_docEl = ScrollTrigger_doc.documentElement;
                        ScrollTrigger_body = ScrollTrigger_doc.body;

                        if (ScrollTrigger_gsap) {
                            _toArray = ScrollTrigger_gsap.utils.toArray;
                            ScrollTrigger_clamp = ScrollTrigger_gsap.utils.clamp;
                            ScrollTrigger_context = ScrollTrigger_gsap.core.context || _passThrough;
                            _suppressOverwrites = ScrollTrigger_gsap.core.suppressOverwrites || _passThrough;
                            _scrollRestoration = ScrollTrigger_win.history.scrollRestoration || "auto";
                            _lastScroll = ScrollTrigger_win.pageYOffset;
                            ScrollTrigger_gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

                            if (ScrollTrigger_body) {
                                _enabled = 1;
                                _div100vh = document.createElement("div"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.

                                _div100vh.style.height = "100vh";
                                _div100vh.style.position = "absolute";

                                _refresh100vh();

                                _rafBugFix();

                                Observer.register(ScrollTrigger_gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

                                ScrollTrigger.isTouch = Observer.isTouch;
                                _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

                                _ignoreMobileResize = Observer.isTouch === 1;

                                ScrollTrigger_addListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll); // mostly for 3rd party smooth scrolling libraries.


                                ScrollTrigger_root = [ScrollTrigger_win, ScrollTrigger_doc, ScrollTrigger_docEl, ScrollTrigger_body];

                                if (ScrollTrigger_gsap.matchMedia) {
                                    ScrollTrigger.matchMedia = function(vars) {
                                        var mm = ScrollTrigger_gsap.matchMedia(),
                                            p;

                                        for (p in vars) {
                                            mm.add(p, vars[p]);
                                        }

                                        return mm;
                                    };

                                    ScrollTrigger_gsap.addEventListener("matchMediaInit", function() {
                                        return _revertAll();
                                    });
                                    ScrollTrigger_gsap.addEventListener("matchMediaRevert", function() {
                                        return _revertRecorded();
                                    });
                                    ScrollTrigger_gsap.addEventListener("matchMedia", function() {
                                        _refreshAll(0, 1);

                                        _dispatch("matchMedia");
                                    });
                                    ScrollTrigger_gsap.matchMedia("(orientation: portrait)", function() {
                                        // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
                                        _setBaseDimensions();

                                        return _setBaseDimensions;
                                    });
                                } else {
                                    console.warn("Requires GSAP 3.11.0 or later");
                                }

                                _setBaseDimensions();

                                ScrollTrigger_addListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


                                var bodyStyle = ScrollTrigger_body.style,
                                    border = bodyStyle.borderTopStyle,
                                    AnimationProto = ScrollTrigger_gsap.core.Animation.prototype,
                                    bounds,
                                    i;
                                AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
                                    value: function value() {
                                        return this.time(-0.01, true);
                                    }
                                }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)

                                bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

                                bounds = _getBounds(ScrollTrigger_body);
                                _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

                                _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
                                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.

                                _syncInterval = setInterval(_sync, 250);
                                ScrollTrigger_gsap.delayedCall(0.5, function() {
                                    return ScrollTrigger_startup = 0;
                                });

                                ScrollTrigger_addListener(ScrollTrigger_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


                                ScrollTrigger_addListener(ScrollTrigger_body, "touchstart", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


                                _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

                                _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);

                                _transformProp = ScrollTrigger_gsap.utils.checkPrefix("transform");

                                _stateProps.push(_transformProp);

                                ScrollTrigger_coreInitted = ScrollTrigger_getTime();
                                _resizeDelay = ScrollTrigger_gsap.delayedCall(0.2, _refreshAll).pause();
                                _autoRefresh = [ScrollTrigger_doc, "visibilitychange", function() {
                                    var w = ScrollTrigger_win.innerWidth,
                                        h = ScrollTrigger_win.innerHeight;

                                    if (ScrollTrigger_doc.hidden) {
                                        _prevWidth = w;
                                        _prevHeight = h;
                                    } else if (_prevWidth !== w || _prevHeight !== h) {
                                        _onResize();
                                    }
                                }, ScrollTrigger_doc, "DOMContentLoaded", _refreshAll, ScrollTrigger_win, "load", _refreshAll, ScrollTrigger_win, "resize", _onResize];

                                _iterateAutoRefresh(ScrollTrigger_addListener);

                                _triggers.forEach(function(trigger) {
                                    return trigger.enable(0, 1);
                                });

                                for (i = 0; i < _scrollers.length; i += 3) {
                                    _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);

                                    _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
                                }
                            }
                        }
                    };

                    ScrollTrigger.config = function config(vars) {
                        "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
                        var ms = vars.syncInterval;
                        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
                        "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

                        if ("autoRefreshEvents" in vars) {
                            _iterateAutoRefresh(ScrollTrigger_removeListener) || _iterateAutoRefresh(ScrollTrigger_addListener, vars.autoRefreshEvents || "none");
                            _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
                        }
                    };

                    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
                        var t = _getTarget(target),
                            i = _scrollers.indexOf(t),
                            isViewport = ScrollTrigger_isViewport(t);

                        if (~i) {
                            _scrollers.splice(i, isViewport ? 6 : 2);
                        }

                        if (vars) {
                            isViewport ? _proxies.unshift(ScrollTrigger_win, vars, ScrollTrigger_body, vars, ScrollTrigger_docEl, vars) : _proxies.unshift(t, vars);
                        }
                    };

                    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
                        _triggers.forEach(function(t) {
                            return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
                        });
                    };

                    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
                        var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),
                            offset = bounds[horizontal ? _width : _height] * ratio || 0;
                        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < ScrollTrigger_win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < ScrollTrigger_win.innerHeight;
                    };

                    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
                        _isString(element) && (element = _getTarget(element));
                        var bounds = element.getBoundingClientRect(),
                            size = bounds[horizontal ? _width : _height],
                            offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
                        return horizontal ? (bounds.left + offset) / ScrollTrigger_win.innerWidth : (bounds.top + offset) / ScrollTrigger_win.innerHeight;
                    };

                    ScrollTrigger.killAll = function killAll(allowListeners) {
                        _triggers.slice(0).forEach(function(t) {
                            return t.vars.id !== "ScrollSmoother" && t.kill();
                        });

                        if (allowListeners !== true) {
                            var listeners = _listeners.killAll || [];
                            _listeners = {};
                            listeners.forEach(function(f) {
                                return f();
                            });
                        }
                    };

                    return ScrollTrigger;
                }();
                ScrollTrigger_ScrollTrigger.version = "3.12.5";

                ScrollTrigger_ScrollTrigger.saveStyles = function(targets) {
                    return targets ? _toArray(targets).forEach(function(target) {
                        // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
                        if (target && target.style) {
                            var i = _savedStyles.indexOf(target);

                            i >= 0 && _savedStyles.splice(i, 5);

                            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), ScrollTrigger_gsap.core.getCache(target), ScrollTrigger_context());
                        }
                    }) : _savedStyles;
                };

                ScrollTrigger_ScrollTrigger.revert = function(soft, media) {
                    return _revertAll(!soft, media);
                };

                ScrollTrigger_ScrollTrigger.create = function(vars, animation) {
                    return new ScrollTrigger_ScrollTrigger(vars, animation);
                };

                ScrollTrigger_ScrollTrigger.refresh = function(safe) {
                    return safe ? _onResize() : (ScrollTrigger_coreInitted || ScrollTrigger_ScrollTrigger.register()) && _refreshAll(true);
                };

                ScrollTrigger_ScrollTrigger.update = function(force) {
                    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
                };

                ScrollTrigger_ScrollTrigger.clearScrollMemory = _clearScrollMemory;

                ScrollTrigger_ScrollTrigger.maxScroll = function(element, horizontal) {
                    return _maxScroll(element, horizontal ? _horizontal : _vertical);
                };

                ScrollTrigger_ScrollTrigger.getScrollFunc = function(element, horizontal) {
                    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
                };

                ScrollTrigger_ScrollTrigger.getById = function(id) {
                    return _ids[id];
                };

                ScrollTrigger_ScrollTrigger.getAll = function() {
                    return _triggers.filter(function(t) {
                        return t.vars.id !== "ScrollSmoother";
                    });
                }; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


                ScrollTrigger_ScrollTrigger.isScrolling = function() {
                    return !!_lastScrollTime;
                };

                ScrollTrigger_ScrollTrigger.snapDirectional = _snapDirectional;

                ScrollTrigger_ScrollTrigger.addEventListener = function(type, callback) {
                    var a = _listeners[type] || (_listeners[type] = []);
                    ~a.indexOf(callback) || a.push(callback);
                };

                ScrollTrigger_ScrollTrigger.removeEventListener = function(type, callback) {
                    var a = _listeners[type],
                        i = a && a.indexOf(callback);
                    i >= 0 && a.splice(i, 1);
                };

                ScrollTrigger_ScrollTrigger.batch = function(targets, vars) {
                    var result = [],
                        varsCopy = {},
                        interval = vars.interval || 0.016,
                        batchMax = vars.batchMax || 1e9,
                        proxyCallback = function proxyCallback(type, callback) {
                            var elements = [],
                                triggers = [],
                                delay = ScrollTrigger_gsap.delayedCall(interval, function() {
                                    callback(elements, triggers);
                                    elements = [];
                                    triggers = [];
                                }).pause();
                            return function(self) {
                                elements.length || delay.restart(true);
                                elements.push(self.trigger);
                                triggers.push(self);
                                batchMax <= elements.length && delay.progress(1);
                            };
                        },
                        p;

                    for (p in vars) {
                        varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
                    }

                    if (_isFunction(batchMax)) {
                        batchMax = batchMax();

                        ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "refresh", function() {
                            return batchMax = vars.batchMax();
                        });
                    }

                    _toArray(targets).forEach(function(target) {
                        var config = {};

                        for (p in varsCopy) {
                            config[p] = varsCopy[p];
                        }

                        config.trigger = target;
                        result.push(ScrollTrigger_ScrollTrigger.create(config));
                    });

                    return result;
                }; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


                var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
                        current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
                        return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
                    },
                    _allowNativePanning = function _allowNativePanning(target, direction) {
                        if (direction === true) {
                            target.style.removeProperty("touch-action");
                        } else {
                            target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
                        }

                        target === ScrollTrigger_docEl && _allowNativePanning(ScrollTrigger_body, direction);
                    },
                    _overflow = {
                        auto: 1,
                        scroll: 1
                    },
                    _nestedScroll = function _nestedScroll(_ref5) {
                        var event = _ref5.event,
                            target = _ref5.target,
                            axis = _ref5.axis;

                        var node = (event.changedTouches ? event.changedTouches[0] : event).target,
                            cache = node._gsap || ScrollTrigger_gsap.core.getCache(node),
                            time = ScrollTrigger_getTime(),
                            cs;

                        if (!cache._isScrollT || time - cache._isScrollT > 2000) {
                            // cache for 2 seconds to improve performance.
                            while (node && node !== ScrollTrigger_body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
                                node = node.parentNode;
                            }

                            cache._isScroll = node && node !== target && !ScrollTrigger_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
                            cache._isScrollT = time;
                        }

                        if (cache._isScroll || axis === "x") {
                            event.stopPropagation();
                            event._gsapAllow = true;
                        }
                    },
                    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
                    _inputObserver = function _inputObserver(target, type, inputs, nested) {
                        return Observer.create({
                            target: target,
                            capture: true,
                            debounce: false,
                            lockAxis: true,
                            type: type,
                            onWheel: nested = nested && _nestedScroll,
                            onPress: nested,
                            onDrag: nested,
                            onScroll: nested,
                            onEnable: function onEnable() {
                                return inputs && ScrollTrigger_addListener(ScrollTrigger_doc, Observer.eventTypes[0], _captureInputs, false, true);
                            },
                            onDisable: function onDisable() {
                                return ScrollTrigger_removeListener(ScrollTrigger_doc, Observer.eventTypes[0], _captureInputs, true);
                            }
                        });
                    },
                    _inputExp = /(input|label|select|textarea)/i,
                    _inputIsFocused,
                    _captureInputs = function _captureInputs(e) {
                        var isInput = _inputExp.test(e.target.tagName);

                        if (isInput || _inputIsFocused) {
                            e._gsapAllow = true;
                            _inputIsFocused = isInput;
                        }
                    },
                    _getScrollNormalizer = function _getScrollNormalizer(vars) {
                        _isObject(vars) || (vars = {});
                        vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
                        vars.type || (vars.type = "wheel,touch");
                        vars.debounce = !!vars.debounce;
                        vars.id = vars.id || "normalizer";

                        var _vars2 = vars,
                            normalizeScrollX = _vars2.normalizeScrollX,
                            momentum = _vars2.momentum,
                            allowNestedScroll = _vars2.allowNestedScroll,
                            onRelease = _vars2.onRelease,
                            self,
                            maxY,
                            target = _getTarget(vars.target) || ScrollTrigger_docEl,
                            smoother = ScrollTrigger_gsap.core.globals().ScrollSmoother,
                            smootherInstance = smoother && smoother.get(),
                            content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
                            scrollFuncY = _getScrollFunc(target, _vertical),
                            scrollFuncX = _getScrollFunc(target, _horizontal),
                            scale = 1,
                            initialScale = (Observer.isTouch && ScrollTrigger_win.visualViewport ? ScrollTrigger_win.visualViewport.scale * ScrollTrigger_win.visualViewport.width : ScrollTrigger_win.outerWidth) / ScrollTrigger_win.innerWidth,
                            wheelRefresh = 0,
                            resolveMomentumDuration = _isFunction(momentum) ? function() {
                                return momentum(self);
                            } : function() {
                                return momentum || 2.8;
                            },
                            lastRefreshID,
                            skipTouchMove,
                            inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
                            resumeTouchMove = function resumeTouchMove() {
                                return skipTouchMove = false;
                            },
                            scrollClampX = _passThrough,
                            scrollClampY = _passThrough,
                            updateClamps = function updateClamps() {
                                maxY = _maxScroll(target, _vertical);
                                scrollClampY = ScrollTrigger_clamp(_fixIOSBug ? 1 : 0, maxY);
                                normalizeScrollX && (scrollClampX = ScrollTrigger_clamp(0, _maxScroll(target, _horizontal)));
                                lastRefreshID = _refreshID;
                            },
                            removeContentOffset = function removeContentOffset() {
                                content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
                                content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
                                scrollFuncY.offset = scrollFuncY.cacheID = 0;
                            },
                            ignoreDrag = function ignoreDrag() {
                                if (skipTouchMove) {
                                    requestAnimationFrame(resumeTouchMove);

                                    var offset = _round(self.deltaY / 2),
                                        scroll = scrollClampY(scrollFuncY.v - offset);

                                    if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
                                        scrollFuncY.offset = scroll - scrollFuncY.v;

                                        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);

                                        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
                                        content._gsap.y = y + "px";
                                        scrollFuncY.cacheID = _scrollers.cache;

                                        _updateAll();
                                    }

                                    return true;
                                }

                                scrollFuncY.offset && removeContentOffset();
                                skipTouchMove = true;
                            },
                            tween,
                            startScrollX,
                            startScrollY,
                            onStopDelayedCall,
                            onResize = function onResize() {
                                // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
                                updateClamps();

                                if (tween.isActive() && tween.vars.scrollY > maxY) {
                                    scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
                                }
                            };

                        content && ScrollTrigger_gsap.set(content, {
                            y: "+=0"
                        }); // to ensure there's a cache (element._gsap)

                        vars.ignoreCheck = function(e) {
                            return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
                        };

                        vars.onPress = function() {
                            skipTouchMove = false;
                            var prevScale = scale;
                            scale = _round((ScrollTrigger_win.visualViewport && ScrollTrigger_win.visualViewport.scale || 1) / initialScale);
                            tween.pause();
                            prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
                            startScrollX = scrollFuncX();
                            startScrollY = scrollFuncY();
                            updateClamps();
                            lastRefreshID = _refreshID;
                        };

                        vars.onRelease = vars.onGestureStart = function(self, wasDragging) {
                            scrollFuncY.offset && removeContentOffset();

                            if (!wasDragging) {
                                onStopDelayedCall.restart(true);
                            } else {
                                _scrollers.cache++; // make sure we're pulling the non-cached value
                                // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

                                var dur = resolveMomentumDuration(),
                                    currentScroll,
                                    endScroll;

                                if (normalizeScrollX) {
                                    currentScroll = scrollFuncX();
                                    endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

                                    dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
                                    tween.vars.scrollX = scrollClampX(endScroll);
                                }

                                currentScroll = scrollFuncY();
                                endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

                                dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
                                tween.vars.scrollY = scrollClampY(endScroll);
                                tween.invalidate().duration(dur).play(0.01);

                                if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
                                    // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
                                    ScrollTrigger_gsap.to({}, {
                                        onUpdate: onResize,
                                        duration: dur
                                    });
                                }
                            }

                            onRelease && onRelease(self);
                        };

                        vars.onWheel = function() {
                            tween._ts && tween.pause();

                            if (ScrollTrigger_getTime() - wheelRefresh > 1000) {
                                // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
                                lastRefreshID = 0;
                                wheelRefresh = ScrollTrigger_getTime();
                            }
                        };

                        vars.onChange = function(self, dx, dy, xArray, yArray) {
                            _refreshID !== lastRefreshID && updateClamps();
                            dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

                            if (dy) {
                                scrollFuncY.offset && removeContentOffset();
                                var isTouch = yArray[2] === dy,
                                    y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
                                    yClamped = scrollClampY(y);
                                isTouch && y !== yClamped && (startScrollY += yClamped - y);
                                scrollFuncY(yClamped);
                            }

                            (dy || dx) && _updateAll();
                        };

                        vars.onEnable = function() {
                            _allowNativePanning(target, normalizeScrollX ? false : "x");

                            ScrollTrigger_ScrollTrigger.addEventListener("refresh", onResize);

                            ScrollTrigger_addListener(ScrollTrigger_win, "resize", onResize);

                            if (scrollFuncY.smooth) {
                                scrollFuncY.target.style.scrollBehavior = "auto";
                                scrollFuncY.smooth = scrollFuncX.smooth = false;
                            }

                            inputObserver.enable();
                        };

                        vars.onDisable = function() {
                            _allowNativePanning(target, true);

                            ScrollTrigger_removeListener(ScrollTrigger_win, "resize", onResize);

                            ScrollTrigger_ScrollTrigger.removeEventListener("refresh", onResize);
                            inputObserver.kill();
                        };

                        vars.lockAxis = vars.lockAxis !== false;
                        self = new Observer(vars);
                        self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

                        _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

                        _fixIOSBug && ScrollTrigger_gsap.ticker.add(_passThrough); // prevent the ticker from sleeping

                        onStopDelayedCall = self._dc;
                        tween = ScrollTrigger_gsap.to(self, {
                            ease: "power4",
                            paused: true,
                            inherit: false,
                            scrollX: normalizeScrollX ? "+=0.1" : "+=0",
                            scrollY: "+=0.1",
                            modifiers: {
                                scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {
                                    return tween.pause();
                                })
                            },
                            onUpdate: _updateAll,
                            onComplete: onStopDelayedCall.vars.onComplete
                        }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.

                        return self;
                    };

                ScrollTrigger_ScrollTrigger.sort = function(func) {
                    return _triggers.sort(func || function(a, b) {
                        return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
                    });
                };

                ScrollTrigger_ScrollTrigger.observe = function(vars) {
                    return new Observer(vars);
                };

                ScrollTrigger_ScrollTrigger.normalizeScroll = function(vars) {
                    if (typeof vars === "undefined") {
                        return ScrollTrigger_normalizer;
                    }

                    if (vars === true && ScrollTrigger_normalizer) {
                        return ScrollTrigger_normalizer.enable();
                    }

                    if (vars === false) {
                        ScrollTrigger_normalizer && ScrollTrigger_normalizer.kill();
                        ScrollTrigger_normalizer = vars;
                        return;
                    }

                    var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
                    ScrollTrigger_normalizer && ScrollTrigger_normalizer.target === normalizer.target && ScrollTrigger_normalizer.kill();
                    ScrollTrigger_isViewport(normalizer.target) && (ScrollTrigger_normalizer = normalizer);
                    return normalizer;
                };

                ScrollTrigger_ScrollTrigger.core = {
                    // smaller file size way to leverage in ScrollSmoother and Observer
                    _getVelocityProp: _getVelocityProp,
                    _inputObserver: _inputObserver,
                    _scrollers: _scrollers,
                    _proxies: _proxies,
                    bridge: {
                        // when normalizeScroll sets the scroll position (ss = setScroll)
                        ss: function ss() {
                            _lastScrollTime || _dispatch("scrollStart");
                            _lastScrollTime = ScrollTrigger_getTime();
                        },
                        // a way to get the _refreshing value in Observer
                        ref: function ref() {
                            return _refreshing;
                        }
                    }
                };
                ScrollTrigger_getGSAP() && ScrollTrigger_gsap.registerPlugin(ScrollTrigger_ScrollTrigger);


                /***/
            }),

        /***/
        "fXHe":
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "p8": () => ( /* binding */ gsapWithCSS)
                });

                // UNUSED EXPORTS: Back, Bounce, CSSPlugin, Circ, Cubic, Elastic, Expo, Linear, Power0, Power1, Power2, Power3, Power4, Quad, Quart, Quint, Sine, SteppedEase, Strong, TimelineLite, TimelineMax, TweenLite, TweenMax, default

                // EXTERNAL MODULE: ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js
                var gsap_core = __webpack_require__("IedM");; // CONCATENATED MODULE: ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js
                /*!
                 * CSSPlugin 3.12.5
                 * https://gsap.com
                 *
                 * Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */

                /* eslint-disable */


                var _win,
                    _doc,
                    _docElement,
                    _pluginInitted,
                    _tempDiv,
                    _tempDivStyler,
                    _recentSetterPlugin,
                    _reverting,
                    _windowExists = function _windowExists() {
                        return "object" !== "undefined";
                    },
                    _transformProps = {},
                    _RAD2DEG = 180 / Math.PI,
                    _DEG2RAD = Math.PI / 180,
                    _atan2 = Math.atan2,
                    _bigNum = 1e8,
                    _capsExp = /([A-Z])/g,
                    _horizontalExp = /(left|right|width|margin|padding|x)/i,
                    _complexExp = /[\s,\(]\S/,
                    _propertyAliases = {
                        autoAlpha: "opacity,visibility",
                        scale: "scaleX,scaleY",
                        alpha: "opacity"
                    },
                    _renderCSSProp = function _renderCSSProp(ratio, data) {
                        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
                    },
                    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
                        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
                    },
                    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
                        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
                    },
                    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
                    _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
                        var value = data.s + data.c * ratio;
                        data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
                    },
                    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
                        return data.set(data.t, data.p, ratio ? data.e : data.b, data);
                    },
                    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
                        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
                    },
                    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
                        return target.style[property] = value;
                    },
                    _setterCSSProp = function _setterCSSProp(target, property, value) {
                        return target.style.setProperty(property, value);
                    },
                    _setterTransform = function _setterTransform(target, property, value) {
                        return target._gsap[property] = value;
                    },
                    _setterScale = function _setterScale(target, property, value) {
                        return target._gsap.scaleX = target._gsap.scaleY = value;
                    },
                    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache.scaleX = cache.scaleY = value;
                        cache.renderTransform(ratio, cache);
                    },
                    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache[property] = value;
                        cache.renderTransform(ratio, cache);
                    },
                    _transformProp = "transform",
                    _transformOriginProp = _transformProp + "Origin",
                    _saveStyle = function _saveStyle(property, isNotCSS) {
                        var _this = this;

                        var target = this.target,
                            style = target.style,
                            cache = target._gsap;

                        if (property in _transformProps && style) {
                            this.tfm = this.tfm || {};

                            if (property !== "transform") {
                                property = _propertyAliases[property] || property;
                                ~property.indexOf(",") ? property.split(",").forEach(function(a) {
                                    return _this.tfm[a] = _get(target, a);
                                }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.

                                property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
                            } else {
                                return _propertyAliases.transform.split(",").forEach(function(p) {
                                    return _saveStyle.call(_this, p, isNotCSS);
                                });
                            }

                            if (this.props.indexOf(_transformProp) >= 0) {
                                return;
                            }

                            if (cache.svg) {
                                this.svgo = target.getAttribute("data-svg-origin");
                                this.props.push(_transformOriginProp, isNotCSS, "");
                            }

                            property = _transformProp;
                        }

                        (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
                    },
                    _removeIndependentTransforms = function _removeIndependentTransforms(style) {
                        if (style.translate) {
                            style.removeProperty("translate");
                            style.removeProperty("scale");
                            style.removeProperty("rotate");
                        }
                    },
                    _revertStyle = function _revertStyle() {
                        var props = this.props,
                            target = this.target,
                            style = target.style,
                            cache = target._gsap,
                            i,
                            p;

                        for (i = 0; i < props.length; i += 3) {
                            // stored like this: property, isNotCSS, value
                            props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
                        }

                        if (this.tfm) {
                            for (p in this.tfm) {
                                cache[p] = this.tfm[p];
                            }

                            if (cache.svg) {
                                cache.renderTransform();
                                target.setAttribute("data-svg-origin", this.svgo || "");
                            }

                            i = _reverting();

                            if ((!i || !i.isStart) && !style[_transformProp]) {
                                _removeIndependentTransforms(style);

                                if (cache.zOrigin && style[_transformOriginProp]) {
                                    style[_transformOriginProp] += " " + cache.zOrigin + "px"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.

                                    cache.zOrigin = 0;
                                    cache.renderTransform();
                                }

                                cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
                            }
                        }
                    },
                    _getStyleSaver = function _getStyleSaver(target, properties) {
                        var saver = {
                            target: target,
                            props: [],
                            revert: _revertStyle,
                            save: _saveStyle
                        };
                        target._gsap || gsap_core /* gsap.core.getCache */ .p8.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.

                        properties && properties.split(",").forEach(function(p) {
                            return saver.save(p);
                        });
                        return saver;
                    },
                    _supports3D,
                    _createElement = function _createElement(type, ns) {
                        var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

                        return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
                    },
                    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
                        var cs = getComputedStyle(target);
                        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
                    },
                    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
                    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
                        var e = element || _tempDiv,
                            s = e.style,
                            i = 5;

                        if (property in s && !preferPrefix) {
                            return property;
                        }

                        property = property.charAt(0).toUpperCase() + property.substr(1);

                        while (i-- && !(_prefixes[i] + property in s)) {}

                        return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
                    },
                    _initCore = function _initCore() {
                        if (_windowExists() && window.document) {
                            _win = window;
                            _doc = _win.document;
                            _docElement = _doc.documentElement;
                            _tempDiv = _createElement("div") || {
                                style: {}
                            };
                            _tempDivStyler = _createElement("div");
                            _transformProp = _checkPropPrefix(_transformProp);
                            _transformOriginProp = _transformProp + "Origin";
                            _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

                            _supports3D = !!_checkPropPrefix("perspective");
                            _reverting = gsap_core /* gsap.core.reverting */ .p8.core.reverting;
                            _pluginInitted = 1;
                        }
                    },
                    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
                        //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
                        var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            oldParent = this.parentNode,
                            oldSibling = this.nextSibling,
                            oldCSS = this.style.cssText,
                            bbox;

                        _docElement.appendChild(svg);

                        svg.appendChild(this);
                        this.style.display = "block";

                        if (swapIfPossible) {
                            try {
                                bbox = this.getBBox();
                                this._gsapBBox = this.getBBox; //store the original

                                this.getBBox = _getBBoxHack;
                            } catch (e) {}
                        } else if (this._gsapBBox) {
                            bbox = this._gsapBBox();
                        }

                        if (oldParent) {
                            if (oldSibling) {
                                oldParent.insertBefore(this, oldSibling);
                            } else {
                                oldParent.appendChild(this);
                            }
                        }

                        _docElement.removeChild(svg);

                        this.style.cssText = oldCSS;
                        return bbox;
                    },
                    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
                        var i = attributesArray.length;

                        while (i--) {
                            if (target.hasAttribute(attributesArray[i])) {
                                return target.getAttribute(attributesArray[i]);
                            }
                        }
                    },
                    _getBBox = function _getBBox(target) {
                        var bounds;

                        try {
                            bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
                        } catch (error) {
                            bounds = _getBBoxHack.call(target, true);
                        }

                        bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

                        return bounds && !bounds.width && !bounds.x && !bounds.y ? {
                            x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
                            y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
                            width: 0,
                            height: 0
                        } : bounds;
                    },
                    _isSVG = function _isSVG(e) {
                        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
                    },
                    //reports if the element is an SVG on which getBBox() actually works
                    _removeProperty = function _removeProperty(target, property) {
                        if (property) {
                            var style = target.style,
                                first2Chars;

                            if (property in _transformProps && property !== _transformOriginProp) {
                                property = _transformProp;
                            }

                            if (style.removeProperty) {
                                first2Chars = property.substr(0, 2);

                                if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
                                    //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
                                    property = "-" + property;
                                }

                                style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
                            } else {
                                //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
                                style.removeAttribute(property);
                            }
                        }
                    },
                    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
                        var pt = new gsap_core /* PropTween */ .Fo(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
                        plugin._pt = pt;
                        pt.b = beginning;
                        pt.e = end;

                        plugin._props.push(property);

                        return pt;
                    },
                    _nonConvertibleUnits = {
                        deg: 1,
                        rad: 1,
                        turn: 1
                    },
                    _nonStandardLayouts = {
                        grid: 1,
                        flex: 1
                    },
                    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
                    _convertToUnit = function _convertToUnit(target, property, value, unit) {
                        var curValue = parseFloat(value) || 0,
                            curUnit = (value + "").trim().substr((curValue + "").length) || "px",
                            // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
                            style = _tempDiv.style,
                            horizontal = _horizontalExp.test(property),
                            isRootSVG = target.tagName.toLowerCase() === "svg",
                            measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
                            amount = 100,
                            toPixels = unit === "px",
                            toPercent = unit === "%",
                            px,
                            parent,
                            cache,
                            isSVG;

                        if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
                            return curValue;
                        }

                        curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
                        isSVG = target.getCTM && _isSVG(target);

                        if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
                            px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
                            return (0, gsap_core /* _round */ .Pr)(toPercent ? curValue / px * amount : curValue / 100 * px);
                        }

                        style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
                        parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

                        if (isSVG) {
                            parent = (target.ownerSVGElement || {}).parentNode;
                        }

                        if (!parent || parent === _doc || !parent.appendChild) {
                            parent = _doc.body;
                        }

                        cache = parent._gsap;

                        if (cache && toPercent && cache.width && horizontal && cache.time === gsap_core /* _ticker.time */ .xr.time && !cache.uncache) {
                            return (0, gsap_core /* _round */ .Pr)(curValue / cache.width * amount);
                        } else {
                            if (toPercent && (property === "height" || property === "width")) {
                                // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.
                                var v = target.style[property];
                                target.style[property] = amount + unit;
                                px = target[measureProperty];
                                v ? target.style[property] = v : _removeProperty(target, property);
                            } else {
                                (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
                                parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

                                parent.appendChild(_tempDiv);
                                px = _tempDiv[measureProperty];
                                parent.removeChild(_tempDiv);
                                style.position = "absolute";
                            }

                            if (horizontal && toPercent) {
                                cache = (0, gsap_core /* _getCache */ .DY)(parent);
                                cache.time = gsap_core /* _ticker.time */ .xr.time;
                                cache.width = parent[measureProperty];
                            }
                        }

                        return (0, gsap_core /* _round */ .Pr)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
                    },
                    _get = function _get(target, property, unit, uncache) {
                        var value;
                        _pluginInitted || _initCore();

                        if (property in _propertyAliases && property !== "transform") {
                            property = _propertyAliases[property];

                            if (~property.indexOf(",")) {
                                property = property.split(",")[0];
                            }
                        }

                        if (_transformProps[property] && property !== "transform") {
                            value = _parseTransform(target, uncache);
                            value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
                        } else {
                            value = target.style[property];

                            if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
                                value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, gsap_core /* _getProperty */ .Ok)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
                            }
                        }

                        return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
                    },
                    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
                        // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
                        if (!start || start === "none") {
                            // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/
                            var p = _checkPropPrefix(prop, target, 1),
                                s = p && _getComputedProperty(target, p, 1);

                            if (s && s !== start) {
                                prop = p;
                                start = s;
                            } else if (prop === "borderColor") {
                                start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
                            }
                        }

                        var pt = new gsap_core /* PropTween */ .Fo(this._pt, target.style, prop, 0, 1, gsap_core /* _renderComplexString */ .Ks),
                            index = 0,
                            matchIndex = 0,
                            a,
                            result,
                            startValues,
                            startNum,
                            color,
                            startValue,
                            endValue,
                            endNum,
                            chunk,
                            endUnit,
                            startUnit,
                            endValues;
                        pt.b = start;
                        pt.e = end;
                        start += ""; // ensure values are strings

                        end += "";

                        if (end === "auto") {
                            startValue = target.style[prop];
                            target.style[prop] = end;
                            end = _getComputedProperty(target, prop) || end;
                            startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
                        }

                        a = [start, end];

                        (0, gsap_core /* _colorStringFilter */ .kr)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


                        start = a[0];
                        end = a[1];
                        startValues = start.match(gsap_core /* _numWithUnitExp */ .d4) || [];
                        endValues = end.match(gsap_core /* _numWithUnitExp */ .d4) || [];

                        if (endValues.length) {
                            while (result = gsap_core /* _numWithUnitExp.exec */ .d4.exec(end)) {
                                endValue = result[0];
                                chunk = end.substring(index, result.index);

                                if (color) {
                                    color = (color + 1) % 5;
                                } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
                                    color = 1;
                                }

                                if (endValue !== (startValue = startValues[matchIndex++] || "")) {
                                    startNum = parseFloat(startValue) || 0;
                                    startUnit = startValue.substr((startNum + "").length);
                                    endValue.charAt(1) === "=" && (endValue = (0, gsap_core /* _parseRelative */ .cy)(startNum, endValue) + startUnit);
                                    endNum = parseFloat(endValue);
                                    endUnit = endValue.substr((endNum + "").length);
                                    index = gsap_core /* _numWithUnitExp.lastIndex */ .d4.lastIndex - endUnit.length;

                                    if (!endUnit) {
                                        //if something like "perspective:300" is passed in and we must add a unit to the end
                                        endUnit = endUnit || gsap_core /* _config.units */ .Fc.units[prop] || startUnit;

                                        if (index === end.length) {
                                            end += endUnit;
                                            pt.e += endUnit;
                                        }
                                    }

                                    if (startUnit !== endUnit) {
                                        startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
                                    } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


                                    pt._pt = {
                                        _next: pt._pt,
                                        p: chunk || matchIndex === 1 ? chunk : ",",
                                        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
                                        s: startNum,
                                        c: endNum - startNum,
                                        m: color && color < 4 || prop === "zIndex" ? Math.round : 0
                                    };
                                }
                            }

                            pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
                        } else {
                            pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
                        }

                        gsap_core /* _relExp.test */ .bQ.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

                        this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

                        return pt;
                    },
                    _keywordToPercent = {
                        top: "0%",
                        bottom: "100%",
                        left: "0%",
                        right: "100%",
                        center: "50%"
                    },
                    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
                        var split = value.split(" "),
                            x = split[0],
                            y = split[1] || "50%";

                        if (x === "top" || x === "bottom" || y === "left" || y === "right") {
                            //the user provided them in the wrong order, so flip them
                            value = x;
                            x = y;
                            y = value;
                        }

                        split[0] = _keywordToPercent[x] || x;
                        split[1] = _keywordToPercent[y] || y;
                        return split.join(" ");
                    },
                    _renderClearProps = function _renderClearProps(ratio, data) {
                        if (data.tween && data.tween._time === data.tween._dur) {
                            var target = data.t,
                                style = target.style,
                                props = data.u,
                                cache = target._gsap,
                                prop,
                                clearTransforms,
                                i;

                            if (props === "all" || props === true) {
                                style.cssText = "";
                                clearTransforms = 1;
                            } else {
                                props = props.split(",");
                                i = props.length;

                                while (--i > -1) {
                                    prop = props[i];

                                    if (_transformProps[prop]) {
                                        clearTransforms = 1;
                                        prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
                                    }

                                    _removeProperty(target, prop);
                                }
                            }

                            if (clearTransforms) {
                                _removeProperty(target, _transformProp);

                                if (cache) {
                                    cache.svg && target.removeAttribute("transform");

                                    _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


                                    cache.uncache = 1;

                                    _removeIndependentTransforms(style);
                                }
                            }
                        }
                    },
                    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
                    _specialProps = {
                        clearProps: function clearProps(plugin, target, property, endValue, tween) {
                            if (tween.data !== "isFromStart") {
                                var pt = plugin._pt = new gsap_core /* PropTween */ .Fo(plugin._pt, target, property, 0, 0, _renderClearProps);
                                pt.u = endValue;
                                pt.pr = -10;
                                pt.tween = tween;

                                plugin._props.push(property);

                                return 1;
                            }
                        }
                        /* className feature (about 0.4kb gzipped).
                        , className(plugin, target, property, endValue, tween) {
                        	let _renderClassName = (ratio, data) => {
                        			data.css.render(ratio, data.css);
                        			if (!ratio || ratio === 1) {
                        				let inline = data.rmv,
                        					target = data.t,
                        					p;
                        				target.setAttribute("class", ratio ? data.e : data.b);
                        				for (p in inline) {
                        					_removeProperty(target, p);
                        				}
                        			}
                        		},
                        		_getAllStyles = (target) => {
                        			let styles = {},
                        				computed = getComputedStyle(target),
                        				p;
                        			for (p in computed) {
                        				if (isNaN(p) && p !== "cssText" && p !== "length") {
                        					styles[p] = computed[p];
                        				}
                        			}
                        			_setDefaults(styles, _parseTransform(target, 1));
                        			return styles;
                        		},
                        		startClassList = target.getAttribute("class"),
                        		style = target.style,
                        		cssText = style.cssText,
                        		cache = target._gsap,
                        		classPT = cache.classPT,
                        		inlineToRemoveAtEnd = {},
                        		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
                        		changingVars = {},
                        		startVars = _getAllStyles(target),
                        		transformRelated = /(transform|perspective)/i,
                        		endVars, p;
                        	if (classPT) {
                        		classPT.r(1, classPT.d);
                        		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
                        	}
                        	target.setAttribute("class", data.e);
                        	endVars = _getAllStyles(target, true);
                        	target.setAttribute("class", startClassList);
                        	for (p in endVars) {
                        		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
                        			changingVars[p] = endVars[p];
                        			if (!style[p] && style[p] !== "0") {
                        				inlineToRemoveAtEnd[p] = 1;
                        			}
                        		}
                        	}
                        	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
                        	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
                        		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
                        	}
                        	_parseTransform(target, true); //to clear the caching of transforms
                        	data.css = new gsap.plugins.css();
                        	data.css.init(target, changingVars, tween);
                        	plugin._props.push(...data.css._props);
                        	return 1;
                        }
                        */

                    },

                    /*
                     * --------------------------------------------------------------------------------------
                     * TRANSFORMS
                     * --------------------------------------------------------------------------------------
                     */
                    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
                    _rotationalProperties = {},
                    _isNullTransform = function _isNullTransform(value) {
                        return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
                    },
                    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
                        var matrixString = _getComputedProperty(target, _transformProp);

                        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(gsap_core /* _numExp */ .SI).map(gsap_core /* _round */ .Pr);
                    },
                    _getMatrix = function _getMatrix(target, force2D) {
                        var cache = target._gsap || (0, gsap_core /* _getCache */ .DY)(target),
                            style = target.style,
                            matrix = _getComputedTransformMatrixAsArray(target),
                            parent,
                            nextSibling,
                            temp,
                            addedToDOM;

                        if (cache.svg && target.getAttribute("transform")) {
                            temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

                            matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
                            return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
                        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
                            //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
                            //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
                            temp = style.display;
                            style.display = "block";
                            parent = target.parentNode;

                            if (!parent || !target.offsetParent) {
                                // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
                                addedToDOM = 1; //flag

                                nextSibling = target.nextElementSibling;

                                _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

                            }

                            matrix = _getComputedTransformMatrixAsArray(target);
                            temp ? style.display = temp : _removeProperty(target, "display");

                            if (addedToDOM) {
                                nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
                            }
                        }

                        return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
                    },
                    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
                        var cache = target._gsap,
                            matrix = matrixArray || _getMatrix(target, true),
                            xOriginOld = cache.xOrigin || 0,
                            yOriginOld = cache.yOrigin || 0,
                            xOffsetOld = cache.xOffset || 0,
                            yOffsetOld = cache.yOffset || 0,
                            a = matrix[0],
                            b = matrix[1],
                            c = matrix[2],
                            d = matrix[3],
                            tx = matrix[4],
                            ty = matrix[5],
                            originSplit = origin.split(" "),
                            xOrigin = parseFloat(originSplit[0]) || 0,
                            yOrigin = parseFloat(originSplit[1]) || 0,
                            bounds,
                            determinant,
                            x,
                            y;

                        if (!originIsAbsolute) {
                            bounds = _getBBox(target);
                            xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
                            yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin); // if (!("xOrigin" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration
                            // 	xOrigin -= bounds.x;
                            // 	yOrigin -= bounds.y;
                            // }
                        } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
                            //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
                            x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
                            y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
                            xOrigin = x;
                            yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.
                        }

                        if (smooth || smooth !== false && cache.smooth) {
                            tx = xOrigin - xOriginOld;
                            ty = yOrigin - yOriginOld;
                            cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
                            cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
                        } else {
                            cache.xOffset = cache.yOffset = 0;
                        }

                        cache.xOrigin = xOrigin;
                        cache.yOrigin = yOrigin;
                        cache.smooth = !!smooth;
                        cache.origin = origin;
                        cache.originIsAbsolute = !!originIsAbsolute;
                        target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

                        if (pluginToAddPropTweensTo) {
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
                        }

                        target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
                    },
                    _parseTransform = function _parseTransform(target, uncache) {
                        var cache = target._gsap || new gsap_core /* GSCache */ .l1(target);

                        if ("x" in cache && !uncache && !cache.uncache) {
                            return cache;
                        }

                        var style = target.style,
                            invertedScaleX = cache.scaleX < 0,
                            px = "px",
                            deg = "deg",
                            cs = getComputedStyle(target),
                            origin = _getComputedProperty(target, _transformOriginProp) || "0",
                            x,
                            y,
                            z,
                            scaleX,
                            scaleY,
                            rotation,
                            rotationX,
                            rotationY,
                            skewX,
                            skewY,
                            perspective,
                            xOrigin,
                            yOrigin,
                            matrix,
                            angle,
                            cos,
                            sin,
                            a,
                            b,
                            c,
                            d,
                            a12,
                            a22,
                            t1,
                            t2,
                            t3,
                            a13,
                            a23,
                            a33,
                            a42,
                            a43,
                            a32;
                        x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
                        scaleX = scaleY = 1;
                        cache.svg = !!(target.getCTM && _isSVG(target));

                        if (cs.translate) {
                            // accommodate independent transforms by combining them into normal ones.
                            if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
                                style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
                            }

                            style.scale = style.rotate = style.translate = "none";
                        }

                        matrix = _getMatrix(target, cache.svg);

                        if (cache.svg) {
                            if (cache.uncache) {
                                // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
                                t2 = target.getBBox();
                                origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
                                t1 = "";
                            } else {
                                t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
                            }

                            _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
                        }

                        xOrigin = cache.xOrigin || 0;
                        yOrigin = cache.yOrigin || 0;

                        if (matrix !== _identity2DMatrix) {
                            a = matrix[0]; //a11

                            b = matrix[1]; //a21

                            c = matrix[2]; //a31

                            d = matrix[3]; //a41

                            x = a12 = matrix[4];
                            y = a22 = matrix[5]; //2D matrix

                            if (matrix.length === 6) {
                                scaleX = Math.sqrt(a * a + b * b);
                                scaleY = Math.sqrt(d * d + c * c);
                                rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

                                skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
                                skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

                                if (cache.svg) {
                                    x -= xOrigin - (xOrigin * a + yOrigin * c);
                                    y -= yOrigin - (xOrigin * b + yOrigin * d);
                                } //3D matrix

                            } else {
                                a32 = matrix[6];
                                a42 = matrix[7];
                                a13 = matrix[8];
                                a23 = matrix[9];
                                a33 = matrix[10];
                                a43 = matrix[11];
                                x = matrix[12];
                                y = matrix[13];
                                z = matrix[14];
                                angle = _atan2(a32, a33);
                                rotationX = angle * _RAD2DEG; //rotationX

                                if (angle) {
                                    cos = Math.cos(-angle);
                                    sin = Math.sin(-angle);
                                    t1 = a12 * cos + a13 * sin;
                                    t2 = a22 * cos + a23 * sin;
                                    t3 = a32 * cos + a33 * sin;
                                    a13 = a12 * -sin + a13 * cos;
                                    a23 = a22 * -sin + a23 * cos;
                                    a33 = a32 * -sin + a33 * cos;
                                    a43 = a42 * -sin + a43 * cos;
                                    a12 = t1;
                                    a22 = t2;
                                    a32 = t3;
                                } //rotationY


                                angle = _atan2(-c, a33);
                                rotationY = angle * _RAD2DEG;

                                if (angle) {
                                    cos = Math.cos(-angle);
                                    sin = Math.sin(-angle);
                                    t1 = a * cos - a13 * sin;
                                    t2 = b * cos - a23 * sin;
                                    t3 = c * cos - a33 * sin;
                                    a43 = d * sin + a43 * cos;
                                    a = t1;
                                    b = t2;
                                    c = t3;
                                } //rotationZ


                                angle = _atan2(b, a);
                                rotation = angle * _RAD2DEG;

                                if (angle) {
                                    cos = Math.cos(angle);
                                    sin = Math.sin(angle);
                                    t1 = a * cos + b * sin;
                                    t2 = a12 * cos + a22 * sin;
                                    b = b * cos - a * sin;
                                    a22 = a22 * cos - a12 * sin;
                                    a = t1;
                                    a12 = t2;
                                }

                                if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
                                    //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
                                    rotationX = rotation = 0;
                                    rotationY = 180 - rotationY;
                                }

                                scaleX = (0, gsap_core /* _round */ .Pr)(Math.sqrt(a * a + b * b + c * c));
                                scaleY = (0, gsap_core /* _round */ .Pr)(Math.sqrt(a22 * a22 + a32 * a32));
                                angle = _atan2(a12, a22);
                                skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
                                perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
                            }

                            if (cache.svg) {
                                //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
                                t1 = target.getAttribute("transform");
                                cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
                                t1 && target.setAttribute("transform", t1);
                            }
                        }

                        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
                            if (invertedScaleX) {
                                scaleX *= -1;
                                skewX += rotation <= 0 ? 180 : -180;
                                rotation += rotation <= 0 ? 180 : -180;
                            } else {
                                scaleY *= -1;
                                skewX += skewX <= 0 ? 180 : -180;
                            }
                        }

                        uncache = uncache || cache.uncache;
                        cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
                        cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
                        cache.z = z + px;
                        cache.scaleX = (0, gsap_core /* _round */ .Pr)(scaleX);
                        cache.scaleY = (0, gsap_core /* _round */ .Pr)(scaleY);
                        cache.rotation = (0, gsap_core /* _round */ .Pr)(rotation) + deg;
                        cache.rotationX = (0, gsap_core /* _round */ .Pr)(rotationX) + deg;
                        cache.rotationY = (0, gsap_core /* _round */ .Pr)(rotationY) + deg;
                        cache.skewX = skewX + deg;
                        cache.skewY = skewY + deg;
                        cache.transformPerspective = perspective + px;

                        if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
                            style[_transformOriginProp] = _firstTwoOnly(origin);
                        }

                        cache.xOffset = cache.yOffset = 0;
                        cache.force3D = gsap_core /* _config.force3D */ .Fc.force3D;
                        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
                        cache.uncache = 0;
                        return cache;
                    },
                    _firstTwoOnly = function _firstTwoOnly(value) {
                        return (value = value.split(" "))[0] + " " + value[1];
                    },
                    //for handling transformOrigin values, stripping out the 3rd dimension
                    _addPxTranslate = function _addPxTranslate(target, start, value) {
                        var unit = (0, gsap_core /* getUnit */ .Wy)(start);
                        return (0, gsap_core /* _round */ .Pr)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
                    },
                    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
                        cache.z = "0px";
                        cache.rotationY = cache.rotationX = "0deg";
                        cache.force3D = 0;

                        _renderCSSTransforms(ratio, cache);
                    },
                    _zeroDeg = "0deg",
                    _zeroPx = "0px",
                    _endParenthesis = ") ",
                    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
                        var _ref = cache || this,
                            xPercent = _ref.xPercent,
                            yPercent = _ref.yPercent,
                            x = _ref.x,
                            y = _ref.y,
                            z = _ref.z,
                            rotation = _ref.rotation,
                            rotationY = _ref.rotationY,
                            rotationX = _ref.rotationX,
                            skewX = _ref.skewX,
                            skewY = _ref.skewY,
                            scaleX = _ref.scaleX,
                            scaleY = _ref.scaleY,
                            transformPerspective = _ref.transformPerspective,
                            force3D = _ref.force3D,
                            target = _ref.target,
                            zOrigin = _ref.zOrigin,
                            transforms = "",
                            use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


                        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
                            var angle = parseFloat(rotationY) * _DEG2RAD,
                                a13 = Math.sin(angle),
                                a33 = Math.cos(angle),
                                cos;

                            angle = parseFloat(rotationX) * _DEG2RAD;
                            cos = Math.cos(angle);
                            x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
                            y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
                            z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
                        }

                        if (transformPerspective !== _zeroPx) {
                            transforms += "perspective(" + transformPerspective + _endParenthesis;
                        }

                        if (xPercent || yPercent) {
                            transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
                        }

                        if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
                            transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
                        }

                        if (rotation !== _zeroDeg) {
                            transforms += "rotate(" + rotation + _endParenthesis;
                        }

                        if (rotationY !== _zeroDeg) {
                            transforms += "rotateY(" + rotationY + _endParenthesis;
                        }

                        if (rotationX !== _zeroDeg) {
                            transforms += "rotateX(" + rotationX + _endParenthesis;
                        }

                        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
                            transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
                        }

                        if (scaleX !== 1 || scaleY !== 1) {
                            transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
                        }

                        target.style[_transformProp] = transforms || "translate(0, 0)";
                    },
                    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
                        var _ref2 = cache || this,
                            xPercent = _ref2.xPercent,
                            yPercent = _ref2.yPercent,
                            x = _ref2.x,
                            y = _ref2.y,
                            rotation = _ref2.rotation,
                            skewX = _ref2.skewX,
                            skewY = _ref2.skewY,
                            scaleX = _ref2.scaleX,
                            scaleY = _ref2.scaleY,
                            target = _ref2.target,
                            xOrigin = _ref2.xOrigin,
                            yOrigin = _ref2.yOrigin,
                            xOffset = _ref2.xOffset,
                            yOffset = _ref2.yOffset,
                            forceCSS = _ref2.forceCSS,
                            tx = parseFloat(x),
                            ty = parseFloat(y),
                            a11,
                            a21,
                            a12,
                            a22,
                            temp;

                        rotation = parseFloat(rotation);
                        skewX = parseFloat(skewX);
                        skewY = parseFloat(skewY);

                        if (skewY) {
                            //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
                            skewY = parseFloat(skewY);
                            skewX += skewY;
                            rotation += skewY;
                        }

                        if (rotation || skewX) {
                            rotation *= _DEG2RAD;
                            skewX *= _DEG2RAD;
                            a11 = Math.cos(rotation) * scaleX;
                            a21 = Math.sin(rotation) * scaleX;
                            a12 = Math.sin(rotation - skewX) * -scaleY;
                            a22 = Math.cos(rotation - skewX) * scaleY;

                            if (skewX) {
                                skewY *= _DEG2RAD;
                                temp = Math.tan(skewX - skewY);
                                temp = Math.sqrt(1 + temp * temp);
                                a12 *= temp;
                                a22 *= temp;

                                if (skewY) {
                                    temp = Math.tan(skewY);
                                    temp = Math.sqrt(1 + temp * temp);
                                    a11 *= temp;
                                    a21 *= temp;
                                }
                            }

                            a11 = (0, gsap_core /* _round */ .Pr)(a11);
                            a21 = (0, gsap_core /* _round */ .Pr)(a21);
                            a12 = (0, gsap_core /* _round */ .Pr)(a12);
                            a22 = (0, gsap_core /* _round */ .Pr)(a22);
                        } else {
                            a11 = scaleX;
                            a22 = scaleY;
                            a21 = a12 = 0;
                        }

                        if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
                            tx = _convertToUnit(target, "x", x, "px");
                            ty = _convertToUnit(target, "y", y, "px");
                        }

                        if (xOrigin || yOrigin || xOffset || yOffset) {
                            tx = (0, gsap_core /* _round */ .Pr)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
                            ty = (0, gsap_core /* _round */ .Pr)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
                        }

                        if (xPercent || yPercent) {
                            //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
                            temp = target.getBBox();
                            tx = (0, gsap_core /* _round */ .Pr)(tx + xPercent / 100 * temp.width);
                            ty = (0, gsap_core /* _round */ .Pr)(ty + yPercent / 100 * temp.height);
                        }

                        temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
                        target.setAttribute("transform", temp);
                        forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
                    },
                    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
                        var cap = 360,
                            isString = (0, gsap_core /* _isString */ .r9)(endValue),
                            endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
                            change = endNum - startNum,
                            finalValue = startNum + change + "deg",
                            direction,
                            pt;

                        if (isString) {
                            direction = endValue.split("_")[1];

                            if (direction === "short") {
                                change %= cap;

                                if (change !== change % (cap / 2)) {
                                    change += change < 0 ? cap : -cap;
                                }
                            }

                            if (direction === "cw" && change < 0) {
                                change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
                            } else if (direction === "ccw" && change > 0) {
                                change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
                            }
                        }

                        plugin._pt = pt = new gsap_core /* PropTween */ .Fo(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
                        pt.e = finalValue;
                        pt.u = "deg";

                        plugin._props.push(property);

                        return pt;
                    },
                    _assign = function _assign(target, source) {
                        // Internet Explorer doesn't have Object.assign(), so we recreate it here.
                        for (var p in source) {
                            target[p] = source[p];
                        }

                        return target;
                    },
                    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
                        //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
                        var startCache = _assign({}, target._gsap),
                            exclude = "perspective,force3D,transformOrigin,svgOrigin",
                            style = target.style,
                            endCache,
                            p,
                            startValue,
                            endValue,
                            startNum,
                            endNum,
                            startUnit,
                            endUnit;

                        if (startCache.svg) {
                            startValue = target.getAttribute("transform");
                            target.setAttribute("transform", "");
                            style[_transformProp] = transforms;
                            endCache = _parseTransform(target, 1);

                            _removeProperty(target, _transformProp);

                            target.setAttribute("transform", startValue);
                        } else {
                            startValue = getComputedStyle(target)[_transformProp];
                            style[_transformProp] = transforms;
                            endCache = _parseTransform(target, 1);
                            style[_transformProp] = startValue;
                        }

                        for (p in _transformProps) {
                            startValue = startCache[p];
                            endValue = endCache[p];

                            if (startValue !== endValue && exclude.indexOf(p) < 0) {
                                //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
                                startUnit = (0, gsap_core /* getUnit */ .Wy)(startValue);
                                endUnit = (0, gsap_core /* getUnit */ .Wy)(endValue);
                                startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
                                endNum = parseFloat(endValue);
                                plugin._pt = new gsap_core /* PropTween */ .Fo(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
                                plugin._pt.u = endUnit || 0;

                                plugin._props.push(p);
                            }
                        }

                        _assign(endCache, startCache);
                    }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


                (0, gsap_core /* _forEachName */ .fS)("padding,margin,Width,Radius", function(name, index) {
                    var t = "Top",
                        r = "Right",
                        b = "Bottom",
                        l = "Left",
                        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
                            return index < 2 ? name + side : "border" + side + name;
                        });

                    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
                        var a, vars;

                        if (arguments.length < 4) {
                            // getter, passed target, property, and unit (from _get())
                            a = props.map(function(prop) {
                                return _get(plugin, prop, property);
                            });
                            vars = a.join(" ");
                            return vars.split(a[0]).length === 5 ? a[0] : vars;
                        }

                        a = (endValue + "").split(" ");
                        vars = {};
                        props.forEach(function(prop, i) {
                            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
                        });
                        plugin.init(target, vars, tween);
                    };
                });

                var CSSPlugin = {
                    name: "css",
                    register: _initCore,
                    targetTest: function targetTest(target) {
                        return target.style && target.nodeType;
                    },
                    init: function init(target, vars, tween, index, targets) {
                        var props = this._props,
                            style = target.style,
                            startAt = tween.vars.startAt,
                            startValue,
                            endValue,
                            endNum,
                            startNum,
                            type,
                            specialProp,
                            p,
                            startUnit,
                            endUnit,
                            relative,
                            isTransformRelated,
                            transformPropTween,
                            cache,
                            smooth,
                            hasPriority,
                            inlineProps;
                        _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

                        this.styles = this.styles || _getStyleSaver(target);
                        inlineProps = this.styles.props;
                        this.tween = tween;

                        for (p in vars) {
                            if (p === "autoRound") {
                                continue;
                            }

                            endValue = vars[p];

                            if (gsap_core /* _plugins */ .$i[p] && (0, gsap_core /* _checkPlugin */ ["if"])(p, vars, tween, index, target, targets)) {
                                // plugins
                                continue;
                            }

                            type = typeof endValue;
                            specialProp = _specialProps[p];

                            if (type === "function") {
                                endValue = endValue.call(tween, index, target, targets);
                                type = typeof endValue;
                            }

                            if (type === "string" && ~endValue.indexOf("random(")) {
                                endValue = (0, gsap_core /* _replaceRandom */ .UI)(endValue);
                            }

                            if (specialProp) {
                                specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
                            } else if (p.substr(0, 2) === "--") {
                                //CSS variable
                                startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
                                endValue += "";
                                gsap_core /* _colorExp.lastIndex */ .GN.lastIndex = 0;

                                if (!gsap_core /* _colorExp.test */ .GN.test(startValue)) {
                                    // colors don't have units
                                    startUnit = (0, gsap_core /* getUnit */ .Wy)(startValue);
                                    endUnit = (0, gsap_core /* getUnit */ .Wy)(endValue);
                                }

                                endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
                                this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
                                props.push(p);
                                inlineProps.push(p, 0, style[p]);
                            } else if (type !== "undefined") {
                                if (startAt && p in startAt) {
                                    // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
                                    startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
                                    (0, gsap_core /* _isString */ .r9)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, gsap_core /* _replaceRandom */ .UI)(startValue));
                                    (0, gsap_core /* getUnit */ .Wy)(startValue + "") || startValue === "auto" || (startValue += gsap_core /* _config.units */ .Fc.units[p] || (0, gsap_core /* getUnit */ .Wy)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

                                    (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
                                } else {
                                    startValue = _get(target, p);
                                }

                                startNum = parseFloat(startValue);
                                relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
                                relative && (endValue = endValue.substr(2));
                                endNum = parseFloat(endValue);

                                if (p in _propertyAliases) {
                                    if (p === "autoAlpha") {
                                        //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
                                        if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                                            //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                                            startNum = 0;
                                        }

                                        inlineProps.push("visibility", 0, style.visibility);

                                        _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                                    }

                                    if (p !== "scale" && p !== "transform") {
                                        p = _propertyAliases[p];
                                        ~p.indexOf(",") && (p = p.split(",")[0]);
                                    }
                                }

                                isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

                                if (isTransformRelated) {
                                    this.styles.save(p);

                                    if (!transformPropTween) {
                                        cache = target._gsap;
                                        cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

                                        smooth = vars.smoothOrigin !== false && cache.smooth;
                                        transformPropTween = this._pt = new gsap_core /* PropTween */ .Fo(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

                                        transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
                                    }

                                    if (p === "scale") {
                                        this._pt = new gsap_core /* PropTween */ .Fo(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, gsap_core /* _parseRelative */ .cy)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                                        this._pt.u = 0;
                                        props.push("scaleY", p);
                                        p += "X";
                                    } else if (p === "transformOrigin") {
                                        inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                                        endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

                                        if (cache.svg) {
                                            _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                                        } else {
                                            endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

                                            endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

                                            _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                                        }

                                        continue;
                                    } else if (p === "svgOrigin") {
                                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);

                                        continue;
                                    } else if (p in _rotationalProperties) {
                                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0, gsap_core /* _parseRelative */ .cy)(startNum, relative + endValue) : endValue);

                                        continue;
                                    } else if (p === "smoothOrigin") {
                                        _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

                                        continue;
                                    } else if (p === "force3D") {
                                        cache[p] = endValue;
                                        continue;
                                    } else if (p === "transform") {
                                        _addRawTransformPTs(this, endValue, target);

                                        continue;
                                    }
                                } else if (!(p in style)) {
                                    p = _checkPropPrefix(p) || p;
                                }

                                if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                                    startUnit = (startValue + "").substr((startNum + "").length);
                                    endNum || (endNum = 0); // protect against NaN

                                    endUnit = (0, gsap_core /* getUnit */ .Wy)(endValue) || (p in gsap_core /* _config.units */ .Fc.units ? gsap_core /* _config.units */ .Fc.units[p] : startUnit);
                                    startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                                    this._pt = new gsap_core /* PropTween */ .Fo(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, gsap_core /* _parseRelative */ .cy)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                                    this._pt.u = endUnit || 0;

                                    if (startUnit !== endUnit && endUnit !== "%") {
                                        //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
                                        this._pt.b = startValue;
                                        this._pt.r = _renderCSSPropWithBeginning;
                                    }
                                } else if (!(p in style)) {
                                    if (p in target) {
                                        //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
                                        this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
                                    } else if (p !== "parseTransform") {
                                        (0, gsap_core /* _missingPlugin */ .lC)(p, endValue);

                                        continue;
                                    }
                                } else {
                                    _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
                                }

                                isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
                                props.push(p);
                            }
                        }

                        hasPriority && (0, gsap_core /* _sortPropTweensByPriority */ .JV)(this);
                    },
                    render: function render(ratio, data) {
                        if (data.tween._time || !_reverting()) {
                            var pt = data._pt;

                            while (pt) {
                                pt.r(ratio, pt.d);
                                pt = pt._next;
                            }
                        } else {
                            data.styles.revert();
                        }
                    },
                    get: _get,
                    aliases: _propertyAliases,
                    getSetter: function getSetter(target, property, plugin) {
                        //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
                        var p = _propertyAliases[property];
                        p && p.indexOf(",") < 0 && (property = p);
                        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, gsap_core /* _isUndefined */ .m2)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, gsap_core /* _getSetter */ .S5)(target, property);
                    },
                    core: {
                        _removeProperty: _removeProperty,
                        _getMatrix: _getMatrix
                    }
                };
                gsap_core /* gsap.utils.checkPrefix */ .p8.utils.checkPrefix = _checkPropPrefix;
                gsap_core /* gsap.core.getStyleSaver */ .p8.core.getStyleSaver = _getStyleSaver;

                (function(positionAndScale, rotation, others, aliases) {
                    var all = (0, gsap_core /* _forEachName */ .fS)(positionAndScale + "," + rotation + "," + others, function(name) {
                        _transformProps[name] = 1;
                    });

                    (0, gsap_core /* _forEachName */ .fS)(rotation, function(name) {
                        gsap_core /* _config.units */ .Fc.units[name] = "deg";
                        _rotationalProperties[name] = 1;
                    });

                    _propertyAliases[all[13]] = positionAndScale + "," + rotation;

                    (0, gsap_core /* _forEachName */ .fS)(aliases, function(name) {
                        var split = name.split(":");
                        _propertyAliases[split[1]] = all[split[0]];
                    });
                })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

                (0, gsap_core /* _forEachName */ .fS)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
                    gsap_core /* _config.units */ .Fc.units[name] = "px";
                });

                gsap_core /* gsap.registerPlugin */ .p8.registerPlugin(CSSPlugin);

                ; // CONCATENATED MODULE: ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js


                var gsapWithCSS = gsap_core /* gsap.registerPlugin */ .p8.registerPlugin(CSSPlugin) || gsap_core /* gsap */ .p8,
                    // to protect from tree shaking
                    TweenMaxWithCSS = gsapWithCSS.core.Tween;


                /***/
            }),

        /***/
        "JpGc":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __webpack_require__("aa+5");

                /** @type {import('.')} */
                module.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }

                    return hasSymbolSham();
                };


                /***/
            }),

        /***/
        "aa+5":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./shams')} */
                /* eslint complexity: [2, 18], max-statements: [2, 33] */
                module.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }

                    /** @type {{ [k in symbol]?: unknown }} */
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }

                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }

                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }

                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

                    var symVal = 42;
                    obj[sym] = symVal;
                    for (var _ in obj) {
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }

                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }

                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }

                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }

                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        // eslint-disable-next-line no-extra-parens
                        var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }

                    return true;
                };


                /***/
            }),

        /***/
        "Tin7":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __webpack_require__("5Shc");

                /** @type {import('.')} */
                module.exports = bind.call(call, $hasOwn);


                /***/
            }),

        /***/
        "/IPs":
            /***/
            ((__unused_webpack_module, exports) => {

                /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
                exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                    var e, m
                    var eLen = (nBytes * 8) - mLen - 1
                    var eMax = (1 << eLen) - 1
                    var eBias = eMax >> 1
                    var nBits = -7
                    var i = isLE ? (nBytes - 1) : 0
                    var d = isLE ? -1 : 1
                    var s = buffer[offset + i]

                    i += d

                    e = s & ((1 << (-nBits)) - 1)
                    s >>= (-nBits)
                    nBits += eLen
                    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

                    m = e & ((1 << (-nBits)) - 1)
                    e >>= (-nBits)
                    nBits += mLen
                    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

                    if (e === 0) {
                        e = 1 - eBias
                    } else if (e === eMax) {
                        return m ? NaN : ((s ? -1 : 1) * Infinity)
                    } else {
                        m = m + Math.pow(2, mLen)
                        e = e - eBias
                    }
                    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
                }

                exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                    var e, m, c
                    var eLen = (nBytes * 8) - mLen - 1
                    var eMax = (1 << eLen) - 1
                    var eBias = eMax >> 1
                    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
                    var i = isLE ? 0 : (nBytes - 1)
                    var d = isLE ? 1 : -1
                    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

                    value = Math.abs(value)

                    if (isNaN(value) || value === Infinity) {
                        m = isNaN(value) ? 1 : 0
                        e = eMax
                    } else {
                        e = Math.floor(Math.log(value) / Math.LN2)
                        if (value * (c = Math.pow(2, -e)) < 1) {
                            e--
                            c *= 2
                        }
                        if (e + eBias >= 1) {
                            value += rt / c
                        } else {
                            value += rt * Math.pow(2, 1 - eBias)
                        }
                        if (value * c >= 2) {
                            e++
                            c /= 2
                        }

                        if (e + eBias >= eMax) {
                            m = 0
                            e = eMax
                        } else if (e + eBias >= 1) {
                            m = ((value * c) - 1) * Math.pow(2, mLen)
                            e = e + eBias
                        } else {
                            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                            e = 0
                        }
                    }

                    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

                    e = (e << mLen) | m
                    eLen += mLen
                    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

                    buffer[offset + i - d] |= s * 128
                }


                /***/
            }),

        /***/
        "R89B":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./abs')} */
                module.exports = Math.abs;


                /***/
            }),

        /***/
        "HLEs":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./floor')} */
                module.exports = Math.floor;


                /***/
            }),

        /***/
        "EzRv":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./isNaN')} */
                module.exports = Number.isNaN || function isNaN(a) {
                    return a !== a;
                };


                /***/
            }),

        /***/
        "OfPJ":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./max')} */
                module.exports = Math.max;


                /***/
            }),

        /***/
        "bpVC":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./min')} */
                module.exports = Math.min;


                /***/
            }),

        /***/
        "1dpo":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./pow')} */
                module.exports = Math.pow;


                /***/
            }),

        /***/
        "8b6j":
            /***/
            ((module) => {

                "use strict";


                /** @type {import('./round')} */
                module.exports = Math.round;


                /***/
            }),

        /***/
        "c2fp":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var $isNaN = __webpack_require__("EzRv");

                /** @type {import('./sign')} */
                module.exports = function sign(number) {
                    if ($isNaN(number) || number === 0) {
                        return number;
                    }
                    return number < 0 ? -1 : +1;
                };


                /***/
            }),

        /***/
        "63T4":
            /***/
            (() => {

                "use strict";
                // extracted by mini-css-extract-plugin


                /***/
            }),

        /***/
        "jChU":
            /***/
            (() => {

                "use strict";
                // extracted by mini-css-extract-plugin


                /***/
            }),

        /***/
        "gqNQ":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                var hasMap = typeof Map === 'function' && Map.prototype;
                var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
                var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
                var mapForEach = hasMap && Map.prototype.forEach;
                var hasSet = typeof Set === 'function' && Set.prototype;
                var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
                var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
                var setForEach = hasSet && Set.prototype.forEach;
                var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
                var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
                var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
                var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
                var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
                var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
                var booleanValueOf = Boolean.prototype.valueOf;
                var objectToString = Object.prototype.toString;
                var functionToString = Function.prototype.toString;
                var $match = String.prototype.match;
                var $slice = String.prototype.slice;
                var $replace = String.prototype.replace;
                var $toUpperCase = String.prototype.toUpperCase;
                var $toLowerCase = String.prototype.toLowerCase;
                var $test = RegExp.prototype.test;
                var $concat = Array.prototype.concat;
                var $join = Array.prototype.join;
                var $arrSlice = Array.prototype.slice;
                var $floor = Math.floor;
                var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
                var gOPS = Object.getOwnPropertySymbols;
                var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
                var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
                // ie, `has-tostringtag/shams
                var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ?
                    Symbol.toStringTag :
                    null;
                var isEnumerable = Object.prototype.propertyIsEnumerable;

                var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
                    [].__proto__ === Array.prototype // eslint-disable-line no-proto
                    ?
                    function(O) {
                        return O.__proto__; // eslint-disable-line no-proto
                    } :
                    null
                );

                function addNumericSeparator(num, str) {
                    if (
                        num === Infinity ||
                        num === -Infinity ||
                        num !== num ||
                        (num && num > -1000 && num < 1000) ||
                        $test.call(/e/, str)
                    ) {
                        return str;
                    }
                    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
                    if (typeof num === 'number') {
                        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
                        if (int !== num) {
                            var intStr = String(int);
                            var dec = $slice.call(str, intStr.length + 1);
                            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                        }
                    }
                    return $replace.call(str, sepRegex, '$&_');
                }

                var utilInspect = __webpack_require__("bTuE");
                var inspectCustom = utilInspect.custom;
                var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

                var quotes = {
                    __proto__: null,
                    'double': '"',
                    single: "'"
                };
                var quoteREs = {
                    __proto__: null,
                    'double': /(["\\])/g,
                    single: /(['\\])/g
                };

                module.exports = function inspect_(obj, options, depth, seen) {
                    var opts = options || {};

                    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
                        throw new TypeError('option "quoteStyle" must be "single" or "double"');
                    }
                    if (
                        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ?
                            opts.maxStringLength < 0 && opts.maxStringLength !== Infinity :
                            opts.maxStringLength !== null
                        )
                    ) {
                        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
                    }
                    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
                    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
                        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
                    }

                    if (
                        has(opts, 'indent') &&
                        opts.indent !== null &&
                        opts.indent !== '\t' &&
                        !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
                    ) {
                        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
                    }
                    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
                        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
                    }
                    var numericSeparator = opts.numericSeparator;

                    if (typeof obj === 'undefined') {
                        return 'undefined';
                    }
                    if (obj === null) {
                        return 'null';
                    }
                    if (typeof obj === 'boolean') {
                        return obj ? 'true' : 'false';
                    }

                    if (typeof obj === 'string') {
                        return inspectString(obj, opts);
                    }
                    if (typeof obj === 'number') {
                        if (obj === 0) {
                            return Infinity / obj > 0 ? '0' : '-0';
                        }
                        var str = String(obj);
                        return numericSeparator ? addNumericSeparator(obj, str) : str;
                    }
                    if (typeof obj === 'bigint') {
                        var bigIntStr = String(obj) + 'n';
                        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
                    }

                    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
                    if (typeof depth === 'undefined') {
                        depth = 0;
                    }
                    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
                        return isArray(obj) ? '[Array]' : '[Object]';
                    }

                    var indent = getIndent(opts, depth);

                    if (typeof seen === 'undefined') {
                        seen = [];
                    } else if (indexOf(seen, obj) >= 0) {
                        return '[Circular]';
                    }

                    function inspect(value, from, noIndent) {
                        if (from) {
                            seen = $arrSlice.call(seen);
                            seen.push(from);
                        }
                        if (noIndent) {
                            var newOpts = {
                                depth: opts.depth
                            };
                            if (has(opts, 'quoteStyle')) {
                                newOpts.quoteStyle = opts.quoteStyle;
                            }
                            return inspect_(value, newOpts, depth + 1, seen);
                        }
                        return inspect_(value, opts, depth + 1, seen);
                    }

                    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
                        var name = nameOf(obj);
                        var keys = arrObjKeys(obj, inspect);
                        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
                    }
                    if (isSymbol(obj)) {
                        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
                    }
                    if (isElement(obj)) {
                        var s = '<' + $toLowerCase.call(String(obj.nodeName));
                        var attrs = obj.attributes || [];
                        for (var i = 0; i < attrs.length; i++) {
                            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                        }
                        s += '>';
                        if (obj.childNodes && obj.childNodes.length) {
                            s += '...';
                        }
                        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                        return s;
                    }
                    if (isArray(obj)) {
                        if (obj.length === 0) {
                            return '[]';
                        }
                        var xs = arrObjKeys(obj, inspect);
                        if (indent && !singleLineValues(xs)) {
                            return '[' + indentedJoin(xs, indent) + ']';
                        }
                        return '[ ' + $join.call(xs, ', ') + ' ]';
                    }
                    if (isError(obj)) {
                        var parts = arrObjKeys(obj, inspect);
                        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
                            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                        }
                        if (parts.length === 0) {
                            return '[' + String(obj) + ']';
                        }
                        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
                    }
                    if (typeof obj === 'object' && customInspect) {
                        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
                            return utilInspect(obj, {
                                depth: maxDepth - depth
                            });
                        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
                            return obj.inspect();
                        }
                    }
                    if (isMap(obj)) {
                        var mapParts = [];
                        if (mapForEach) {
                            mapForEach.call(obj, function(value, key) {
                                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                            });
                        }
                        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
                    }
                    if (isSet(obj)) {
                        var setParts = [];
                        if (setForEach) {
                            setForEach.call(obj, function(value) {
                                setParts.push(inspect(value, obj));
                            });
                        }
                        return collectionOf('Set', setSize.call(obj), setParts, indent);
                    }
                    if (isWeakMap(obj)) {
                        return weakCollectionOf('WeakMap');
                    }
                    if (isWeakSet(obj)) {
                        return weakCollectionOf('WeakSet');
                    }
                    if (isWeakRef(obj)) {
                        return weakCollectionOf('WeakRef');
                    }
                    if (isNumber(obj)) {
                        return markBoxed(inspect(Number(obj)));
                    }
                    if (isBigInt(obj)) {
                        return markBoxed(inspect(bigIntValueOf.call(obj)));
                    }
                    if (isBoolean(obj)) {
                        return markBoxed(booleanValueOf.call(obj));
                    }
                    if (isString(obj)) {
                        return markBoxed(inspect(String(obj)));
                    }
                    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
                    /* eslint-env browser */
                    if (true && obj === window) {
                        return '{ [object Window] }';
                    }
                    if (
                        (typeof globalThis !== 'undefined' && obj === globalThis) ||
                        (typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g)
                    ) {
                        return '{ [object globalThis] }';
                    }
                    if (!isDate(obj) && !isRegExp(obj)) {
                        var ys = arrObjKeys(obj, inspect);
                        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                        var protoTag = obj instanceof Object ? '' : 'null prototype';
                        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                        if (ys.length === 0) {
                            return tag + '{}';
                        }
                        if (indent) {
                            return tag + '{' + indentedJoin(ys, indent) + '}';
                        }
                        return tag + '{ ' + $join.call(ys, ', ') + ' }';
                    }
                    return String(obj);
                };

                function wrapQuotes(s, defaultStyle, opts) {
                    var style = opts.quoteStyle || defaultStyle;
                    var quoteChar = quotes[style];
                    return quoteChar + s + quoteChar;
                }

                function quote(s) {
                    return $replace.call(String(s), /"/g, '&quot;');
                }

                function isArray(obj) {
                    return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                function isDate(obj) {
                    return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                function isRegExp(obj) {
                    return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                function isError(obj) {
                    return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                function isString(obj) {
                    return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                function isNumber(obj) {
                    return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                function isBoolean(obj) {
                    return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
                }

                // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
                function isSymbol(obj) {
                    if (hasShammedSymbols) {
                        return obj && typeof obj === 'object' && obj instanceof Symbol;
                    }
                    if (typeof obj === 'symbol') {
                        return true;
                    }
                    if (!obj || typeof obj !== 'object' || !symToString) {
                        return false;
                    }
                    try {
                        symToString.call(obj);
                        return true;
                    } catch (e) {}
                    return false;
                }

                function isBigInt(obj) {
                    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
                        return false;
                    }
                    try {
                        bigIntValueOf.call(obj);
                        return true;
                    } catch (e) {}
                    return false;
                }

                var hasOwn = Object.prototype.hasOwnProperty || function(key) {
                    return key in this;
                };

                function has(obj, key) {
                    return hasOwn.call(obj, key);
                }

                function toStr(obj) {
                    return objectToString.call(obj);
                }

                function nameOf(f) {
                    if (f.name) {
                        return f.name;
                    }
                    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
                    if (m) {
                        return m[1];
                    }
                    return null;
                }

                function indexOf(xs, x) {
                    if (xs.indexOf) {
                        return xs.indexOf(x);
                    }
                    for (var i = 0, l = xs.length; i < l; i++) {
                        if (xs[i] === x) {
                            return i;
                        }
                    }
                    return -1;
                }

                function isMap(x) {
                    if (!mapSize || !x || typeof x !== 'object') {
                        return false;
                    }
                    try {
                        mapSize.call(x);
                        try {
                            setSize.call(x);
                        } catch (s) {
                            return true;
                        }
                        return x instanceof Map; // core-js workaround, pre-v2.5.0
                    } catch (e) {}
                    return false;
                }

                function isWeakMap(x) {
                    if (!weakMapHas || !x || typeof x !== 'object') {
                        return false;
                    }
                    try {
                        weakMapHas.call(x, weakMapHas);
                        try {
                            weakSetHas.call(x, weakSetHas);
                        } catch (s) {
                            return true;
                        }
                        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
                    } catch (e) {}
                    return false;
                }

                function isWeakRef(x) {
                    if (!weakRefDeref || !x || typeof x !== 'object') {
                        return false;
                    }
                    try {
                        weakRefDeref.call(x);
                        return true;
                    } catch (e) {}
                    return false;
                }

                function isSet(x) {
                    if (!setSize || !x || typeof x !== 'object') {
                        return false;
                    }
                    try {
                        setSize.call(x);
                        try {
                            mapSize.call(x);
                        } catch (m) {
                            return true;
                        }
                        return x instanceof Set; // core-js workaround, pre-v2.5.0
                    } catch (e) {}
                    return false;
                }

                function isWeakSet(x) {
                    if (!weakSetHas || !x || typeof x !== 'object') {
                        return false;
                    }
                    try {
                        weakSetHas.call(x, weakSetHas);
                        try {
                            weakMapHas.call(x, weakMapHas);
                        } catch (s) {
                            return true;
                        }
                        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
                    } catch (e) {}
                    return false;
                }

                function isElement(x) {
                    if (!x || typeof x !== 'object') {
                        return false;
                    }
                    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
                        return true;
                    }
                    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
                }

                function inspectString(str, opts) {
                    if (str.length > opts.maxStringLength) {
                        var remaining = str.length - opts.maxStringLength;
                        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
                    }
                    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
                    quoteRE.lastIndex = 0;
                    // eslint-disable-next-line no-control-regex
                    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
                    return wrapQuotes(s, 'single', opts);
                }

                function lowbyte(c) {
                    var n = c.charCodeAt(0);
                    var x = {
                        8: 'b',
                        9: 't',
                        10: 'n',
                        12: 'f',
                        13: 'r'
                    }[n];
                    if (x) {
                        return '\\' + x;
                    }
                    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
                }

                function markBoxed(str) {
                    return 'Object(' + str + ')';
                }

                function weakCollectionOf(type) {
                    return type + ' { ? }';
                }

                function collectionOf(type, size, entries, indent) {
                    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
                    return type + ' (' + size + ') {' + joinedEntries + '}';
                }

                function singleLineValues(xs) {
                    for (var i = 0; i < xs.length; i++) {
                        if (indexOf(xs[i], '\n') >= 0) {
                            return false;
                        }
                    }
                    return true;
                }

                function getIndent(opts, depth) {
                    var baseIndent;
                    if (opts.indent === '\t') {
                        baseIndent = '\t';
                    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
                        baseIndent = $join.call(Array(opts.indent + 1), ' ');
                    } else {
                        return null;
                    }
                    return {
                        base: baseIndent,
                        prev: $join.call(Array(depth + 1), baseIndent)
                    };
                }

                function indentedJoin(xs, indent) {
                    if (xs.length === 0) {
                        return '';
                    }
                    var lineJoiner = '\n' + indent.prev + indent.base;
                    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
                }

                function arrObjKeys(obj, inspect) {
                    var isArr = isArray(obj);
                    var xs = [];
                    if (isArr) {
                        xs.length = obj.length;
                        for (var i = 0; i < obj.length; i++) {
                            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
                        }
                    }
                    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
                    var symMap;
                    if (hasShammedSymbols) {
                        symMap = {};
                        for (var k = 0; k < syms.length; k++) {
                            symMap['$' + syms[k]] = syms[k];
                        }
                    }

                    for (var key in obj) { // eslint-disable-line no-restricted-syntax
                        if (!has(obj, key)) {
                            continue;
                        } // eslint-disable-line no-restricted-syntax, no-continue
                        if (isArr && String(Number(key)) === key && key < obj.length) {
                            continue;
                        } // eslint-disable-line no-restricted-syntax, no-continue
                        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
                            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
                            continue; // eslint-disable-line no-restricted-syntax, no-continue
                        } else if ($test.call(/[^\w$]/, key)) {
                            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                        } else {
                            xs.push(key + ': ' + inspect(obj[key], obj));
                        }
                    }
                    if (typeof gOPS === 'function') {
                        for (var j = 0; j < syms.length; j++) {
                            if (isEnumerable.call(obj, syms[j])) {
                                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
                            }
                        }
                    }
                    return xs;
                }


                /***/
            }),

        /***/
        "ozD+":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {


                const canPromise = __webpack_require__("Z5++")

                const QRCode = __webpack_require__("YOh+")
                const CanvasRenderer = __webpack_require__("d7EH")
                const SvgRenderer = __webpack_require__("FZag")

                function renderCanvas(renderFunc, canvas, text, opts, cb) {
                    const args = [].slice.call(arguments, 1)
                    const argsNum = args.length
                    const isLastArgCb = typeof args[argsNum - 1] === 'function'

                    if (!isLastArgCb && !canPromise()) {
                        throw new Error('Callback required as last argument')
                    }

                    if (isLastArgCb) {
                        if (argsNum < 2) {
                            throw new Error('Too few arguments provided')
                        }

                        if (argsNum === 2) {
                            cb = text
                            text = canvas
                            canvas = opts = undefined
                        } else if (argsNum === 3) {
                            if (canvas.getContext && typeof cb === 'undefined') {
                                cb = opts
                                opts = undefined
                            } else {
                                cb = opts
                                opts = text
                                text = canvas
                                canvas = undefined
                            }
                        }
                    } else {
                        if (argsNum < 1) {
                            throw new Error('Too few arguments provided')
                        }

                        if (argsNum === 1) {
                            text = canvas
                            canvas = opts = undefined
                        } else if (argsNum === 2 && !canvas.getContext) {
                            opts = text
                            text = canvas
                            canvas = undefined
                        }

                        return new Promise(function(resolve, reject) {
                            try {
                                const data = QRCode.create(text, opts)
                                resolve(renderFunc(data, canvas, opts))
                            } catch (e) {
                                reject(e)
                            }
                        })
                    }

                    try {
                        const data = QRCode.create(text, opts)
                        cb(null, renderFunc(data, canvas, opts))
                    } catch (e) {
                        cb(e)
                    }
                }

                exports.create = QRCode.create
                exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)
                exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)

                // only svg for now.
                exports.toString = renderCanvas.bind(null, function(data, _, opts) {
                    return SvgRenderer.render(data, opts)
                })


                /***/
            }),

        /***/
        "Z5++":
            /***/
            ((module) => {

                // can-promise has a crash in some versions of react native that dont have
                // standard global objects
                // https://github.com/soldair/node-qrcode/issues/157

                module.exports = function() {
                    return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
                }


                /***/
            }),

        /***/
        "teuN":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                /**
                 * Alignment pattern are fixed reference pattern in defined positions
                 * in a matrix symbology, which enables the decode software to re-synchronise
                 * the coordinate mapping of the image modules in the event of moderate amounts
                 * of distortion of the image.
                 *
                 * Alignment patterns are present only in QR Code symbols of version 2 or larger
                 * and their number depends on the symbol version.
                 */

                const getSymbolSize = (__webpack_require__("lr8Y").getSymbolSize)

                /**
                 * Calculate the row/column coordinates of the center module of each alignment pattern
                 * for the specified QR Code version.
                 *
                 * The alignment patterns are positioned symmetrically on either side of the diagonal
                 * running from the top left corner of the symbol to the bottom right corner.
                 *
                 * Since positions are simmetrical only half of the coordinates are returned.
                 * Each item of the array will represent in turn the x and y coordinate.
                 * @see {@link getPositions}
                 *
                 * @param  {Number} version QR Code version
                 * @return {Array}          Array of coordinate
                 */
                exports.getRowColCoords = function getRowColCoords(version) {
                    if (version === 1) return []

                    const posCount = Math.floor(version / 7) + 2
                    const size = getSymbolSize(version)
                    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2
                    const positions = [size - 7] // Last coord is always (size - 7)

                    for (let i = 1; i < posCount - 1; i++) {
                        positions[i] = positions[i - 1] - intervals
                    }

                    positions.push(6) // First coord is always 6

                    return positions.reverse()
                }

                /**
                 * Returns an array containing the positions of each alignment pattern.
                 * Each array's element represent the center point of the pattern as (x, y) coordinates
                 *
                 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
                 * and filtering out the items that overlaps with finder pattern
                 *
                 * @example
                 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
                 * The alignment patterns, therefore, are to be centered on (row, column)
                 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
                 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
                 * and are not therefore used for alignment patterns.
                 *
                 * let pos = getPositions(7)
                 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
                 *
                 * @param  {Number} version QR Code version
                 * @return {Array}          Array of coordinates
                 */
                exports.getPositions = function getPositions(version) {
                    const coords = []
                    const pos = exports.getRowColCoords(version)
                    const posLength = pos.length

                    for (let i = 0; i < posLength; i++) {
                        for (let j = 0; j < posLength; j++) {
                            // Skip if position is occupied by finder patterns
                            if ((i === 0 && j === 0) || // top-left
                                (i === 0 && j === posLength - 1) || // bottom-left
                                (i === posLength - 1 && j === 0)) { // top-right
                                continue
                            }

                            coords.push([pos[i], pos[j]])
                        }
                    }

                    return coords
                }


                /***/
            }),

        /***/
        "aob+":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                const Mode = __webpack_require__("u8wY")

                /**
                 * Array of characters available in alphanumeric mode
                 *
                 * As per QR Code specification, to each character
                 * is assigned a value from 0 to 44 which in this case coincides
                 * with the array index
                 *
                 * @type {Array}
                 */
                const ALPHA_NUM_CHARS = [
                    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                    ' ', '$', '%', '*', '+', '-', '.', '/', ':'
                ]

                function AlphanumericData(data) {
                    this.mode = Mode.ALPHANUMERIC
                    this.data = data
                }

                AlphanumericData.getBitsLength = function getBitsLength(length) {
                    return 11 * Math.floor(length / 2) + 6 * (length % 2)
                }

                AlphanumericData.prototype.getLength = function getLength() {
                    return this.data.length
                }

                AlphanumericData.prototype.getBitsLength = function getBitsLength() {
                    return AlphanumericData.getBitsLength(this.data.length)
                }

                AlphanumericData.prototype.write = function write(bitBuffer) {
                    let i

                    // Input data characters are divided into groups of two characters
                    // and encoded as 11-bit binary codes.
                    for (i = 0; i + 2 <= this.data.length; i += 2) {
                        // The character value of the first character is multiplied by 45
                        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45

                        // The character value of the second digit is added to the product
                        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])

                        // The sum is then stored as 11-bit binary number
                        bitBuffer.put(value, 11)
                    }

                    // If the number of input data characters is not a multiple of two,
                    // the character value of the final character is encoded as a 6-bit binary number.
                    if (this.data.length % 2) {
                        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)
                    }
                }

                module.exports = AlphanumericData


                /***/
            }),

        /***/
        "nkTa":
            /***/
            ((module) => {

                function BitBuffer() {
                    this.buffer = []
                    this.length = 0
                }

                BitBuffer.prototype = {

                    get: function(index) {
                        const bufIndex = Math.floor(index / 8)
                        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
                    },

                    put: function(num, length) {
                        for (let i = 0; i < length; i++) {
                            this.putBit(((num >>> (length - i - 1)) & 1) === 1)
                        }
                    },

                    getLengthInBits: function() {
                        return this.length
                    },

                    putBit: function(bit) {
                        const bufIndex = Math.floor(this.length / 8)
                        if (this.buffer.length <= bufIndex) {
                            this.buffer.push(0)
                        }

                        if (bit) {
                            this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))
                        }

                        this.length++
                    }
                }

                module.exports = BitBuffer


                /***/
            }),

        /***/
        "BQSn":
            /***/
            ((module) => {

                /**
                 * Helper class to handle QR Code symbol modules
                 *
                 * @param {Number} size Symbol size
                 */
                function BitMatrix(size) {
                    if (!size || size < 1) {
                        throw new Error('BitMatrix size must be defined and greater than 0')
                    }

                    this.size = size
                    this.data = new Uint8Array(size * size)
                    this.reservedBit = new Uint8Array(size * size)
                }

                /**
                 * Set bit value at specified location
                 * If reserved flag is set, this bit will be ignored during masking process
                 *
                 * @param {Number}  row
                 * @param {Number}  col
                 * @param {Boolean} value
                 * @param {Boolean} reserved
                 */
                BitMatrix.prototype.set = function(row, col, value, reserved) {
                    const index = row * this.size + col
                    this.data[index] = value
                    if (reserved) this.reservedBit[index] = true
                }

                /**
                 * Returns bit value at specified location
                 *
                 * @param  {Number}  row
                 * @param  {Number}  col
                 * @return {Boolean}
                 */
                BitMatrix.prototype.get = function(row, col) {
                    return this.data[row * this.size + col]
                }

                /**
                 * Applies xor operator at specified location
                 * (used during masking process)
                 *
                 * @param {Number}  row
                 * @param {Number}  col
                 * @param {Boolean} value
                 */
                BitMatrix.prototype.xor = function(row, col, value) {
                    this.data[row * this.size + col] ^= value
                }

                /**
                 * Check if bit at specified location is reserved
                 *
                 * @param {Number}   row
                 * @param {Number}   col
                 * @return {Boolean}
                 */
                BitMatrix.prototype.isReserved = function(row, col) {
                    return this.reservedBit[row * this.size + col]
                }

                module.exports = BitMatrix


                /***/
            }),

        /***/
        "k0ef":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                const Mode = __webpack_require__("u8wY")

                function ByteData(data) {
                    this.mode = Mode.BYTE
                    if (typeof(data) === 'string') {
                        this.data = new TextEncoder().encode(data)
                    } else {
                        this.data = new Uint8Array(data)
                    }
                }

                ByteData.getBitsLength = function getBitsLength(length) {
                    return length * 8
                }

                ByteData.prototype.getLength = function getLength() {
                    return this.data.length
                }

                ByteData.prototype.getBitsLength = function getBitsLength() {
                    return ByteData.getBitsLength(this.data.length)
                }

                ByteData.prototype.write = function(bitBuffer) {
                    for (let i = 0, l = this.data.length; i < l; i++) {
                        bitBuffer.put(this.data[i], 8)
                    }
                }

                module.exports = ByteData


                /***/
            }),

        /***/
        "Dvwq":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const ECLevel = __webpack_require__("gp4+")

                const EC_BLOCKS_TABLE = [
                    // L  M  Q  H
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 2, 2,
                    1, 2, 2, 4,
                    1, 2, 4, 4,
                    2, 4, 4, 4,
                    2, 4, 6, 5,
                    2, 4, 6, 6,
                    2, 5, 8, 8,
                    4, 5, 8, 8,
                    4, 5, 8, 11,
                    4, 8, 10, 11,
                    4, 9, 12, 16,
                    4, 9, 16, 16,
                    6, 10, 12, 18,
                    6, 10, 17, 16,
                    6, 11, 16, 19,
                    6, 13, 18, 21,
                    7, 14, 21, 25,
                    8, 16, 20, 25,
                    8, 17, 23, 25,
                    9, 17, 23, 34,
                    9, 18, 25, 30,
                    10, 20, 27, 32,
                    12, 21, 29, 35,
                    12, 23, 34, 37,
                    12, 25, 34, 40,
                    13, 26, 35, 42,
                    14, 28, 38, 45,
                    15, 29, 40, 48,
                    16, 31, 43, 51,
                    17, 33, 45, 54,
                    18, 35, 48, 57,
                    19, 37, 51, 60,
                    19, 38, 53, 63,
                    20, 40, 56, 66,
                    21, 43, 59, 70,
                    22, 45, 62, 74,
                    24, 47, 65, 77,
                    25, 49, 68, 81
                ]

                const EC_CODEWORDS_TABLE = [
                    // L  M  Q  H
                    7, 10, 13, 17,
                    10, 16, 22, 28,
                    15, 26, 36, 44,
                    20, 36, 52, 64,
                    26, 48, 72, 88,
                    36, 64, 96, 112,
                    40, 72, 108, 130,
                    48, 88, 132, 156,
                    60, 110, 160, 192,
                    72, 130, 192, 224,
                    80, 150, 224, 264,
                    96, 176, 260, 308,
                    104, 198, 288, 352,
                    120, 216, 320, 384,
                    132, 240, 360, 432,
                    144, 280, 408, 480,
                    168, 308, 448, 532,
                    180, 338, 504, 588,
                    196, 364, 546, 650,
                    224, 416, 600, 700,
                    224, 442, 644, 750,
                    252, 476, 690, 816,
                    270, 504, 750, 900,
                    300, 560, 810, 960,
                    312, 588, 870, 1050,
                    336, 644, 952, 1110,
                    360, 700, 1020, 1200,
                    390, 728, 1050, 1260,
                    420, 784, 1140, 1350,
                    450, 812, 1200, 1440,
                    480, 868, 1290, 1530,
                    510, 924, 1350, 1620,
                    540, 980, 1440, 1710,
                    570, 1036, 1530, 1800,
                    570, 1064, 1590, 1890,
                    600, 1120, 1680, 1980,
                    630, 1204, 1770, 2100,
                    660, 1260, 1860, 2220,
                    720, 1316, 1950, 2310,
                    750, 1372, 2040, 2430
                ]

                /**
                 * Returns the number of error correction block that the QR Code should contain
                 * for the specified version and error correction level.
                 *
                 * @param  {Number} version              QR Code version
                 * @param  {Number} errorCorrectionLevel Error correction level
                 * @return {Number}                      Number of error correction blocks
                 */
                exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
                    switch (errorCorrectionLevel) {
                        case ECLevel.L:
                            return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
                        case ECLevel.M:
                            return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
                        case ECLevel.Q:
                            return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
                        case ECLevel.H:
                            return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
                        default:
                            return undefined
                    }
                }

                /**
                 * Returns the number of error correction codewords to use for the specified
                 * version and error correction level.
                 *
                 * @param  {Number} version              QR Code version
                 * @param  {Number} errorCorrectionLevel Error correction level
                 * @return {Number}                      Number of error correction codewords
                 */
                exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
                    switch (errorCorrectionLevel) {
                        case ECLevel.L:
                            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
                        case ECLevel.M:
                            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
                        case ECLevel.Q:
                            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
                        case ECLevel.H:
                            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
                        default:
                            return undefined
                    }
                }


                /***/
            }),

        /***/
        "gp4+":
            /***/
            ((__unused_webpack_module, exports) => {

                exports.L = {
                    bit: 1
                }
                exports.M = {
                    bit: 0
                }
                exports.Q = {
                    bit: 3
                }
                exports.H = {
                    bit: 2
                }

                function fromString(string) {
                    if (typeof string !== 'string') {
                        throw new Error('Param is not a string')
                    }

                    const lcStr = string.toLowerCase()

                    switch (lcStr) {
                        case 'l':
                        case 'low':
                            return exports.L

                        case 'm':
                        case 'medium':
                            return exports.M

                        case 'q':
                        case 'quartile':
                            return exports.Q

                        case 'h':
                        case 'high':
                            return exports.H

                        default:
                            throw new Error('Unknown EC Level: ' + string)
                    }
                }

                exports.isValid = function isValid(level) {
                    return level && typeof level.bit !== 'undefined' &&
                        level.bit >= 0 && level.bit < 4
                }

                exports.from = function from(value, defaultValue) {
                    if (exports.isValid(value)) {
                        return value
                    }

                    try {
                        return fromString(value)
                    } catch (e) {
                        return defaultValue
                    }
                }


                /***/
            }),

        /***/
        "Nmi9":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const getSymbolSize = (__webpack_require__("lr8Y").getSymbolSize)
                const FINDER_PATTERN_SIZE = 7

                /**
                 * Returns an array containing the positions of each finder pattern.
                 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
                 *
                 * @param  {Number} version QR Code version
                 * @return {Array}          Array of coordinates
                 */
                exports.getPositions = function getPositions(version) {
                    const size = getSymbolSize(version)

                    return [
                        // top-left
                        [0, 0],
                        // top-right
                        [size - FINDER_PATTERN_SIZE, 0],
                        // bottom-left
                        [0, size - FINDER_PATTERN_SIZE]
                    ]
                }


                /***/
            }),

        /***/
        "XsPz":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const Utils = __webpack_require__("lr8Y")

                const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)
                const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)
                const G15_BCH = Utils.getBCHDigit(G15)

                /**
                 * Returns format information with relative error correction bits
                 *
                 * The format information is a 15-bit sequence containing 5 data bits,
                 * with 10 error correction bits calculated using the (15, 5) BCH code.
                 *
                 * @param  {Number} errorCorrectionLevel Error correction level
                 * @param  {Number} mask                 Mask pattern
                 * @return {Number}                      Encoded format information bits
                 */
                exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
                    const data = ((errorCorrectionLevel.bit << 3) | mask)
                    let d = data << 10

                    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
                        d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))
                    }

                    // xor final data with mask pattern in order to ensure that
                    // no combination of Error Correction Level and data mask pattern
                    // will result in an all-zero data string
                    return ((data << 10) | d) ^ G15_MASK
                }


                /***/
            }),

        /***/
        "/qAS":
            /***/
            ((__unused_webpack_module, exports) => {

                const EXP_TABLE = new Uint8Array(512)
                const LOG_TABLE = new Uint8Array(256)
                /**
                 * Precompute the log and anti-log tables for faster computation later
                 *
                 * For each possible value in the galois field 2^8, we will pre-compute
                 * the logarithm and anti-logarithm (exponential) of this value
                 *
                 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
                 */
                ;
                (function initTables() {
                    let x = 1
                    for (let i = 0; i < 255; i++) {
                        EXP_TABLE[i] = x
                        LOG_TABLE[x] = i

                        x <<= 1 // multiply by 2

                        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
                        // This means that when a number is 256 or larger, it should be XORed with 0x11D.
                        if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
                            x ^= 0x11D
                        }
                    }

                    // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
                    // stay inside the bounds (because we will mainly use this table for the multiplication of
                    // two GF numbers, no more).
                    // @see {@link mul}
                    for (let i = 255; i < 512; i++) {
                        EXP_TABLE[i] = EXP_TABLE[i - 255]
                    }
                }())

                /**
                 * Returns log value of n inside Galois Field
                 *
                 * @param  {Number} n
                 * @return {Number}
                 */
                exports.log = function log(n) {
                    if (n < 1) throw new Error('log(' + n + ')')
                    return LOG_TABLE[n]
                }

                /**
                 * Returns anti-log value of n inside Galois Field
                 *
                 * @param  {Number} n
                 * @return {Number}
                 */
                exports.exp = function exp(n) {
                    return EXP_TABLE[n]
                }

                /**
                 * Multiplies two number inside Galois Field
                 *
                 * @param  {Number} x
                 * @param  {Number} y
                 * @return {Number}
                 */
                exports.mul = function mul(x, y) {
                    if (x === 0 || y === 0) return 0

                    // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
                    // @see {@link initTables}
                    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
                }


                /***/
            }),

        /***/
        "Rx1C":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                const Mode = __webpack_require__("u8wY")
                const Utils = __webpack_require__("lr8Y")

                function KanjiData(data) {
                    this.mode = Mode.KANJI
                    this.data = data
                }

                KanjiData.getBitsLength = function getBitsLength(length) {
                    return length * 13
                }

                KanjiData.prototype.getLength = function getLength() {
                    return this.data.length
                }

                KanjiData.prototype.getBitsLength = function getBitsLength() {
                    return KanjiData.getBitsLength(this.data.length)
                }

                KanjiData.prototype.write = function(bitBuffer) {
                    let i

                    // In the Shift JIS system, Kanji characters are represented by a two byte combination.
                    // These byte values are shifted from the JIS X 0208 values.
                    // JIS X 0208 gives details of the shift coded representation.
                    for (i = 0; i < this.data.length; i++) {
                        let value = Utils.toSJIS(this.data[i])

                        // For characters with Shift JIS values from 0x8140 to 0x9FFC:
                        if (value >= 0x8140 && value <= 0x9FFC) {
                            // Subtract 0x8140 from Shift JIS value
                            value -= 0x8140

                            // For characters with Shift JIS values from 0xE040 to 0xEBBF
                        } else if (value >= 0xE040 && value <= 0xEBBF) {
                            // Subtract 0xC140 from Shift JIS value
                            value -= 0xC140
                        } else {
                            throw new Error(
                                'Invalid SJIS character: ' + this.data[i] + '\n' +
                                'Make sure your charset is UTF-8')
                        }

                        // Multiply most significant byte of result by 0xC0
                        // and add least significant byte to product
                        value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)

                        // Convert result to a 13-bit binary string
                        bitBuffer.put(value, 13)
                    }
                }

                module.exports = KanjiData


                /***/
            }),

        /***/
        "H873":
            /***/
            ((__unused_webpack_module, exports) => {

                /**
                 * Data mask pattern reference
                 * @type {Object}
                 */
                exports.Patterns = {
                    PATTERN000: 0,
                    PATTERN001: 1,
                    PATTERN010: 2,
                    PATTERN011: 3,
                    PATTERN100: 4,
                    PATTERN101: 5,
                    PATTERN110: 6,
                    PATTERN111: 7
                }

                /**
                 * Weighted penalty scores for the undesirable features
                 * @type {Object}
                 */
                const PenaltyScores = {
                    N1: 3,
                    N2: 3,
                    N3: 40,
                    N4: 10
                }

                /**
                 * Check if mask pattern value is valid
                 *
                 * @param  {Number}  mask    Mask pattern
                 * @return {Boolean}         true if valid, false otherwise
                 */
                exports.isValid = function isValid(mask) {
                    return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
                }

                /**
                 * Returns mask pattern from a value.
                 * If value is not valid, returns undefined
                 *
                 * @param  {Number|String} value        Mask pattern value
                 * @return {Number}                     Valid mask pattern or undefined
                 */
                exports.from = function from(value) {
                    return exports.isValid(value) ? parseInt(value, 10) : undefined
                }

                /**
                 * Find adjacent modules in row/column with the same color
                 * and assign a penalty value.
                 *
                 * Points: N1 + i
                 * i is the amount by which the number of adjacent modules of the same color exceeds 5
                 */
                exports.getPenaltyN1 = function getPenaltyN1(data) {
                    const size = data.size
                    let points = 0
                    let sameCountCol = 0
                    let sameCountRow = 0
                    let lastCol = null
                    let lastRow = null

                    for (let row = 0; row < size; row++) {
                        sameCountCol = sameCountRow = 0
                        lastCol = lastRow = null

                        for (let col = 0; col < size; col++) {
                            let module = data.get(row, col)
                            if (module === lastCol) {
                                sameCountCol++
                            } else {
                                if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
                                lastCol = module
                                sameCountCol = 1
                            }

                            module = data.get(col, row)
                            if (module === lastRow) {
                                sameCountRow++
                            } else {
                                if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
                                lastRow = module
                                sameCountRow = 1
                            }
                        }

                        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
                        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
                    }

                    return points
                }

                /**
                 * Find 2x2 blocks with the same color and assign a penalty value
                 *
                 * Points: N2 * (m - 1) * (n - 1)
                 */
                exports.getPenaltyN2 = function getPenaltyN2(data) {
                    const size = data.size
                    let points = 0

                    for (let row = 0; row < size - 1; row++) {
                        for (let col = 0; col < size - 1; col++) {
                            const last = data.get(row, col) +
                                data.get(row, col + 1) +
                                data.get(row + 1, col) +
                                data.get(row + 1, col + 1)

                            if (last === 4 || last === 0) points++
                        }
                    }

                    return points * PenaltyScores.N2
                }

                /**
                 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
                 * preceded or followed by light area 4 modules wide
                 *
                 * Points: N3 * number of pattern found
                 */
                exports.getPenaltyN3 = function getPenaltyN3(data) {
                    const size = data.size
                    let points = 0
                    let bitsCol = 0
                    let bitsRow = 0

                    for (let row = 0; row < size; row++) {
                        bitsCol = bitsRow = 0
                        for (let col = 0; col < size; col++) {
                            bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)
                            if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++

                                bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)
                            if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++
                        }
                    }

                    return points * PenaltyScores.N3
                }

                /**
                 * Calculate proportion of dark modules in entire symbol
                 *
                 * Points: N4 * k
                 *
                 * k is the rating of the deviation of the proportion of dark modules
                 * in the symbol from 50% in steps of 5%
                 */
                exports.getPenaltyN4 = function getPenaltyN4(data) {
                    let darkCount = 0
                    const modulesCount = data.data.length

                    for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]

                    const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)

                    return k * PenaltyScores.N4
                }

                /**
                 * Return mask value at given position
                 *
                 * @param  {Number} maskPattern Pattern reference value
                 * @param  {Number} i           Row
                 * @param  {Number} j           Column
                 * @return {Boolean}            Mask value
                 */
                function getMaskAt(maskPattern, i, j) {
                    switch (maskPattern) {
                        case exports.Patterns.PATTERN000:
                            return (i + j) % 2 === 0
                        case exports.Patterns.PATTERN001:
                            return i % 2 === 0
                        case exports.Patterns.PATTERN010:
                            return j % 3 === 0
                        case exports.Patterns.PATTERN011:
                            return (i + j) % 3 === 0
                        case exports.Patterns.PATTERN100:
                            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
                        case exports.Patterns.PATTERN101:
                            return (i * j) % 2 + (i * j) % 3 === 0
                        case exports.Patterns.PATTERN110:
                            return ((i * j) % 2 + (i * j) % 3) % 2 === 0
                        case exports.Patterns.PATTERN111:
                            return ((i * j) % 3 + (i + j) % 2) % 2 === 0

                        default:
                            throw new Error('bad maskPattern:' + maskPattern)
                    }
                }

                /**
                 * Apply a mask pattern to a BitMatrix
                 *
                 * @param  {Number}    pattern Pattern reference number
                 * @param  {BitMatrix} data    BitMatrix data
                 */
                exports.applyMask = function applyMask(pattern, data) {
                    const size = data.size

                    for (let col = 0; col < size; col++) {
                        for (let row = 0; row < size; row++) {
                            if (data.isReserved(row, col)) continue
                            data.xor(row, col, getMaskAt(pattern, row, col))
                        }
                    }
                }

                /**
                 * Returns the best mask pattern for data
                 *
                 * @param  {BitMatrix} data
                 * @return {Number} Mask pattern reference number
                 */
                exports.getBestMask = function getBestMask(data, setupFormatFunc) {
                    const numPatterns = Object.keys(exports.Patterns).length
                    let bestPattern = 0
                    let lowerPenalty = Infinity

                    for (let p = 0; p < numPatterns; p++) {
                        setupFormatFunc(p)
                        exports.applyMask(p, data)

                        // Calculate penalty
                        const penalty =
                            exports.getPenaltyN1(data) +
                            exports.getPenaltyN2(data) +
                            exports.getPenaltyN3(data) +
                            exports.getPenaltyN4(data)

                        // Undo previously applied mask
                        exports.applyMask(p, data)

                        if (penalty < lowerPenalty) {
                            lowerPenalty = penalty
                            bestPattern = p
                        }
                    }

                    return bestPattern
                }


                /***/
            }),

        /***/
        "u8wY":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const VersionCheck = __webpack_require__("mVQ0")
                const Regex = __webpack_require__("ZREs")

                /**
                 * Numeric mode encodes data from the decimal digit set (0 - 9)
                 * (byte values 30HEX to 39HEX).
                 * Normally, 3 data characters are represented by 10 bits.
                 *
                 * @type {Object}
                 */
                exports.NUMERIC = {
                    id: 'Numeric',
                    bit: 1 << 0,
                    ccBits: [10, 12, 14]
                }

                /**
                 * Alphanumeric mode encodes data from a set of 45 characters,
                 * i.e. 10 numeric digits (0 - 9),
                 *      26 alphabetic characters (A - Z),
                 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
                 * Normally, two input characters are represented by 11 bits.
                 *
                 * @type {Object}
                 */
                exports.ALPHANUMERIC = {
                    id: 'Alphanumeric',
                    bit: 1 << 1,
                    ccBits: [9, 11, 13]
                }

                /**
                 * In byte mode, data is encoded at 8 bits per character.
                 *
                 * @type {Object}
                 */
                exports.BYTE = {
                    id: 'Byte',
                    bit: 1 << 2,
                    ccBits: [8, 16, 16]
                }

                /**
                 * The Kanji mode efficiently encodes Kanji characters in accordance with
                 * the Shift JIS system based on JIS X 0208.
                 * The Shift JIS values are shifted from the JIS X 0208 values.
                 * JIS X 0208 gives details of the shift coded representation.
                 * Each two-byte character value is compacted to a 13-bit binary codeword.
                 *
                 * @type {Object}
                 */
                exports.KANJI = {
                    id: 'Kanji',
                    bit: 1 << 3,
                    ccBits: [8, 10, 12]
                }

                /**
                 * Mixed mode will contain a sequences of data in a combination of any of
                 * the modes described above
                 *
                 * @type {Object}
                 */
                exports.MIXED = {
                    bit: -1
                }

                /**
                 * Returns the number of bits needed to store the data length
                 * according to QR Code specifications.
                 *
                 * @param  {Mode}   mode    Data mode
                 * @param  {Number} version QR Code version
                 * @return {Number}         Number of bits
                 */
                exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
                    if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

                    if (!VersionCheck.isValid(version)) {
                        throw new Error('Invalid version: ' + version)
                    }

                    if (version >= 1 && version < 10) return mode.ccBits[0]
                    else if (version < 27) return mode.ccBits[1]
                    return mode.ccBits[2]
                }

                /**
                 * Returns the most efficient mode to store the specified data
                 *
                 * @param  {String} dataStr Input data string
                 * @return {Mode}           Best mode
                 */
                exports.getBestModeForData = function getBestModeForData(dataStr) {
                    if (Regex.testNumeric(dataStr)) return exports.NUMERIC
                    else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
                    else if (Regex.testKanji(dataStr)) return exports.KANJI
                    else return exports.BYTE
                }

                /**
                 * Return mode name as string
                 *
                 * @param {Mode} mode Mode object
                 * @returns {String}  Mode name
                 */
                exports.toString = function toString(mode) {
                    if (mode && mode.id) return mode.id
                    throw new Error('Invalid mode')
                }

                /**
                 * Check if input param is a valid mode object
                 *
                 * @param   {Mode}    mode Mode object
                 * @returns {Boolean} True if valid mode, false otherwise
                 */
                exports.isValid = function isValid(mode) {
                    return mode && mode.bit && mode.ccBits
                }

                /**
                 * Get mode object from its name
                 *
                 * @param   {String} string Mode name
                 * @returns {Mode}          Mode object
                 */
                function fromString(string) {
                    if (typeof string !== 'string') {
                        throw new Error('Param is not a string')
                    }

                    const lcStr = string.toLowerCase()

                    switch (lcStr) {
                        case 'numeric':
                            return exports.NUMERIC
                        case 'alphanumeric':
                            return exports.ALPHANUMERIC
                        case 'kanji':
                            return exports.KANJI
                        case 'byte':
                            return exports.BYTE
                        default:
                            throw new Error('Unknown mode: ' + string)
                    }
                }

                /**
                 * Returns mode from a value.
                 * If value is not a valid mode, returns defaultValue
                 *
                 * @param  {Mode|String} value        Encoding mode
                 * @param  {Mode}        defaultValue Fallback value
                 * @return {Mode}                     Encoding mode
                 */
                exports.from = function from(value, defaultValue) {
                    if (exports.isValid(value)) {
                        return value
                    }

                    try {
                        return fromString(value)
                    } catch (e) {
                        return defaultValue
                    }
                }


                /***/
            }),

        /***/
        "nQfA":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                const Mode = __webpack_require__("u8wY")

                function NumericData(data) {
                    this.mode = Mode.NUMERIC
                    this.data = data.toString()
                }

                NumericData.getBitsLength = function getBitsLength(length) {
                    return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
                }

                NumericData.prototype.getLength = function getLength() {
                    return this.data.length
                }

                NumericData.prototype.getBitsLength = function getBitsLength() {
                    return NumericData.getBitsLength(this.data.length)
                }

                NumericData.prototype.write = function write(bitBuffer) {
                    let i, group, value

                    // The input data string is divided into groups of three digits,
                    // and each group is converted to its 10-bit binary equivalent.
                    for (i = 0; i + 3 <= this.data.length; i += 3) {
                        group = this.data.substr(i, 3)
                        value = parseInt(group, 10)

                        bitBuffer.put(value, 10)
                    }

                    // If the number of input digits is not an exact multiple of three,
                    // the final one or two digits are converted to 4 or 7 bits respectively.
                    const remainingNum = this.data.length - i
                    if (remainingNum > 0) {
                        group = this.data.substr(i)
                        value = parseInt(group, 10)

                        bitBuffer.put(value, remainingNum * 3 + 1)
                    }
                }

                module.exports = NumericData


                /***/
            }),

        /***/
        "p0ui":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const GF = __webpack_require__("/qAS")

                /**
                 * Multiplies two polynomials inside Galois Field
                 *
                 * @param  {Uint8Array} p1 Polynomial
                 * @param  {Uint8Array} p2 Polynomial
                 * @return {Uint8Array}    Product of p1 and p2
                 */
                exports.mul = function mul(p1, p2) {
                    const coeff = new Uint8Array(p1.length + p2.length - 1)

                    for (let i = 0; i < p1.length; i++) {
                        for (let j = 0; j < p2.length; j++) {
                            coeff[i + j] ^= GF.mul(p1[i], p2[j])
                        }
                    }

                    return coeff
                }

                /**
                 * Calculate the remainder of polynomials division
                 *
                 * @param  {Uint8Array} divident Polynomial
                 * @param  {Uint8Array} divisor  Polynomial
                 * @return {Uint8Array}          Remainder
                 */
                exports.mod = function mod(divident, divisor) {
                    let result = new Uint8Array(divident)

                    while ((result.length - divisor.length) >= 0) {
                        const coeff = result[0]

                        for (let i = 0; i < divisor.length; i++) {
                            result[i] ^= GF.mul(divisor[i], coeff)
                        }

                        // remove all zeros from buffer head
                        let offset = 0
                        while (offset < result.length && result[offset] === 0) offset++
                            result = result.slice(offset)
                    }

                    return result
                }

                /**
                 * Generate an irreducible generator polynomial of specified degree
                 * (used by Reed-Solomon encoder)
                 *
                 * @param  {Number} degree Degree of the generator polynomial
                 * @return {Uint8Array}    Buffer containing polynomial coefficients
                 */
                exports.generateECPolynomial = function generateECPolynomial(degree) {
                    let poly = new Uint8Array([1])
                    for (let i = 0; i < degree; i++) {
                        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))
                    }

                    return poly
                }


                /***/
            }),

        /***/
        "YOh+":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const Utils = __webpack_require__("lr8Y")
                const ECLevel = __webpack_require__("gp4+")
                const BitBuffer = __webpack_require__("nkTa")
                const BitMatrix = __webpack_require__("BQSn")
                const AlignmentPattern = __webpack_require__("teuN")
                const FinderPattern = __webpack_require__("Nmi9")
                const MaskPattern = __webpack_require__("H873")
                const ECCode = __webpack_require__("Dvwq")
                const ReedSolomonEncoder = __webpack_require__("DpGt")
                const Version = __webpack_require__("ayUG")
                const FormatInfo = __webpack_require__("XsPz")
                const Mode = __webpack_require__("u8wY")
                const Segments = __webpack_require__("lsmn")

                /**
                 * QRCode for JavaScript
                 *
                 * modified by Ryan Day for nodejs support
                 * Copyright (c) 2011 Ryan Day
                 *
                 * Licensed under the MIT license:
                 *   http://www.opensource.org/licenses/mit-license.php
                 *
                //---------------------------------------------------------------------
                // QRCode for JavaScript
                //
                // Copyright (c) 2009 Kazuhiko Arase
                //
                // URL: http://www.d-project.com/
                //
                // Licensed under the MIT license:
                //   http://www.opensource.org/licenses/mit-license.php
                //
                // The word "QR Code" is registered trademark of
                // DENSO WAVE INCORPORATED
                //   http://www.denso-wave.com/qrcode/faqpatent-e.html
                //
                //---------------------------------------------------------------------
                */

                /**
                 * Add finder patterns bits to matrix
                 *
                 * @param  {BitMatrix} matrix  Modules matrix
                 * @param  {Number}    version QR Code version
                 */
                function setupFinderPattern(matrix, version) {
                    const size = matrix.size
                    const pos = FinderPattern.getPositions(version)

                    for (let i = 0; i < pos.length; i++) {
                        const row = pos[i][0]
                        const col = pos[i][1]

                        for (let r = -1; r <= 7; r++) {
                            if (row + r <= -1 || size <= row + r) continue

                            for (let c = -1; c <= 7; c++) {
                                if (col + c <= -1 || size <= col + c) continue

                                if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
                                    (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
                                    (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
                                    matrix.set(row + r, col + c, true, true)
                                } else {
                                    matrix.set(row + r, col + c, false, true)
                                }
                            }
                        }
                    }
                }

                /**
                 * Add timing pattern bits to matrix
                 *
                 * Note: this function must be called before {@link setupAlignmentPattern}
                 *
                 * @param  {BitMatrix} matrix Modules matrix
                 */
                function setupTimingPattern(matrix) {
                    const size = matrix.size

                    for (let r = 8; r < size - 8; r++) {
                        const value = r % 2 === 0
                        matrix.set(r, 6, value, true)
                        matrix.set(6, r, value, true)
                    }
                }

                /**
                 * Add alignment patterns bits to matrix
                 *
                 * Note: this function must be called after {@link setupTimingPattern}
                 *
                 * @param  {BitMatrix} matrix  Modules matrix
                 * @param  {Number}    version QR Code version
                 */
                function setupAlignmentPattern(matrix, version) {
                    const pos = AlignmentPattern.getPositions(version)

                    for (let i = 0; i < pos.length; i++) {
                        const row = pos[i][0]
                        const col = pos[i][1]

                        for (let r = -2; r <= 2; r++) {
                            for (let c = -2; c <= 2; c++) {
                                if (r === -2 || r === 2 || c === -2 || c === 2 ||
                                    (r === 0 && c === 0)) {
                                    matrix.set(row + r, col + c, true, true)
                                } else {
                                    matrix.set(row + r, col + c, false, true)
                                }
                            }
                        }
                    }
                }

                /**
                 * Add version info bits to matrix
                 *
                 * @param  {BitMatrix} matrix  Modules matrix
                 * @param  {Number}    version QR Code version
                 */
                function setupVersionInfo(matrix, version) {
                    const size = matrix.size
                    const bits = Version.getEncodedBits(version)
                    let row, col, mod

                    for (let i = 0; i < 18; i++) {
                        row = Math.floor(i / 3)
                        col = i % 3 + size - 8 - 3
                        mod = ((bits >> i) & 1) === 1

                        matrix.set(row, col, mod, true)
                        matrix.set(col, row, mod, true)
                    }
                }

                /**
                 * Add format info bits to matrix
                 *
                 * @param  {BitMatrix} matrix               Modules matrix
                 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
                 * @param  {Number}    maskPattern          Mask pattern reference value
                 */
                function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
                    const size = matrix.size
                    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)
                    let i, mod

                    for (i = 0; i < 15; i++) {
                        mod = ((bits >> i) & 1) === 1

                        // vertical
                        if (i < 6) {
                            matrix.set(i, 8, mod, true)
                        } else if (i < 8) {
                            matrix.set(i + 1, 8, mod, true)
                        } else {
                            matrix.set(size - 15 + i, 8, mod, true)
                        }

                        // horizontal
                        if (i < 8) {
                            matrix.set(8, size - i - 1, mod, true)
                        } else if (i < 9) {
                            matrix.set(8, 15 - i - 1 + 1, mod, true)
                        } else {
                            matrix.set(8, 15 - i - 1, mod, true)
                        }
                    }

                    // fixed module
                    matrix.set(size - 8, 8, 1, true)
                }

                /**
                 * Add encoded data bits to matrix
                 *
                 * @param  {BitMatrix}  matrix Modules matrix
                 * @param  {Uint8Array} data   Data codewords
                 */
                function setupData(matrix, data) {
                    const size = matrix.size
                    let inc = -1
                    let row = size - 1
                    let bitIndex = 7
                    let byteIndex = 0

                    for (let col = size - 1; col > 0; col -= 2) {
                        if (col === 6) col--

                            while (true) {
                                for (let c = 0; c < 2; c++) {
                                    if (!matrix.isReserved(row, col - c)) {
                                        let dark = false

                                        if (byteIndex < data.length) {
                                            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)
                                        }

                                        matrix.set(row, col - c, dark)
                                        bitIndex--

                                        if (bitIndex === -1) {
                                            byteIndex++
                                            bitIndex = 7
                                        }
                                    }
                                }

                                row += inc

                                if (row < 0 || size <= row) {
                                    row -= inc
                                    inc = -inc
                                    break
                                }
                            }
                    }
                }

                /**
                 * Create encoded codewords from data input
                 *
                 * @param  {Number}   version              QR Code version
                 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
                 * @param  {ByteData} data                 Data input
                 * @return {Uint8Array}                    Buffer containing encoded codewords
                 */
                function createData(version, errorCorrectionLevel, segments) {
                    // Prepare data buffer
                    const buffer = new BitBuffer()

                    segments.forEach(function(data) {
                        // prefix data with mode indicator (4 bits)
                        buffer.put(data.mode.bit, 4)

                        // Prefix data with character count indicator.
                        // The character count indicator is a string of bits that represents the
                        // number of characters that are being encoded.
                        // The character count indicator must be placed after the mode indicator
                        // and must be a certain number of bits long, depending on the QR version
                        // and data mode
                        // @see {@link Mode.getCharCountIndicator}.
                        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))

                        // add binary data sequence to buffer
                        data.write(buffer)
                    })

                    // Calculate required number of bits
                    const totalCodewords = Utils.getSymbolTotalCodewords(version)
                    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)
                    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8

                    // Add a terminator.
                    // If the bit string is shorter than the total number of required bits,
                    // a terminator of up to four 0s must be added to the right side of the string.
                    // If the bit string is more than four bits shorter than the required number of bits,
                    // add four 0s to the end.
                    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
                        buffer.put(0, 4)
                    }

                    // If the bit string is fewer than four bits shorter, add only the number of 0s that
                    // are needed to reach the required number of bits.

                    // After adding the terminator, if the number of bits in the string is not a multiple of 8,
                    // pad the string on the right with 0s to make the string's length a multiple of 8.
                    while (buffer.getLengthInBits() % 8 !== 0) {
                        buffer.putBit(0)
                    }

                    // Add pad bytes if the string is still shorter than the total number of required bits.
                    // Extend the buffer to fill the data capacity of the symbol corresponding to
                    // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
                    // and 00010001 (0x11) alternately.
                    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8
                    for (let i = 0; i < remainingByte; i++) {
                        buffer.put(i % 2 ? 0x11 : 0xEC, 8)
                    }

                    return createCodewords(buffer, version, errorCorrectionLevel)
                }

                /**
                 * Encode input data with Reed-Solomon and return codewords with
                 * relative error correction bits
                 *
                 * @param  {BitBuffer} bitBuffer            Data to encode
                 * @param  {Number}    version              QR Code version
                 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
                 * @return {Uint8Array}                     Buffer containing encoded codewords
                 */
                function createCodewords(bitBuffer, version, errorCorrectionLevel) {
                    // Total codewords for this QR code version (Data + Error correction)
                    const totalCodewords = Utils.getSymbolTotalCodewords(version)

                    // Total number of error correction codewords
                    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)

                    // Total number of data codewords
                    const dataTotalCodewords = totalCodewords - ecTotalCodewords

                    // Total number of blocks
                    const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)

                    // Calculate how many blocks each group should contain
                    const blocksInGroup2 = totalCodewords % ecTotalBlocks
                    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2

                    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)

                    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)
                    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1

                    // Number of EC codewords is the same for both groups
                    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1

                    // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
                    const rs = new ReedSolomonEncoder(ecCount)

                    let offset = 0
                    const dcData = new Array(ecTotalBlocks)
                    const ecData = new Array(ecTotalBlocks)
                    let maxDataSize = 0
                    const buffer = new Uint8Array(bitBuffer.buffer)

                    // Divide the buffer into the required number of blocks
                    for (let b = 0; b < ecTotalBlocks; b++) {
                        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2

                        // extract a block of data from buffer
                        dcData[b] = buffer.slice(offset, offset + dataSize)

                        // Calculate EC codewords for this data block
                        ecData[b] = rs.encode(dcData[b])

                        offset += dataSize
                        maxDataSize = Math.max(maxDataSize, dataSize)
                    }

                    // Create final data
                    // Interleave the data and error correction codewords from each block
                    const data = new Uint8Array(totalCodewords)
                    let index = 0
                    let i, r

                    // Add data codewords
                    for (i = 0; i < maxDataSize; i++) {
                        for (r = 0; r < ecTotalBlocks; r++) {
                            if (i < dcData[r].length) {
                                data[index++] = dcData[r][i]
                            }
                        }
                    }

                    // Apped EC codewords
                    for (i = 0; i < ecCount; i++) {
                        for (r = 0; r < ecTotalBlocks; r++) {
                            data[index++] = ecData[r][i]
                        }
                    }

                    return data
                }

                /**
                 * Build QR Code symbol
                 *
                 * @param  {String} data                 Input string
                 * @param  {Number} version              QR Code version
                 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
                 * @param  {MaskPattern} maskPattern     Mask pattern
                 * @return {Object}                      Object containing symbol data
                 */
                function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
                    let segments

                    if (Array.isArray(data)) {
                        segments = Segments.fromArray(data)
                    } else if (typeof data === 'string') {
                        let estimatedVersion = version

                        if (!estimatedVersion) {
                            const rawSegments = Segments.rawSplit(data)

                            // Estimate best version that can contain raw splitted segments
                            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)
                        }

                        // Build optimized segments
                        // If estimated version is undefined, try with the highest version
                        segments = Segments.fromString(data, estimatedVersion || 40)
                    } else {
                        throw new Error('Invalid data')
                    }

                    // Get the min version that can contain data
                    const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)

                    // If no version is found, data cannot be stored
                    if (!bestVersion) {
                        throw new Error('The amount of data is too big to be stored in a QR Code')
                    }

                    // If not specified, use min version as default
                    if (!version) {
                        version = bestVersion

                        // Check if the specified version can contain the data
                    } else if (version < bestVersion) {
                        throw new Error('\n' +
                            'The chosen QR Code version cannot contain this amount of data.\n' +
                            'Minimum version required to store current data is: ' + bestVersion + '.\n'
                        )
                    }

                    const dataBits = createData(version, errorCorrectionLevel, segments)

                    // Allocate matrix buffer
                    const moduleCount = Utils.getSymbolSize(version)
                    const modules = new BitMatrix(moduleCount)

                    // Add function modules
                    setupFinderPattern(modules, version)
                    setupTimingPattern(modules)
                    setupAlignmentPattern(modules, version)

                    // Add temporary dummy bits for format info just to set them as reserved.
                    // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
                    // since the masking operation must be performed only on the encoding region.
                    // These blocks will be replaced with correct values later in code.
                    setupFormatInfo(modules, errorCorrectionLevel, 0)

                    if (version >= 7) {
                        setupVersionInfo(modules, version)
                    }

                    // Add data codewords
                    setupData(modules, dataBits)

                    if (isNaN(maskPattern)) {
                        // Find best mask pattern
                        maskPattern = MaskPattern.getBestMask(modules,
                            setupFormatInfo.bind(null, modules, errorCorrectionLevel))
                    }

                    // Apply mask pattern
                    MaskPattern.applyMask(maskPattern, modules)

                    // Replace format info bits with correct values
                    setupFormatInfo(modules, errorCorrectionLevel, maskPattern)

                    return {
                        modules: modules,
                        version: version,
                        errorCorrectionLevel: errorCorrectionLevel,
                        maskPattern: maskPattern,
                        segments: segments
                    }
                }

                /**
                 * QR Code
                 *
                 * @param {String | Array} data                 Input data
                 * @param {Object} options                      Optional configurations
                 * @param {Number} options.version              QR Code version
                 * @param {String} options.errorCorrectionLevel Error correction level
                 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
                 */
                exports.create = function create(data, options) {
                    if (typeof data === 'undefined' || data === '') {
                        throw new Error('No input text')
                    }

                    let errorCorrectionLevel = ECLevel.M
                    let version
                    let mask

                    if (typeof options !== 'undefined') {
                        // Use higher error correction level as default
                        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)
                        version = Version.from(options.version)
                        mask = MaskPattern.from(options.maskPattern)

                        if (options.toSJISFunc) {
                            Utils.setToSJISFunction(options.toSJISFunc)
                        }
                    }

                    return createSymbol(data, version, errorCorrectionLevel, mask)
                }


                /***/
            }),

        /***/
        "DpGt":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                const Polynomial = __webpack_require__("p0ui")

                function ReedSolomonEncoder(degree) {
                    this.genPoly = undefined
                    this.degree = degree

                    if (this.degree) this.initialize(this.degree)
                }

                /**
                 * Initialize the encoder.
                 * The input param should correspond to the number of error correction codewords.
                 *
                 * @param  {Number} degree
                 */
                ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
                    // create an irreducible generator polynomial
                    this.degree = degree
                    this.genPoly = Polynomial.generateECPolynomial(this.degree)
                }

                /**
                 * Encodes a chunk of data
                 *
                 * @param  {Uint8Array} data Buffer containing input data
                 * @return {Uint8Array}      Buffer containing encoded data
                 */
                ReedSolomonEncoder.prototype.encode = function encode(data) {
                    if (!this.genPoly) {
                        throw new Error('Encoder not initialized')
                    }

                    // Calculate EC for this data block
                    // extends data size to data+genPoly size
                    const paddedData = new Uint8Array(data.length + this.degree)
                    paddedData.set(data)

                    // The error correction codewords are the remainder after dividing the data codewords
                    // by a generator polynomial
                    const remainder = Polynomial.mod(paddedData, this.genPoly)

                    // return EC data blocks (last n byte, where n is the degree of genPoly)
                    // If coefficients number in remainder are less than genPoly degree,
                    // pad with 0s to the left to reach the needed number of coefficients
                    const start = this.degree - remainder.length
                    if (start > 0) {
                        const buff = new Uint8Array(this.degree)
                        buff.set(remainder, start)

                        return buff
                    }

                    return remainder
                }

                module.exports = ReedSolomonEncoder


                /***/
            }),

        /***/
        "ZREs":
            /***/
            ((__unused_webpack_module, exports) => {

                const numeric = '[0-9]+'
                const alphanumeric = '[A-Z $%*+\\-./:]+'
                let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
                    '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
                    '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
                    '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'
                kanji = kanji.replace(/u/g, '\\u')

                const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+'

                exports.KANJI = new RegExp(kanji, 'g')
                exports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g')
                exports.BYTE = new RegExp(byte, 'g')
                exports.NUMERIC = new RegExp(numeric, 'g')
                exports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')

                const TEST_KANJI = new RegExp('^' + kanji + '$')
                const TEST_NUMERIC = new RegExp('^' + numeric + '$')
                const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$')

                exports.testKanji = function testKanji(str) {
                    return TEST_KANJI.test(str)
                }

                exports.testNumeric = function testNumeric(str) {
                    return TEST_NUMERIC.test(str)
                }

                exports.testAlphanumeric = function testAlphanumeric(str) {
                    return TEST_ALPHANUMERIC.test(str)
                }


                /***/
            }),

        /***/
        "lsmn":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const Mode = __webpack_require__("u8wY")
                const NumericData = __webpack_require__("nQfA")
                const AlphanumericData = __webpack_require__("aob+")
                const ByteData = __webpack_require__("k0ef")
                const KanjiData = __webpack_require__("Rx1C")
                const Regex = __webpack_require__("ZREs")
                const Utils = __webpack_require__("lr8Y")
                const dijkstra = __webpack_require__("OyDd")

                /**
                 * Returns UTF8 byte length
                 *
                 * @param  {String} str Input string
                 * @return {Number}     Number of byte
                 */
                function getStringByteLength(str) {
                    return unescape(encodeURIComponent(str)).length
                }

                /**
                 * Get a list of segments of the specified mode
                 * from a string
                 *
                 * @param  {Mode}   mode Segment mode
                 * @param  {String} str  String to process
                 * @return {Array}       Array of object with segments data
                 */
                function getSegments(regex, mode, str) {
                    const segments = []
                    let result

                    while ((result = regex.exec(str)) !== null) {
                        segments.push({
                            data: result[0],
                            index: result.index,
                            mode: mode,
                            length: result[0].length
                        })
                    }

                    return segments
                }

                /**
                 * Extracts a series of segments with the appropriate
                 * modes from a string
                 *
                 * @param  {String} dataStr Input string
                 * @return {Array}          Array of object with segments data
                 */
                function getSegmentsFromString(dataStr) {
                    const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)
                    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)
                    let byteSegs
                    let kanjiSegs

                    if (Utils.isKanjiModeEnabled()) {
                        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)
                        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)
                    } else {
                        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)
                        kanjiSegs = []
                    }

                    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)

                    return segs
                        .sort(function(s1, s2) {
                            return s1.index - s2.index
                        })
                        .map(function(obj) {
                            return {
                                data: obj.data,
                                mode: obj.mode,
                                length: obj.length
                            }
                        })
                }

                /**
                 * Returns how many bits are needed to encode a string of
                 * specified length with the specified mode
                 *
                 * @param  {Number} length String length
                 * @param  {Mode} mode     Segment mode
                 * @return {Number}        Bit length
                 */
                function getSegmentBitsLength(length, mode) {
                    switch (mode) {
                        case Mode.NUMERIC:
                            return NumericData.getBitsLength(length)
                        case Mode.ALPHANUMERIC:
                            return AlphanumericData.getBitsLength(length)
                        case Mode.KANJI:
                            return KanjiData.getBitsLength(length)
                        case Mode.BYTE:
                            return ByteData.getBitsLength(length)
                    }
                }

                /**
                 * Merges adjacent segments which have the same mode
                 *
                 * @param  {Array} segs Array of object with segments data
                 * @return {Array}      Array of object with segments data
                 */
                function mergeSegments(segs) {
                    return segs.reduce(function(acc, curr) {
                        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null
                        if (prevSeg && prevSeg.mode === curr.mode) {
                            acc[acc.length - 1].data += curr.data
                            return acc
                        }

                        acc.push(curr)
                        return acc
                    }, [])
                }

                /**
                 * Generates a list of all possible nodes combination which
                 * will be used to build a segments graph.
                 *
                 * Nodes are divided by groups. Each group will contain a list of all the modes
                 * in which is possible to encode the given text.
                 *
                 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
                 * The group for '12345' will contain then 3 objects, one for each
                 * possible encoding mode.
                 *
                 * Each node represents a possible segment.
                 *
                 * @param  {Array} segs Array of object with segments data
                 * @return {Array}      Array of object with segments data
                 */
                function buildNodes(segs) {
                    const nodes = []
                    for (let i = 0; i < segs.length; i++) {
                        const seg = segs[i]

                        switch (seg.mode) {
                            case Mode.NUMERIC:
                                nodes.push([seg,
                                    {
                                        data: seg.data,
                                        mode: Mode.ALPHANUMERIC,
                                        length: seg.length
                                    },
                                    {
                                        data: seg.data,
                                        mode: Mode.BYTE,
                                        length: seg.length
                                    }
                                ])
                                break
                            case Mode.ALPHANUMERIC:
                                nodes.push([seg,
                                    {
                                        data: seg.data,
                                        mode: Mode.BYTE,
                                        length: seg.length
                                    }
                                ])
                                break
                            case Mode.KANJI:
                                nodes.push([seg,
                                    {
                                        data: seg.data,
                                        mode: Mode.BYTE,
                                        length: getStringByteLength(seg.data)
                                    }
                                ])
                                break
                            case Mode.BYTE:
                                nodes.push([{
                                    data: seg.data,
                                    mode: Mode.BYTE,
                                    length: getStringByteLength(seg.data)
                                }])
                        }
                    }

                    return nodes
                }

                /**
                 * Builds a graph from a list of nodes.
                 * All segments in each node group will be connected with all the segments of
                 * the next group and so on.
                 *
                 * At each connection will be assigned a weight depending on the
                 * segment's byte length.
                 *
                 * @param  {Array} nodes    Array of object with segments data
                 * @param  {Number} version QR Code version
                 * @return {Object}         Graph of all possible segments
                 */
                function buildGraph(nodes, version) {
                    const table = {}
                    const graph = {
                        start: {}
                    }
                    let prevNodeIds = ['start']

                    for (let i = 0; i < nodes.length; i++) {
                        const nodeGroup = nodes[i]
                        const currentNodeIds = []

                        for (let j = 0; j < nodeGroup.length; j++) {
                            const node = nodeGroup[j]
                            const key = '' + i + j

                            currentNodeIds.push(key)
                            table[key] = {
                                node: node,
                                lastCount: 0
                            }
                            graph[key] = {}

                            for (let n = 0; n < prevNodeIds.length; n++) {
                                const prevNodeId = prevNodeIds[n]

                                if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                                    graph[prevNodeId][key] =
                                        getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
                                        getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)

                                    table[prevNodeId].lastCount += node.length
                                } else {
                                    if (table[prevNodeId]) table[prevNodeId].lastCount = node.length

                                    graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
                                        4 + Mode.getCharCountIndicator(node.mode, version) // switch cost
                                }
                            }
                        }

                        prevNodeIds = currentNodeIds
                    }

                    for (let n = 0; n < prevNodeIds.length; n++) {
                        graph[prevNodeIds[n]].end = 0
                    }

                    return {
                        map: graph,
                        table: table
                    }
                }

                /**
                 * Builds a segment from a specified data and mode.
                 * If a mode is not specified, the more suitable will be used.
                 *
                 * @param  {String} data             Input data
                 * @param  {Mode | String} modesHint Data mode
                 * @return {Segment}                 Segment
                 */
                function buildSingleSegment(data, modesHint) {
                    let mode
                    const bestMode = Mode.getBestModeForData(data)

                    mode = Mode.from(modesHint, bestMode)

                    // Make sure data can be encoded
                    if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
                        throw new Error('"' + data + '"' +
                            ' cannot be encoded with mode ' + Mode.toString(mode) +
                            '.\n Suggested mode is: ' + Mode.toString(bestMode))
                    }

                    // Use Mode.BYTE if Kanji support is disabled
                    if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
                        mode = Mode.BYTE
                    }

                    switch (mode) {
                        case Mode.NUMERIC:
                            return new NumericData(data)

                        case Mode.ALPHANUMERIC:
                            return new AlphanumericData(data)

                        case Mode.KANJI:
                            return new KanjiData(data)

                        case Mode.BYTE:
                            return new ByteData(data)
                    }
                }

                /**
                 * Builds a list of segments from an array.
                 * Array can contain Strings or Objects with segment's info.
                 *
                 * For each item which is a string, will be generated a segment with the given
                 * string and the more appropriate encoding mode.
                 *
                 * For each item which is an object, will be generated a segment with the given
                 * data and mode.
                 * Objects must contain at least the property "data".
                 * If property "mode" is not present, the more suitable mode will be used.
                 *
                 * @param  {Array} array Array of objects with segments data
                 * @return {Array}       Array of Segments
                 */
                exports.fromArray = function fromArray(array) {
                    return array.reduce(function(acc, seg) {
                        if (typeof seg === 'string') {
                            acc.push(buildSingleSegment(seg, null))
                        } else if (seg.data) {
                            acc.push(buildSingleSegment(seg.data, seg.mode))
                        }

                        return acc
                    }, [])
                }

                /**
                 * Builds an optimized sequence of segments from a string,
                 * which will produce the shortest possible bitstream.
                 *
                 * @param  {String} data    Input string
                 * @param  {Number} version QR Code version
                 * @return {Array}          Array of segments
                 */
                exports.fromString = function fromString(data, version) {
                    const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())

                    const nodes = buildNodes(segs)
                    const graph = buildGraph(nodes, version)
                    const path = dijkstra.find_path(graph.map, 'start', 'end')

                    const optimizedSegs = []
                    for (let i = 1; i < path.length - 1; i++) {
                        optimizedSegs.push(graph.table[path[i]].node)
                    }

                    return exports.fromArray(mergeSegments(optimizedSegs))
                }

                /**
                 * Splits a string in various segments with the modes which
                 * best represent their content.
                 * The produced segments are far from being optimized.
                 * The output of this function is only used to estimate a QR Code version
                 * which may contain the data.
                 *
                 * @param  {string} data Input string
                 * @return {Array}       Array of segments
                 */
                exports.rawSplit = function rawSplit(data) {
                    return exports.fromArray(
                        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
                    )
                }


                /***/
            }),

        /***/
        "lr8Y":
            /***/
            ((__unused_webpack_module, exports) => {

                let toSJISFunction
                const CODEWORDS_COUNT = [
                    0, // Not used
                    26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
                    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
                    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
                    2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
                ]

                /**
                 * Returns the QR Code size for the specified version
                 *
                 * @param  {Number} version QR Code version
                 * @return {Number}         size of QR code
                 */
                exports.getSymbolSize = function getSymbolSize(version) {
                    if (!version) throw new Error('"version" cannot be null or undefined')
                    if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
                    return version * 4 + 17
                }

                /**
                 * Returns the total number of codewords used to store data and EC information.
                 *
                 * @param  {Number} version QR Code version
                 * @return {Number}         Data length in bits
                 */
                exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
                    return CODEWORDS_COUNT[version]
                }

                /**
                 * Encode data with Bose-Chaudhuri-Hocquenghem
                 *
                 * @param  {Number} data Value to encode
                 * @return {Number}      Encoded value
                 */
                exports.getBCHDigit = function(data) {
                    let digit = 0

                    while (data !== 0) {
                        digit++
                        data >>>= 1
                    }

                    return digit
                }

                exports.setToSJISFunction = function setToSJISFunction(f) {
                    if (typeof f !== 'function') {
                        throw new Error('"toSJISFunc" is not a valid function.')
                    }

                    toSJISFunction = f
                }

                exports.isKanjiModeEnabled = function() {
                    return typeof toSJISFunction !== 'undefined'
                }

                exports.toSJIS = function toSJIS(kanji) {
                    return toSJISFunction(kanji)
                }


                /***/
            }),

        /***/
        "mVQ0":
            /***/
            ((__unused_webpack_module, exports) => {

                /**
                 * Check if QR Code version is valid
                 *
                 * @param  {Number}  version QR Code version
                 * @return {Boolean}         true if valid version, false otherwise
                 */
                exports.isValid = function isValid(version) {
                    return !isNaN(version) && version >= 1 && version <= 40
                }


                /***/
            }),

        /***/
        "ayUG":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const Utils = __webpack_require__("lr8Y")
                const ECCode = __webpack_require__("Dvwq")
                const ECLevel = __webpack_require__("gp4+")
                const Mode = __webpack_require__("u8wY")
                const VersionCheck = __webpack_require__("mVQ0")

                // Generator polynomial used to encode version information
                const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)
                const G18_BCH = Utils.getBCHDigit(G18)

                function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
                    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
                        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
                            return currentVersion
                        }
                    }

                    return undefined
                }

                function getReservedBitsCount(mode, version) {
                    // Character count indicator + mode indicator bits
                    return Mode.getCharCountIndicator(mode, version) + 4
                }

                function getTotalBitsFromDataArray(segments, version) {
                    let totalBits = 0

                    segments.forEach(function(data) {
                        const reservedBits = getReservedBitsCount(data.mode, version)
                        totalBits += reservedBits + data.getBitsLength()
                    })

                    return totalBits
                }

                function getBestVersionForMixedData(segments, errorCorrectionLevel) {
                    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
                        const length = getTotalBitsFromDataArray(segments, currentVersion)
                        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
                            return currentVersion
                        }
                    }

                    return undefined
                }

                /**
                 * Returns version number from a value.
                 * If value is not a valid version, returns defaultValue
                 *
                 * @param  {Number|String} value        QR Code version
                 * @param  {Number}        defaultValue Fallback value
                 * @return {Number}                     QR Code version number
                 */
                exports.from = function from(value, defaultValue) {
                    if (VersionCheck.isValid(value)) {
                        return parseInt(value, 10)
                    }

                    return defaultValue
                }

                /**
                 * Returns how much data can be stored with the specified QR code version
                 * and error correction level
                 *
                 * @param  {Number} version              QR Code version (1-40)
                 * @param  {Number} errorCorrectionLevel Error correction level
                 * @param  {Mode}   mode                 Data mode
                 * @return {Number}                      Quantity of storable data
                 */
                exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
                    if (!VersionCheck.isValid(version)) {
                        throw new Error('Invalid QR Code version')
                    }

                    // Use Byte mode as default
                    if (typeof mode === 'undefined') mode = Mode.BYTE

                    // Total codewords for this QR code version (Data + Error correction)
                    const totalCodewords = Utils.getSymbolTotalCodewords(version)

                    // Total number of error correction codewords
                    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)

                    // Total number of data codewords
                    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8

                    if (mode === Mode.MIXED) return dataTotalCodewordsBits

                    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)

                    // Return max number of storable codewords
                    switch (mode) {
                        case Mode.NUMERIC:
                            return Math.floor((usableBits / 10) * 3)

                        case Mode.ALPHANUMERIC:
                            return Math.floor((usableBits / 11) * 2)

                        case Mode.KANJI:
                            return Math.floor(usableBits / 13)

                        case Mode.BYTE:
                        default:
                            return Math.floor(usableBits / 8)
                    }
                }

                /**
                 * Returns the minimum version needed to contain the amount of data
                 *
                 * @param  {Segment} data                    Segment of data
                 * @param  {Number} [errorCorrectionLevel=H] Error correction level
                 * @param  {Mode} mode                       Data mode
                 * @return {Number}                          QR Code version
                 */
                exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
                    let seg

                    const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)

                    if (Array.isArray(data)) {
                        if (data.length > 1) {
                            return getBestVersionForMixedData(data, ecl)
                        }

                        if (data.length === 0) {
                            return 1
                        }

                        seg = data[0]
                    } else {
                        seg = data
                    }

                    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
                }

                /**
                 * Returns version information with relative error correction bits
                 *
                 * The version information is included in QR Code symbols of version 7 or larger.
                 * It consists of an 18-bit sequence containing 6 data bits,
                 * with 12 error correction bits calculated using the (18, 6) Golay code.
                 *
                 * @param  {Number} version QR Code version
                 * @return {Number}         Encoded version info bits
                 */
                exports.getEncodedBits = function getEncodedBits(version) {
                    if (!VersionCheck.isValid(version) || version < 7) {
                        throw new Error('Invalid QR Code version')
                    }

                    let d = version << 12

                    while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
                        d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))
                    }

                    return (version << 12) | d
                }


                /***/
            }),

        /***/
        "d7EH":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const Utils = __webpack_require__("4QaL")

                function clearCanvas(ctx, canvas, size) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height)

                    if (!canvas.style) canvas.style = {}
                    canvas.height = size
                    canvas.width = size
                    canvas.style.height = size + 'px'
                    canvas.style.width = size + 'px'
                }

                function getCanvasElement() {
                    try {
                        return document.createElement('canvas')
                    } catch (e) {
                        throw new Error('You need to specify a canvas element')
                    }
                }

                exports.render = function render(qrData, canvas, options) {
                    let opts = options
                    let canvasEl = canvas

                    if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
                        opts = canvas
                        canvas = undefined
                    }

                    if (!canvas) {
                        canvasEl = getCanvasElement()
                    }

                    opts = Utils.getOptions(opts)
                    const size = Utils.getImageWidth(qrData.modules.size, opts)

                    const ctx = canvasEl.getContext('2d')
                    const image = ctx.createImageData(size, size)
                    Utils.qrToImageData(image.data, qrData, opts)

                    clearCanvas(ctx, canvasEl, size)
                    ctx.putImageData(image, 0, 0)

                    return canvasEl
                }

                exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
                    let opts = options

                    if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
                        opts = canvas
                        canvas = undefined
                    }

                    if (!opts) opts = {}

                    const canvasEl = exports.render(qrData, canvas, opts)

                    const type = opts.type || 'image/png'
                    const rendererOpts = opts.rendererOpts || {}

                    return canvasEl.toDataURL(type, rendererOpts.quality)
                }


                /***/
            }),

        /***/
        "FZag":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                const Utils = __webpack_require__("4QaL")

                function getColorAttrib(color, attrib) {
                    const alpha = color.a / 255
                    const str = attrib + '="' + color.hex + '"'

                    return alpha < 1 ?
                        str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' :
                        str
                }

                function svgCmd(cmd, x, y) {
                    let str = cmd + x
                    if (typeof y !== 'undefined') str += ' ' + y

                    return str
                }

                function qrToPath(data, size, margin) {
                    let path = ''
                    let moveBy = 0
                    let newRow = false
                    let lineLength = 0

                    for (let i = 0; i < data.length; i++) {
                        const col = Math.floor(i % size)
                        const row = Math.floor(i / size)

                        if (!col && !newRow) newRow = true

                        if (data[i]) {
                            lineLength++

                            if (!(i > 0 && col > 0 && data[i - 1])) {
                                path += newRow ?
                                    svgCmd('M', col + margin, 0.5 + row + margin) :
                                    svgCmd('m', moveBy, 0)

                                moveBy = 0
                                newRow = false
                            }

                            if (!(col + 1 < size && data[i + 1])) {
                                path += svgCmd('h', lineLength)
                                lineLength = 0
                            }
                        } else {
                            moveBy++
                        }
                    }

                    return path
                }

                exports.render = function render(qrData, options, cb) {
                    const opts = Utils.getOptions(options)
                    const size = qrData.modules.size
                    const data = qrData.modules.data
                    const qrcodesize = size + opts.margin * 2

                    const bg = !opts.color.light.a ?
                        '' :
                        '<path ' + getColorAttrib(opts.color.light, 'fill') +
                        ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>'

                    const path =
                        '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
                        ' d="' + qrToPath(data, size, opts.margin) + '"/>'

                    const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"'

                    const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" '

                    const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n'

                    if (typeof cb === 'function') {
                        cb(null, svgTag)
                    }

                    return svgTag
                }


                /***/
            }),

        /***/
        "4QaL":
            /***/
            ((__unused_webpack_module, exports) => {

                function hex2rgba(hex) {
                    if (typeof hex === 'number') {
                        hex = hex.toString()
                    }

                    if (typeof hex !== 'string') {
                        throw new Error('Color should be defined as hex string')
                    }

                    let hexCode = hex.slice().replace('#', '').split('')
                    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
                        throw new Error('Invalid hex color: ' + hex)
                    }

                    // Convert from short to long form (fff -> ffffff)
                    if (hexCode.length === 3 || hexCode.length === 4) {
                        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
                            return [c, c]
                        }))
                    }

                    // Add default alpha value
                    if (hexCode.length === 6) hexCode.push('F', 'F')

                    const hexValue = parseInt(hexCode.join(''), 16)

                    return {
                        r: (hexValue >> 24) & 255,
                        g: (hexValue >> 16) & 255,
                        b: (hexValue >> 8) & 255,
                        a: hexValue & 255,
                        hex: '#' + hexCode.slice(0, 6).join('')
                    }
                }

                exports.getOptions = function getOptions(options) {
                    if (!options) options = {}
                    if (!options.color) options.color = {}

                    const margin = typeof options.margin === 'undefined' ||
                        options.margin === null ||
                        options.margin < 0 ?
                        4 :
                        options.margin

                    const width = options.width && options.width >= 21 ? options.width : undefined
                    const scale = options.scale || 4

                    return {
                        width: width,
                        scale: width ? 4 : scale,
                        margin: margin,
                        color: {
                            dark: hex2rgba(options.color.dark || '#000000ff'),
                            light: hex2rgba(options.color.light || '#ffffffff')
                        },
                        type: options.type,
                        rendererOpts: options.rendererOpts || {}
                    }
                }

                exports.getScale = function getScale(qrSize, opts) {
                    return opts.width && opts.width >= qrSize + opts.margin * 2 ?
                        opts.width / (qrSize + opts.margin * 2) :
                        opts.scale
                }

                exports.getImageWidth = function getImageWidth(qrSize, opts) {
                    const scale = exports.getScale(qrSize, opts)
                    return Math.floor((qrSize + opts.margin * 2) * scale)
                }

                exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
                    const size = qr.modules.size
                    const data = qr.modules.data
                    const scale = exports.getScale(size, opts)
                    const symbolSize = Math.floor((size + opts.margin * 2) * scale)
                    const scaledMargin = opts.margin * scale
                    const palette = [opts.color.light, opts.color.dark]

                    for (let i = 0; i < symbolSize; i++) {
                        for (let j = 0; j < symbolSize; j++) {
                            let posDst = (i * symbolSize + j) * 4
                            let pxColor = opts.color.light

                            if (i >= scaledMargin && j >= scaledMargin &&
                                i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
                                const iSrc = Math.floor((i - scaledMargin) / scale)
                                const jSrc = Math.floor((j - scaledMargin) / scale)
                                pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]
                            }

                            imgData[posDst++] = pxColor.r
                            imgData[posDst++] = pxColor.g
                            imgData[posDst++] = pxColor.b
                            imgData[posDst] = pxColor.a
                        }
                    }
                }


                /***/
            }),

        /***/
        "otnf":
            /***/
            ((module) => {

                "use strict";


                var replace = String.prototype.replace;
                var percentTwenties = /%20/g;

                var Format = {
                    RFC1738: 'RFC1738',
                    RFC3986: 'RFC3986'
                };

                module.exports = {
                    'default': Format.RFC3986,
                    formatters: {
                        RFC1738: function(value) {
                            return replace.call(value, percentTwenties, '+');
                        },
                        RFC3986: function(value) {
                            return String(value);
                        }
                    },
                    RFC1738: Format.RFC1738,
                    RFC3986: Format.RFC3986
                };


                /***/
            }),

        /***/
        "oeLA":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var stringify = __webpack_require__("yip9");
                var parse = __webpack_require__("nv8S");
                var formats = __webpack_require__("otnf");

                module.exports = {
                    formats: formats,
                    parse: parse,
                    stringify: stringify
                };


                /***/
            }),

        /***/
        "nv8S":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var utils = __webpack_require__("t7Dp");

                var has = Object.prototype.hasOwnProperty;
                var isArray = Array.isArray;

                var defaults = {
                    allowDots: false,
                    allowEmptyArrays: false,
                    allowPrototypes: false,
                    allowSparse: false,
                    arrayLimit: 20,
                    charset: 'utf-8',
                    charsetSentinel: false,
                    comma: false,
                    decodeDotInKeys: false,
                    decoder: utils.decode,
                    delimiter: '&',
                    depth: 5,
                    duplicates: 'combine',
                    ignoreQueryPrefix: false,
                    interpretNumericEntities: false,
                    parameterLimit: 1000,
                    parseArrays: true,
                    plainObjects: false,
                    strictDepth: false,
                    strictNullHandling: false
                };

                var interpretNumericEntities = function(str) {
                    return str.replace(/&#(\d+);/g, function($0, numberStr) {
                        return String.fromCharCode(parseInt(numberStr, 10));
                    });
                };

                var parseArrayValue = function(val, options) {
                    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
                        return val.split(',');
                    }

                    return val;
                };

                // This is what browsers will submit when the ✓ character occurs in an
                // application/x-www-form-urlencoded body and the encoding of the page containing
                // the form is iso-8859-1, or when the submitted form has an accept-charset
                // attribute of iso-8859-1. Presumably also with other charsets that do not contain
                // the ✓ character, such as us-ascii.
                var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

                // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
                var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

                var parseValues = function parseQueryStringValues(str, options) {
                    var obj = {
                        __proto__: null
                    };

                    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
                    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
                    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
                    var parts = cleanStr.split(options.delimiter, limit);
                    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
                    var i;

                    var charset = options.charset;
                    if (options.charsetSentinel) {
                        for (i = 0; i < parts.length; ++i) {
                            if (parts[i].indexOf('utf8=') === 0) {
                                if (parts[i] === charsetSentinel) {
                                    charset = 'utf-8';
                                } else if (parts[i] === isoSentinel) {
                                    charset = 'iso-8859-1';
                                }
                                skipIndex = i;
                                i = parts.length; // The eslint settings do not allow break;
                            }
                        }
                    }

                    for (i = 0; i < parts.length; ++i) {
                        if (i === skipIndex) {
                            continue;
                        }
                        var part = parts[i];

                        var bracketEqualsPos = part.indexOf(']=');
                        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

                        var key;
                        var val;
                        if (pos === -1) {
                            key = options.decoder(part, defaults.decoder, charset, 'key');
                            val = options.strictNullHandling ? null : '';
                        } else {
                            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
                            val = utils.maybeMap(
                                parseArrayValue(part.slice(pos + 1), options),
                                function(encodedVal) {
                                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                                }
                            );
                        }

                        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
                            val = interpretNumericEntities(String(val));
                        }

                        if (part.indexOf('[]=') > -1) {
                            val = isArray(val) ? [val] : val;
                        }

                        var existing = has.call(obj, key);
                        if (existing && options.duplicates === 'combine') {
                            obj[key] = utils.combine(obj[key], val);
                        } else if (!existing || options.duplicates === 'last') {
                            obj[key] = val;
                        }
                    }

                    return obj;
                };

                var parseObject = function(chain, val, options, valuesParsed) {
                    var leaf = valuesParsed ? val : parseArrayValue(val, options);

                    for (var i = chain.length - 1; i >= 0; --i) {
                        var obj;
                        var root = chain[i];

                        if (root === '[]' && options.parseArrays) {
                            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null)) ?
                                [] :
                                [].concat(leaf);
                        } else {
                            obj = options.plainObjects ? {
                                __proto__: null
                            } : {};
                            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
                            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
                            var index = parseInt(decodedRoot, 10);
                            if (!options.parseArrays && decodedRoot === '') {
                                obj = {
                                    0: leaf
                                };
                            } else if (!isNaN(index) &&
                                root !== decodedRoot &&
                                String(index) === decodedRoot &&
                                index >= 0 &&
                                (options.parseArrays && index <= options.arrayLimit)
                            ) {
                                obj = [];
                                obj[index] = leaf;
                            } else if (decodedRoot !== '__proto__') {
                                obj[decodedRoot] = leaf;
                            }
                        }

                        leaf = obj;
                    }

                    return leaf;
                };

                var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
                    if (!givenKey) {
                        return;
                    }

                    // Transform dot notation to bracket notation
                    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

                    // The regex chunks

                    var brackets = /(\[[^[\]]*])/;
                    var child = /(\[[^[\]]*])/g;

                    // Get the parent

                    var segment = options.depth > 0 && brackets.exec(key);
                    var parent = segment ? key.slice(0, segment.index) : key;

                    // Stash the parent if it exists

                    var keys = [];
                    if (parent) {
                        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
                        if (!options.plainObjects && has.call(Object.prototype, parent)) {
                            if (!options.allowPrototypes) {
                                return;
                            }
                        }

                        keys.push(parent);
                    }

                    // Loop through children appending to the array until we hit depth

                    var i = 0;
                    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
                        i += 1;
                        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
                            if (!options.allowPrototypes) {
                                return;
                            }
                        }
                        keys.push(segment[1]);
                    }

                    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

                    if (segment) {
                        if (options.strictDepth === true) {
                            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
                        }
                        keys.push('[' + key.slice(segment.index) + ']');
                    }

                    return parseObject(keys, val, options, valuesParsed);
                };

                var normalizeParseOptions = function normalizeParseOptions(opts) {
                    if (!opts) {
                        return defaults;
                    }

                    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
                        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
                    }

                    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
                        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
                    }

                    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
                        throw new TypeError('Decoder has to be a function.');
                    }

                    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
                        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
                    }
                    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

                    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

                    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
                        throw new TypeError('The duplicates option must be either combine, first, or last');
                    }

                    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

                    return {
                        allowDots: allowDots,
                        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
                        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
                        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
                        charset: charset,
                        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
                        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
                        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
                        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
                        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
                        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
                        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
                        duplicates: duplicates,
                        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
                        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
                        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
                        parseArrays: opts.parseArrays !== false,
                        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
                        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
                        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
                    };
                };

                module.exports = function(str, opts) {
                    var options = normalizeParseOptions(opts);

                    if (str === '' || str === null || typeof str === 'undefined') {
                        return options.plainObjects ? {
                            __proto__: null
                        } : {};
                    }

                    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
                    var obj = options.plainObjects ? {
                        __proto__: null
                    } : {};

                    // Iterate over the keys and setup the new object

                    var keys = Object.keys(tempObj);
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
                        obj = utils.merge(obj, newObj, options);
                    }

                    if (options.allowSparse === true) {
                        return obj;
                    }

                    return utils.compact(obj);
                };


                /***/
            }),

        /***/
        "yip9":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var getSideChannel = __webpack_require__("NMG3");
                var utils = __webpack_require__("t7Dp");
                var formats = __webpack_require__("otnf");
                var has = Object.prototype.hasOwnProperty;

                var arrayPrefixGenerators = {
                    brackets: function brackets(prefix) {
                        return prefix + '[]';
                    },
                    comma: 'comma',
                    indices: function indices(prefix, key) {
                        return prefix + '[' + key + ']';
                    },
                    repeat: function repeat(prefix) {
                        return prefix;
                    }
                };

                var isArray = Array.isArray;
                var push = Array.prototype.push;
                var pushToArray = function(arr, valueOrArray) {
                    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
                };

                var toISO = Date.prototype.toISOString;

                var defaultFormat = formats['default'];
                var defaults = {
                    addQueryPrefix: false,
                    allowDots: false,
                    allowEmptyArrays: false,
                    arrayFormat: 'indices',
                    charset: 'utf-8',
                    charsetSentinel: false,
                    commaRoundTrip: false,
                    delimiter: '&',
                    encode: true,
                    encodeDotInKeys: false,
                    encoder: utils.encode,
                    encodeValuesOnly: false,
                    filter: void undefined,
                    format: defaultFormat,
                    formatter: formats.formatters[defaultFormat],
                    // deprecated
                    indices: false,
                    serializeDate: function serializeDate(date) {
                        return toISO.call(date);
                    },
                    skipNulls: false,
                    strictNullHandling: false
                };

                var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
                    return typeof v === 'string' ||
                        typeof v === 'number' ||
                        typeof v === 'boolean' ||
                        typeof v === 'symbol' ||
                        typeof v === 'bigint';
                };

                var sentinel = {};

                var stringify = function stringify(
                    object,
                    prefix,
                    generateArrayPrefix,
                    commaRoundTrip,
                    allowEmptyArrays,
                    strictNullHandling,
                    skipNulls,
                    encodeDotInKeys,
                    encoder,
                    filter,
                    sort,
                    allowDots,
                    serializeDate,
                    format,
                    formatter,
                    encodeValuesOnly,
                    charset,
                    sideChannel
                ) {
                    var obj = object;

                    var tmpSc = sideChannel;
                    var step = 0;
                    var findFlag = false;
                    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
                        // Where object last appeared in the ref tree
                        var pos = tmpSc.get(object);
                        step += 1;
                        if (typeof pos !== 'undefined') {
                            if (pos === step) {
                                throw new RangeError('Cyclic object value');
                            } else {
                                findFlag = true; // Break while
                            }
                        }
                        if (typeof tmpSc.get(sentinel) === 'undefined') {
                            step = 0;
                        }
                    }

                    if (typeof filter === 'function') {
                        obj = filter(prefix, obj);
                    } else if (obj instanceof Date) {
                        obj = serializeDate(obj);
                    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
                        obj = utils.maybeMap(obj, function(value) {
                            if (value instanceof Date) {
                                return serializeDate(value);
                            }
                            return value;
                        });
                    }

                    if (obj === null) {
                        if (strictNullHandling) {
                            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
                        }

                        obj = '';
                    }

                    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
                        if (encoder) {
                            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
                            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
                        }
                        return [formatter(prefix) + '=' + formatter(String(obj))];
                    }

                    var values = [];

                    if (typeof obj === 'undefined') {
                        return values;
                    }

                    var objKeys;
                    if (generateArrayPrefix === 'comma' && isArray(obj)) {
                        // we need to join elements in
                        if (encodeValuesOnly && encoder) {
                            obj = utils.maybeMap(obj, encoder);
                        }
                        objKeys = [{
                            value: obj.length > 0 ? obj.join(',') || null : void undefined
                        }];
                    } else if (isArray(filter)) {
                        objKeys = filter;
                    } else {
                        var keys = Object.keys(obj);
                        objKeys = sort ? keys.sort(sort) : keys;
                    }

                    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

                    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

                    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
                        return adjustedPrefix + '[]';
                    }

                    for (var j = 0; j < objKeys.length; ++j) {
                        var key = objKeys[j];
                        var value = typeof key === 'object' && key && typeof key.value !== 'undefined' ?
                            key.value :
                            obj[key];

                        if (skipNulls && value === null) {
                            continue;
                        }

                        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
                        var keyPrefix = isArray(obj) ?
                            typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix :
                            adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

                        sideChannel.set(object, step);
                        var valueSideChannel = getSideChannel();
                        valueSideChannel.set(sentinel, sideChannel);
                        pushToArray(values, stringify(
                            value,
                            keyPrefix,
                            generateArrayPrefix,
                            commaRoundTrip,
                            allowEmptyArrays,
                            strictNullHandling,
                            skipNulls,
                            encodeDotInKeys,
                            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
                            filter,
                            sort,
                            allowDots,
                            serializeDate,
                            format,
                            formatter,
                            encodeValuesOnly,
                            charset,
                            valueSideChannel
                        ));
                    }

                    return values;
                };

                var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
                    if (!opts) {
                        return defaults;
                    }

                    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
                        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
                    }

                    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
                        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
                    }

                    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
                        throw new TypeError('Encoder has to be a function.');
                    }

                    var charset = opts.charset || defaults.charset;
                    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
                        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
                    }

                    var format = formats['default'];
                    if (typeof opts.format !== 'undefined') {
                        if (!has.call(formats.formatters, opts.format)) {
                            throw new TypeError('Unknown format option provided.');
                        }
                        format = opts.format;
                    }
                    var formatter = formats.formatters[format];

                    var filter = defaults.filter;
                    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
                        filter = opts.filter;
                    }

                    var arrayFormat;
                    if (opts.arrayFormat in arrayPrefixGenerators) {
                        arrayFormat = opts.arrayFormat;
                    } else if ('indices' in opts) {
                        arrayFormat = opts.indices ? 'indices' : 'repeat';
                    } else {
                        arrayFormat = defaults.arrayFormat;
                    }

                    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
                        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
                    }

                    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

                    return {
                        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
                        allowDots: allowDots,
                        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                        arrayFormat: arrayFormat,
                        charset: charset,
                        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
                        commaRoundTrip: !!opts.commaRoundTrip,
                        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
                        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
                        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
                        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
                        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
                        filter: filter,
                        format: format,
                        formatter: formatter,
                        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
                        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
                        sort: typeof opts.sort === 'function' ? opts.sort : null,
                        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
                    };
                };

                module.exports = function(object, opts) {
                    var obj = object;
                    var options = normalizeStringifyOptions(opts);

                    var objKeys;
                    var filter;

                    if (typeof options.filter === 'function') {
                        filter = options.filter;
                        obj = filter('', obj);
                    } else if (isArray(options.filter)) {
                        filter = options.filter;
                        objKeys = filter;
                    }

                    var keys = [];

                    if (typeof obj !== 'object' || obj === null) {
                        return '';
                    }

                    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
                    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

                    if (!objKeys) {
                        objKeys = Object.keys(obj);
                    }

                    if (options.sort) {
                        objKeys.sort(options.sort);
                    }

                    var sideChannel = getSideChannel();
                    for (var i = 0; i < objKeys.length; ++i) {
                        var key = objKeys[i];
                        var value = obj[key];

                        if (options.skipNulls && value === null) {
                            continue;
                        }
                        pushToArray(keys, stringify(
                            value,
                            key,
                            generateArrayPrefix,
                            commaRoundTrip,
                            options.allowEmptyArrays,
                            options.strictNullHandling,
                            options.skipNulls,
                            options.encodeDotInKeys,
                            options.encode ? options.encoder : null,
                            options.filter,
                            options.sort,
                            options.allowDots,
                            options.serializeDate,
                            options.format,
                            options.formatter,
                            options.encodeValuesOnly,
                            options.charset,
                            sideChannel
                        ));
                    }

                    var joined = keys.join(options.delimiter);
                    var prefix = options.addQueryPrefix === true ? '?' : '';

                    if (options.charsetSentinel) {
                        if (options.charset === 'iso-8859-1') {
                            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
                            prefix += 'utf8=%26%2310003%3B&';
                        } else {
                            // encodeURIComponent('✓')
                            prefix += 'utf8=%E2%9C%93&';
                        }
                    }

                    return joined.length > 0 ? prefix + joined : '';
                };


                /***/
            }),

        /***/
        "t7Dp":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var formats = __webpack_require__("otnf");

                var has = Object.prototype.hasOwnProperty;
                var isArray = Array.isArray;

                var hexTable = (function() {
                    var array = [];
                    for (var i = 0; i < 256; ++i) {
                        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
                    }

                    return array;
                }());

                var compactQueue = function compactQueue(queue) {
                    while (queue.length > 1) {
                        var item = queue.pop();
                        var obj = item.obj[item.prop];

                        if (isArray(obj)) {
                            var compacted = [];

                            for (var j = 0; j < obj.length; ++j) {
                                if (typeof obj[j] !== 'undefined') {
                                    compacted.push(obj[j]);
                                }
                            }

                            item.obj[item.prop] = compacted;
                        }
                    }
                };

                var arrayToObject = function arrayToObject(source, options) {
                    var obj = options && options.plainObjects ? {
                        __proto__: null
                    } : {};
                    for (var i = 0; i < source.length; ++i) {
                        if (typeof source[i] !== 'undefined') {
                            obj[i] = source[i];
                        }
                    }

                    return obj;
                };

                var merge = function merge(target, source, options) {
                    /* eslint no-param-reassign: 0 */
                    if (!source) {
                        return target;
                    }

                    if (typeof source !== 'object' && typeof source !== 'function') {
                        if (isArray(target)) {
                            target.push(source);
                        } else if (target && typeof target === 'object') {
                            if (
                                (options && (options.plainObjects || options.allowPrototypes)) ||
                                !has.call(Object.prototype, source)
                            ) {
                                target[source] = true;
                            }
                        } else {
                            return [target, source];
                        }

                        return target;
                    }

                    if (!target || typeof target !== 'object') {
                        return [target].concat(source);
                    }

                    var mergeTarget = target;
                    if (isArray(target) && !isArray(source)) {
                        mergeTarget = arrayToObject(target, options);
                    }

                    if (isArray(target) && isArray(source)) {
                        source.forEach(function(item, i) {
                            if (has.call(target, i)) {
                                var targetItem = target[i];
                                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                                    target[i] = merge(targetItem, item, options);
                                } else {
                                    target.push(item);
                                }
                            } else {
                                target[i] = item;
                            }
                        });
                        return target;
                    }

                    return Object.keys(source).reduce(function(acc, key) {
                        var value = source[key];

                        if (has.call(acc, key)) {
                            acc[key] = merge(acc[key], value, options);
                        } else {
                            acc[key] = value;
                        }
                        return acc;
                    }, mergeTarget);
                };

                var assign = function assignSingleSource(target, source) {
                    return Object.keys(source).reduce(function(acc, key) {
                        acc[key] = source[key];
                        return acc;
                    }, target);
                };

                var decode = function(str, defaultDecoder, charset) {
                    var strWithoutPlus = str.replace(/\+/g, ' ');
                    if (charset === 'iso-8859-1') {
                        // unescape never throws, no try...catch needed:
                        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
                    }
                    // utf-8
                    try {
                        return decodeURIComponent(strWithoutPlus);
                    } catch (e) {
                        return strWithoutPlus;
                    }
                };

                var limit = 1024;

                /* eslint operator-linebreak: [2, "before"] */

                var encode = function encode(str, defaultEncoder, charset, kind, format) {
                    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
                    // It has been adapted here for stricter adherence to RFC 3986
                    if (str.length === 0) {
                        return str;
                    }

                    var string = str;
                    if (typeof str === 'symbol') {
                        string = Symbol.prototype.toString.call(str);
                    } else if (typeof str !== 'string') {
                        string = String(str);
                    }

                    if (charset === 'iso-8859-1') {
                        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
                            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
                        });
                    }

                    var out = '';
                    for (var j = 0; j < string.length; j += limit) {
                        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
                        var arr = [];

                        for (var i = 0; i < segment.length; ++i) {
                            var c = segment.charCodeAt(i);
                            if (
                                c === 0x2D // -
                                ||
                                c === 0x2E // .
                                ||
                                c === 0x5F // _
                                ||
                                c === 0x7E // ~
                                ||
                                (c >= 0x30 && c <= 0x39) // 0-9
                                ||
                                (c >= 0x41 && c <= 0x5A) // a-z
                                ||
                                (c >= 0x61 && c <= 0x7A) // A-Z
                                ||
                                (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
                            ) {
                                arr[arr.length] = segment.charAt(i);
                                continue;
                            }

                            if (c < 0x80) {
                                arr[arr.length] = hexTable[c];
                                continue;
                            }

                            if (c < 0x800) {
                                arr[arr.length] = hexTable[0xC0 | (c >> 6)] +
                                    hexTable[0x80 | (c & 0x3F)];
                                continue;
                            }

                            if (c < 0xD800 || c >= 0xE000) {
                                arr[arr.length] = hexTable[0xE0 | (c >> 12)] +
                                    hexTable[0x80 | ((c >> 6) & 0x3F)] +
                                    hexTable[0x80 | (c & 0x3F)];
                                continue;
                            }

                            i += 1;
                            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

                            arr[arr.length] = hexTable[0xF0 | (c >> 18)] +
                                hexTable[0x80 | ((c >> 12) & 0x3F)] +
                                hexTable[0x80 | ((c >> 6) & 0x3F)] +
                                hexTable[0x80 | (c & 0x3F)];
                        }

                        out += arr.join('');
                    }

                    return out;
                };

                var compact = function compact(value) {
                    var queue = [{
                        obj: {
                            o: value
                        },
                        prop: 'o'
                    }];
                    var refs = [];

                    for (var i = 0; i < queue.length; ++i) {
                        var item = queue[i];
                        var obj = item.obj[item.prop];

                        var keys = Object.keys(obj);
                        for (var j = 0; j < keys.length; ++j) {
                            var key = keys[j];
                            var val = obj[key];
                            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                                queue.push({
                                    obj: obj,
                                    prop: key
                                });
                                refs.push(val);
                            }
                        }
                    }

                    compactQueue(queue);

                    return value;
                };

                var isRegExp = function isRegExp(obj) {
                    return Object.prototype.toString.call(obj) === '[object RegExp]';
                };

                var isBuffer = function isBuffer(obj) {
                    if (!obj || typeof obj !== 'object') {
                        return false;
                    }

                    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
                };

                var combine = function combine(a, b) {
                    return [].concat(a, b);
                };

                var maybeMap = function maybeMap(val, fn) {
                    if (isArray(val)) {
                        var mapped = [];
                        for (var i = 0; i < val.length; i += 1) {
                            mapped.push(fn(val[i]));
                        }
                        return mapped;
                    }
                    return fn(val);
                };

                module.exports = {
                    arrayToObject: arrayToObject,
                    assign: assign,
                    combine: combine,
                    compact: compact,
                    decode: decode,
                    encode: encode,
                    isBuffer: isBuffer,
                    isRegExp: isRegExp,
                    maybeMap: maybeMap,
                    merge: merge
                };


                /***/
            }),

        /***/
        "7SlD":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                module.exports = __webpack_require__("DyVO")()


                /***/
            }),

        /***/
        "DyVO":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";
                /* provided dependency */
                var Buffer = __webpack_require__("pMyr")["Buffer"];

                module.exports = rfdc

                function copyBuffer(cur) {
                    if (cur instanceof Buffer) {
                        return Buffer.from(cur)
                    }

                    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
                }

                function rfdc(opts) {
                    opts = opts || {}
                    if (opts.circles) return rfdcCircles(opts)

                    const constructorHandlers = new Map()
                    constructorHandlers.set(Date, (o) => new Date(o))
                    constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)))
                    constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)))
                    if (opts.constructorHandlers) {
                        for (const handler of opts.constructorHandlers) {
                            constructorHandlers.set(handler[0], handler[1])
                        }
                    }

                    let handler = null

                    return opts.proto ? cloneProto : clone

                    function cloneArray(a, fn) {
                        const keys = Object.keys(a)
                        const a2 = new Array(keys.length)
                        for (let i = 0; i < keys.length; i++) {
                            const k = keys[i]
                            const cur = a[k]
                            if (typeof cur !== 'object' || cur === null) {
                                a2[k] = cur
                            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                                a2[k] = handler(cur, fn)
                            } else if (ArrayBuffer.isView(cur)) {
                                a2[k] = copyBuffer(cur)
                            } else {
                                a2[k] = fn(cur)
                            }
                        }
                        return a2
                    }

                    function clone(o) {
                        if (typeof o !== 'object' || o === null) return o
                        if (Array.isArray(o)) return cloneArray(o, clone)
                        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
                            return handler(o, clone)
                        }
                        const o2 = {}
                        for (const k in o) {
                            if (Object.hasOwnProperty.call(o, k) === false) continue
                            const cur = o[k]
                            if (typeof cur !== 'object' || cur === null) {
                                o2[k] = cur
                            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                                o2[k] = handler(cur, clone)
                            } else if (ArrayBuffer.isView(cur)) {
                                o2[k] = copyBuffer(cur)
                            } else {
                                o2[k] = clone(cur)
                            }
                        }
                        return o2
                    }

                    function cloneProto(o) {
                        if (typeof o !== 'object' || o === null) return o
                        if (Array.isArray(o)) return cloneArray(o, cloneProto)
                        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
                            return handler(o, cloneProto)
                        }
                        const o2 = {}
                        for (const k in o) {
                            const cur = o[k]
                            if (typeof cur !== 'object' || cur === null) {
                                o2[k] = cur
                            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                                o2[k] = handler(cur, cloneProto)
                            } else if (ArrayBuffer.isView(cur)) {
                                o2[k] = copyBuffer(cur)
                            } else {
                                o2[k] = cloneProto(cur)
                            }
                        }
                        return o2
                    }
                }

                function rfdcCircles(opts) {
                    const refs = []
                    const refsNew = []

                    const constructorHandlers = new Map()
                    constructorHandlers.set(Date, (o) => new Date(o))
                    constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)))
                    constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)))
                    if (opts.constructorHandlers) {
                        for (const handler of opts.constructorHandlers) {
                            constructorHandlers.set(handler[0], handler[1])
                        }
                    }

                    let handler = null
                    return opts.proto ? cloneProto : clone

                    function cloneArray(a, fn) {
                        const keys = Object.keys(a)
                        const a2 = new Array(keys.length)
                        for (let i = 0; i < keys.length; i++) {
                            const k = keys[i]
                            const cur = a[k]
                            if (typeof cur !== 'object' || cur === null) {
                                a2[k] = cur
                            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                                a2[k] = handler(cur, fn)
                            } else if (ArrayBuffer.isView(cur)) {
                                a2[k] = copyBuffer(cur)
                            } else {
                                const index = refs.indexOf(cur)
                                if (index !== -1) {
                                    a2[k] = refsNew[index]
                                } else {
                                    a2[k] = fn(cur)
                                }
                            }
                        }
                        return a2
                    }

                    function clone(o) {
                        if (typeof o !== 'object' || o === null) return o
                        if (Array.isArray(o)) return cloneArray(o, clone)
                        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
                            return handler(o, clone)
                        }
                        const o2 = {}
                        refs.push(o)
                        refsNew.push(o2)
                        for (const k in o) {
                            if (Object.hasOwnProperty.call(o, k) === false) continue
                            const cur = o[k]
                            if (typeof cur !== 'object' || cur === null) {
                                o2[k] = cur
                            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                                o2[k] = handler(cur, clone)
                            } else if (ArrayBuffer.isView(cur)) {
                                o2[k] = copyBuffer(cur)
                            } else {
                                const i = refs.indexOf(cur)
                                if (i !== -1) {
                                    o2[k] = refsNew[i]
                                } else {
                                    o2[k] = clone(cur)
                                }
                            }
                        }
                        refs.pop()
                        refsNew.pop()
                        return o2
                    }

                    function cloneProto(o) {
                        if (typeof o !== 'object' || o === null) return o
                        if (Array.isArray(o)) return cloneArray(o, cloneProto)
                        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
                            return handler(o, cloneProto)
                        }
                        const o2 = {}
                        refs.push(o)
                        refsNew.push(o2)
                        for (const k in o) {
                            const cur = o[k]
                            if (typeof cur !== 'object' || cur === null) {
                                o2[k] = cur
                            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                                o2[k] = handler(cur, cloneProto)
                            } else if (ArrayBuffer.isView(cur)) {
                                o2[k] = copyBuffer(cur)
                            } else {
                                const i = refs.indexOf(cur)
                                if (i !== -1) {
                                    o2[k] = refsNew[i]
                                } else {
                                    o2[k] = cloneProto(cur)
                                }
                            }
                        }
                        refs.pop()
                        refsNew.pop()
                        return o2
                    }
                }


                /***/
            }),

        /***/
        "xYZZ":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var inspect = __webpack_require__("gqNQ");

                var $TypeError = __webpack_require__("c2Eb");

                /*
                 * This function traverses the list returning the node corresponding to the given key.
                 *
                 * That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
                 * By doing so, all the recently used nodes can be accessed relatively quickly.
                 */
                /** @type {import('./list.d.ts').listGetNode} */
                // eslint-disable-next-line consistent-return
                var listGetNode = function(list, key, isDelete) {
                    /** @type {typeof list | NonNullable<(typeof list)['next']>} */
                    var prev = list;
                    /** @type {(typeof list)['next']} */
                    var curr;
                    // eslint-disable-next-line eqeqeq
                    for (;
                        (curr = prev.next) != null; prev = curr) {
                        if (curr.key === key) {
                            prev.next = curr.next;
                            if (!isDelete) {
                                // eslint-disable-next-line no-extra-parens
                                curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
                                list.next = curr; // eslint-disable-line no-param-reassign
                            }
                            return curr;
                        }
                    }
                };

                /** @type {import('./list.d.ts').listGet} */
                var listGet = function(objects, key) {
                    if (!objects) {
                        return void undefined;
                    }
                    var node = listGetNode(objects, key);
                    return node && node.value;
                };
                /** @type {import('./list.d.ts').listSet} */
                var listSet = function(objects, key, value) {
                    var node = listGetNode(objects, key);
                    if (node) {
                        node.value = value;
                    } else {
                        // Prepend the new node to the beginning of the list
                        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
                            key: key,
                            next: objects.next,
                            value: value
                        });
                    }
                };
                /** @type {import('./list.d.ts').listHas} */
                var listHas = function(objects, key) {
                    if (!objects) {
                        return false;
                    }
                    return !!listGetNode(objects, key);
                };
                /** @type {import('./list.d.ts').listDelete} */
                // eslint-disable-next-line consistent-return
                var listDelete = function(objects, key) {
                    if (objects) {
                        return listGetNode(objects, key, true);
                    }
                };

                /** @type {import('.')} */
                module.exports = function getSideChannelList() {
                    /** @typedef {ReturnType<typeof getSideChannelList>} Channel */
                    /** @typedef {Parameters<Channel['get']>[0]} K */
                    /** @typedef {Parameters<Channel['set']>[1]} V */

                    /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */
                    var $o;

                    /** @type {Channel} */
                    var channel = {
                        assert: function(key) {
                            if (!channel.has(key)) {
                                throw new $TypeError('Side channel does not contain ' + inspect(key));
                            }
                        },
                        'delete': function(key) {
                            var root = $o && $o.next;
                            var deletedNode = listDelete($o, key);
                            if (deletedNode && root && root === deletedNode) {
                                $o = void undefined;
                            }
                            return !!deletedNode;
                        },
                        get: function(key) {
                            return listGet($o, key);
                        },
                        has: function(key) {
                            return listHas($o, key);
                        },
                        set: function(key, value) {
                            if (!$o) {
                                // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
                                $o = {
                                    next: void undefined
                                };
                            }
                            // eslint-disable-next-line no-extra-parens
                            listSet( /** @type {NonNullable<typeof $o>} */ ($o), key, value);
                        }
                    };
                    // @ts-expect-error TODO: figure out why this is erroring
                    return channel;
                };


                /***/
            }),

        /***/
        "Ad7j":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var GetIntrinsic = __webpack_require__("PQUF");
                var callBound = __webpack_require__("zGPW");
                var inspect = __webpack_require__("gqNQ");

                var $TypeError = __webpack_require__("c2Eb");
                var $Map = GetIntrinsic('%Map%', true);

                /** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
                var $mapGet = callBound('Map.prototype.get', true);
                /** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
                var $mapSet = callBound('Map.prototype.set', true);
                /** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
                var $mapHas = callBound('Map.prototype.has', true);
                /** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
                var $mapDelete = callBound('Map.prototype.delete', true);
                /** @type {<K, V>(thisArg: Map<K, V>) => number} */
                var $mapSize = callBound('Map.prototype.size', true);

                /** @type {import('.')} */
                module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
                    /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
                    /** @typedef {Parameters<Channel['get']>[0]} K */
                    /** @typedef {Parameters<Channel['set']>[1]} V */

                    /** @type {Map<K, V> | undefined} */
                    var $m;

                    /** @type {Channel} */
                    var channel = {
                        assert: function(key) {
                            if (!channel.has(key)) {
                                throw new $TypeError('Side channel does not contain ' + inspect(key));
                            }
                        },
                        'delete': function(key) {
                            if ($m) {
                                var result = $mapDelete($m, key);
                                if ($mapSize($m) === 0) {
                                    $m = void undefined;
                                }
                                return result;
                            }
                            return false;
                        },
                        get: function(key) { // eslint-disable-line consistent-return
                            if ($m) {
                                return $mapGet($m, key);
                            }
                        },
                        has: function(key) {
                            if ($m) {
                                return $mapHas($m, key);
                            }
                            return false;
                        },
                        set: function(key, value) {
                            if (!$m) {
                                // @ts-expect-error TS can't handle narrowing a variable inside a closure
                                $m = new $Map();
                            }
                            $mapSet($m, key, value);
                        }
                    };

                    // @ts-expect-error TODO: figure out why TS is erroring here
                    return channel;
                };


                /***/
            }),

        /***/
        "J9M2":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var GetIntrinsic = __webpack_require__("PQUF");
                var callBound = __webpack_require__("zGPW");
                var inspect = __webpack_require__("gqNQ");
                var getSideChannelMap = __webpack_require__("Ad7j");

                var $TypeError = __webpack_require__("c2Eb");
                var $WeakMap = GetIntrinsic('%WeakMap%', true);

                /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
                var $weakMapGet = callBound('WeakMap.prototype.get', true);
                /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
                var $weakMapSet = callBound('WeakMap.prototype.set', true);
                /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
                var $weakMapHas = callBound('WeakMap.prototype.has', true);
                /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
                var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

                /** @type {import('.')} */
                module.exports = $WeakMap ?
                    /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
                        /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
                        /** @typedef {Parameters<Channel['get']>[0]} K */
                        /** @typedef {Parameters<Channel['set']>[1]} V */

                        /** @type {WeakMap<K & object, V> | undefined} */
                        var $wm;
                        /** @type {Channel | undefined} */
                        var $m;

                        /** @type {Channel} */
                        var channel = {
                            assert: function(key) {
                                if (!channel.has(key)) {
                                    throw new $TypeError('Side channel does not contain ' + inspect(key));
                                }
                            },
                            'delete': function(key) {
                                if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                                    if ($wm) {
                                        return $weakMapDelete($wm, key);
                                    }
                                } else if (getSideChannelMap) {
                                    if ($m) {
                                        return $m['delete'](key);
                                    }
                                }
                                return false;
                            },
                            get: function(key) {
                                if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                                    if ($wm) {
                                        return $weakMapGet($wm, key);
                                    }
                                }
                                return $m && $m.get(key);
                            },
                            has: function(key) {
                                if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                                    if ($wm) {
                                        return $weakMapHas($wm, key);
                                    }
                                }
                                return !!$m && $m.has(key);
                            },
                            set: function(key, value) {
                                if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                                    if (!$wm) {
                                        $wm = new $WeakMap();
                                    }
                                    $weakMapSet($wm, key, value);
                                } else if (getSideChannelMap) {
                                    if (!$m) {
                                        $m = getSideChannelMap();
                                    }
                                    // eslint-disable-next-line no-extra-parens
                                    /** @type {NonNullable<typeof $m>} */
                                    ($m).set(key, value);
                                }
                            }
                        };

                        // @ts-expect-error TODO: figure out why this is erroring
                        return channel;
                    } :
                    getSideChannelMap;


                /***/
            }),

        /***/
        "NMG3":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                var $TypeError = __webpack_require__("c2Eb");
                var inspect = __webpack_require__("gqNQ");
                var getSideChannelList = __webpack_require__("xYZZ");
                var getSideChannelMap = __webpack_require__("Ad7j");
                var getSideChannelWeakMap = __webpack_require__("J9M2");

                var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

                /** @type {import('.')} */
                module.exports = function getSideChannel() {
                    /** @typedef {ReturnType<typeof getSideChannel>} Channel */

                    /** @type {Channel | undefined} */
                    var $channelData;

                    /** @type {Channel} */
                    var channel = {
                        assert: function(key) {
                            if (!channel.has(key)) {
                                throw new $TypeError('Side channel does not contain ' + inspect(key));
                            }
                        },
                        'delete': function(key) {
                            return !!$channelData && $channelData['delete'](key);
                        },
                        get: function(key) {
                            return $channelData && $channelData.get(key);
                        },
                        has: function(key) {
                            return !!$channelData && $channelData.has(key);
                        },
                        set: function(key, value) {
                            if (!$channelData) {
                                $channelData = makeChannel();
                            }

                            $channelData.set(key, value);
                        }
                    };
                    // @ts-expect-error TODO: figure out why this is erroring
                    return channel;
                };


                /***/
            }),

        /***/
        "lY63":
            /***/
            ((__unused_webpack_module, exports, __webpack_require__) => {

                "use strict";
                /**
                 * @license React
                 * use-sync-external-store-shim.production.js
                 *
                 * Copyright (c) Meta Platforms, Inc. and affiliates.
                 *
                 * This source code is licensed under the MIT license found in the
                 * LICENSE file in the root directory of this source tree.
                 */


                var React = __webpack_require__("DTvD");

                function is(x, y) {
                    return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
                }
                var objectIs = "function" === typeof Object.is ? Object.is : is,
                    useState = React.useState,
                    useEffect = React.useEffect,
                    useLayoutEffect = React.useLayoutEffect,
                    useDebugValue = React.useDebugValue;

                function useSyncExternalStore$2(subscribe, getSnapshot) {
                    var value = getSnapshot(),
                        _useState = useState({
                            inst: {
                                value: value,
                                getSnapshot: getSnapshot
                            }
                        }),
                        inst = _useState[0].inst,
                        forceUpdate = _useState[1];
                    useLayoutEffect(
                        function() {
                            inst.value = value;
                            inst.getSnapshot = getSnapshot;
                            checkIfSnapshotChanged(inst) && forceUpdate({
                                inst: inst
                            });
                        }, [subscribe, value, getSnapshot]
                    );
                    useEffect(
                        function() {
                            checkIfSnapshotChanged(inst) && forceUpdate({
                                inst: inst
                            });
                            return subscribe(function() {
                                checkIfSnapshotChanged(inst) && forceUpdate({
                                    inst: inst
                                });
                            });
                        }, [subscribe]
                    );
                    useDebugValue(value);
                    return value;
                }

                function checkIfSnapshotChanged(inst) {
                    var latestGetSnapshot = inst.getSnapshot;
                    inst = inst.value;
                    try {
                        var nextValue = latestGetSnapshot();
                        return !objectIs(inst, nextValue);
                    } catch (error) {
                        return !0;
                    }
                }

                function useSyncExternalStore$1(subscribe, getSnapshot) {
                    return getSnapshot();
                }
                var shim =
                    false ||
                    "undefined" === typeof window.document ||
                    "undefined" === typeof window.document.createElement ?
                    useSyncExternalStore$1 :
                    useSyncExternalStore$2;
                exports.useSyncExternalStore =
                    void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;


                /***/
            }),

        /***/
        "bmXu":
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                "use strict";


                if (true) {
                    module.exports = __webpack_require__("lY63");
                } else {}


                /***/
            }),

        /***/
        "bTuE":
            /***/
            (() => {

                /* (ignored) */

                /***/
            }),

        /***/
        "w7fa":
            /***/
            ((module, exports) => {

                var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
                /*!
                	Copyright (c) 2018 Jed Watson.
                	Licensed under the MIT License (MIT), see
                	http://jedwatson.github.io/classnames
                */
                /* global define */

                (function() {
                    'use strict';

                    var hasOwn = {}.hasOwnProperty;

                    function classNames() {
                        var classes = '';

                        for (var i = 0; i < arguments.length; i++) {
                            var arg = arguments[i];
                            if (arg) {
                                classes = appendClass(classes, parseValue(arg));
                            }
                        }

                        return classes;
                    }

                    function parseValue(arg) {
                        if (typeof arg === 'string' || typeof arg === 'number') {
                            return arg;
                        }

                        if (typeof arg !== 'object') {
                            return '';
                        }

                        if (Array.isArray(arg)) {
                            return classNames.apply(null, arg);
                        }

                        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
                            return arg.toString();
                        }

                        var classes = '';

                        for (var key in arg) {
                            if (hasOwn.call(arg, key) && arg[key]) {
                                classes = appendClass(classes, key);
                            }
                        }

                        return classes;
                    }

                    function appendClass(value, newClass) {
                        if (!newClass) {
                            return value;
                        }

                        if (value) {
                            return value + ' ' + newClass;
                        }

                        return value + newClass;
                    }

                    if (true && module.exports) {
                        classNames.default = classNames;
                        module.exports = classNames;
                    } else if (true) {
                        // register as 'classnames', consistent with npm package name
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                                return classNames;
                            }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else {}
                }());


                /***/
            }),

        /***/
        "3Tbc":
            /***/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "KO": () => ( /* binding */ useAtom)
                    /* harmony export */
                });
                /* unused harmony exports Provider, useAtomValue, useSetAtom, useStore */
                /* harmony import */
                var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("DTvD");
                /* harmony import */
                var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8GlW");
                'use client';



                const StoreContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(
                    void 0
                );
                const useStore = (options) => {
                    const store = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);
                    return (options == null ? void 0 : options.store) || store || (0, jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ /* .getDefaultStore */ .K7)();
                };
                const Provider = ({
                    children,
                    store
                }) => {
                    const storeRef = useRef(void 0);
                    if (!store && !storeRef.current) {
                        storeRef.current = createStore();
                    }
                    return createElement(
                        StoreContext.Provider, {
                            value: store || storeRef.current
                        },
                        children
                    );
                };

                const isPromiseLike = (x) => typeof(x == null ? void 0 : x.then) === "function";
                const attachPromiseMeta = (promise) => {
                    promise.status = "pending";
                    promise.then(
                        (v) => {
                            promise.status = "fulfilled";
                            promise.value = v;
                        },
                        (e) => {
                            promise.status = "rejected";
                            promise.reason = e;
                        }
                    );
                };
                const use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise) => {
                    if (promise.status === "pending") {
                        throw promise;
                    } else if (promise.status === "fulfilled") {
                        return promise.value;
                    } else if (promise.status === "rejected") {
                        throw promise.reason;
                    } else {
                        attachPromiseMeta(promise);
                        throw promise;
                    }
                });
                const continuablePromiseMap = /* @__PURE__ */ new WeakMap();
                const createContinuablePromise = (promise) => {
                    let continuablePromise = continuablePromiseMap.get(promise);
                    if (!continuablePromise) {
                        continuablePromise = new Promise((resolve, reject) => {
                            let curr = promise;
                            const onFulfilled = (me) => (v) => {
                                if (curr === me) {
                                    resolve(v);
                                }
                            };
                            const onRejected = (me) => (e) => {
                                if (curr === me) {
                                    reject(e);
                                }
                            };
                            const registerCancelHandler = (p) => {
                                if ("onCancel" in p && typeof p.onCancel === "function") {
                                    p.onCancel((nextValue) => {
                                        if ((false ? 0 : void 0) !== "production" && nextValue === p) {
                                            throw new Error("[Bug] p is not updated even after cancelation");
                                        }
                                        if (isPromiseLike(nextValue)) {
                                            continuablePromiseMap.set(nextValue, continuablePromise);
                                            curr = nextValue;
                                            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
                                            registerCancelHandler(nextValue);
                                        } else {
                                            resolve(nextValue);
                                        }
                                    });
                                }
                            };
                            promise.then(onFulfilled(promise), onRejected(promise));
                            registerCancelHandler(promise);
                        });
                        continuablePromiseMap.set(promise, continuablePromise);
                    }
                    return continuablePromise;
                };

                function useAtomValue(atom, options) {
                    const store = useStore(options);
                    const [
                        [valueFromReducer, storeFromReducer, atomFromReducer], rerender
                    ] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(
                        (prev) => {
                            const nextValue = store.get(atom);
                            if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {
                                return prev;
                            }
                            return [nextValue, store, atom];
                        },
                        void 0,
                        () => [store.get(atom), store, atom]
                    );
                    let value = valueFromReducer;
                    if (storeFromReducer !== store || atomFromReducer !== atom) {
                        rerender();
                        value = store.get(atom);
                    }
                    const delay = options == null ? void 0 : options.delay;
                    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
                        const unsub = store.sub(atom, () => {
                            if (typeof delay === "number") {
                                const value2 = store.get(atom);
                                if (isPromiseLike(value2)) {
                                    attachPromiseMeta(createContinuablePromise(value2));
                                }
                                setTimeout(rerender, delay);
                                return;
                            }
                            rerender();
                        });
                        rerender();
                        return unsub;
                    }, [store, atom, delay]);
                    (0, react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);
                    if (isPromiseLike(value)) {
                        const promise = createContinuablePromise(value);
                        return use(promise);
                    }
                    return value;
                }

                function useSetAtom(atom, options) {
                    const store = useStore(options);
                    const setAtom = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
                        (...args) => {
                            if ((false ? 0 : void 0) !== "production" && !("write" in atom)) {
                                throw new Error("not writable atom");
                            }
                            return store.set(atom, ...args);
                        }, [store, atom]
                    );
                    return setAtom;
                }

                function useAtom(atom, options) {
                    return [
                        useAtomValue(atom, options),
                        // We do wrong type assertion here, which results in throwing an error.
                        useSetAtom(atom, options)
                    ];
                }




                /***/
            }),

        /***/
        "8GlW":
            /***/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

                "use strict";
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "K7": () => ( /* binding */ getDefaultStore),
                    /* harmony export */
                    "cn": () => ( /* binding */ atom)
                    /* harmony export */
                });
                /* unused harmony export createStore */
                let keyCount = 0;

                function atom(read, write) {
                    const key = `atom${++keyCount}`;
                    const config = {
                        toString() {
                            return (false ? 0 : void 0) !== "production" && this.debugLabel ? key + ":" + this.debugLabel : key;
                        }
                    };
                    if (typeof read === "function") {
                        config.read = read;
                    } else {
                        config.init = read;
                        config.read = defaultRead;
                        config.write = defaultWrite;
                    }
                    if (write) {
                        config.write = write;
                    }
                    return config;
                }

                function defaultRead(get) {
                    return get(this);
                }

                function defaultWrite(get, set, arg) {
                    return set(
                        this,
                        typeof arg === "function" ? arg(get(this)) : arg
                    );
                }

                const isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;
                const hasInitialValue = (atom) => "init" in atom;
                const isActuallyWritableAtom = (atom) => !!atom.write;
                const cancelablePromiseMap = /* @__PURE__ */ new WeakMap();
                const isPendingPromise = (value) => {
                    var _a;
                    return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? void 0 : _a[1]);
                };
                const cancelPromise = (promise, nextValue) => {
                    const promiseState = cancelablePromiseMap.get(promise);
                    if (promiseState) {
                        promiseState[1] = true;
                        promiseState[0].forEach((fn) => fn(nextValue));
                    } else if ((false ? 0 : void 0) !== "production") {
                        throw new Error("[Bug] cancelable promise not found");
                    }
                };
                const patchPromiseForCancelability = (promise) => {
                    if (cancelablePromiseMap.has(promise)) {
                        return;
                    }
                    const promiseState = [ /* @__PURE__ */ new Set(), false];
                    cancelablePromiseMap.set(promise, promiseState);
                    const settle = () => {
                        promiseState[1] = true;
                    };
                    promise.then(settle, settle);
                    promise.onCancel = (fn) => {
                        promiseState[0].add(fn);
                    };
                };
                const isPromiseLike = (x) => typeof(x == null ? void 0 : x.then) === "function";
                const isAtomStateInitialized = (atomState) => "v" in atomState || "e" in atomState;
                const returnAtomValue = (atomState) => {
                    if ("e" in atomState) {
                        throw atomState.e;
                    }
                    if ((false ? 0 : void 0) !== "production" && !("v" in atomState)) {
                        throw new Error("[Bug] atom state is not initialized");
                    }
                    return atomState.v;
                };
                const addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {
                    if (!dependencyAtomState.p.has(atom)) {
                        dependencyAtomState.p.add(atom);
                        promise.then(
                            () => {
                                dependencyAtomState.p.delete(atom);
                            },
                            () => {
                                dependencyAtomState.p.delete(atom);
                            }
                        );
                    }
                };
                const addDependency = (batch, atom, atomState, a, aState) => {
                    var _a;
                    if ((false ? 0 : void 0) !== "production" && a === atom) {
                        throw new Error("[Bug] atom cannot depend on itself");
                    }
                    atomState.d.set(a, aState.n);
                    if (isPendingPromise(atomState.v)) {
                        addPendingPromiseToDependency(atom, atomState.v, aState);
                    }
                    (_a = aState.m) == null ? void 0 : _a.t.add(atom);
                    if (batch) {
                        addBatchAtomDependent(batch, a, atom);
                    }
                };
                const createBatch = () => ({
                    D: /* @__PURE__ */ new Map(),
                    H: /* @__PURE__ */ new Set(),
                    M: /* @__PURE__ */ new Set(),
                    L: /* @__PURE__ */ new Set()
                });
                const addBatchFunc = (batch, priority, fn) => {
                    batch[priority].add(fn);
                };
                const registerBatchAtom = (batch, atom, atomState) => {
                    if (!batch.D.has(atom)) {
                        batch.D.set(atom, /* @__PURE__ */ new Set());
                        addBatchFunc(batch, "M", () => {
                            var _a;
                            (_a = atomState.m) == null ? void 0 : _a.l.forEach((listener) => addBatchFunc(batch, "M", listener));
                        });
                    }
                };
                const addBatchAtomDependent = (batch, atom, dependent) => {
                    const dependents = batch.D.get(atom);
                    if (dependents) {
                        dependents.add(dependent);
                    }
                };
                const getBatchAtomDependents = (batch, atom) => batch.D.get(atom);
                const flushBatch = (batch) => {
                    let error;
                    let hasError = false;
                    const call = (fn) => {
                        try {
                            fn();
                        } catch (e) {
                            if (!hasError) {
                                error = e;
                                hasError = true;
                            }
                        }
                    };
                    while (batch.H.size || batch.M.size || batch.L.size) {
                        batch.D.clear();
                        batch.H.forEach(call);
                        batch.H.clear();
                        batch.M.forEach(call);
                        batch.M.clear();
                        batch.L.forEach(call);
                        batch.L.clear();
                    }
                    if (hasError) {
                        throw error;
                    }
                };
                const buildStore = (...[getAtomState, atomRead, atomWrite, atomOnMount]) => {
                    const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise) => {
                        const hasPrevValue = "v" in atomState;
                        const prevValue = atomState.v;
                        const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;
                        if (isPromiseLike(valueOrPromise)) {
                            patchPromiseForCancelability(valueOrPromise);
                            for (const a of atomState.d.keys()) {
                                addPendingPromiseToDependency(atom, valueOrPromise, getAtomState(a));
                            }
                            atomState.v = valueOrPromise;
                        } else {
                            atomState.v = valueOrPromise;
                        }
                        delete atomState.e;
                        delete atomState.x;
                        if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
                            ++atomState.n;
                            if (pendingPromise) {
                                cancelPromise(pendingPromise, valueOrPromise);
                            }
                        }
                    };
                    const readAtomState = (batch, atom) => {
                        var _a;
                        const atomState = getAtomState(atom);
                        if (isAtomStateInitialized(atomState)) {
                            if (atomState.m && !atomState.x) {
                                return atomState;
                            }
                            if (Array.from(atomState.d).every(
                                    ([a, n]) => (
                                        // Recursively, read the atom state of the dependency, and
                                        // check if the atom epoch number is unchanged
                                        readAtomState(batch, a).n === n
                                    )
                                )) {
                                return atomState;
                            }
                        }
                        atomState.d.clear();
                        let isSync = true;
                        const getter = (a) => {
                            if (isSelfAtom(atom, a)) {
                                const aState2 = getAtomState(a);
                                if (!isAtomStateInitialized(aState2)) {
                                    if (hasInitialValue(a)) {
                                        setAtomStateValueOrPromise(a, aState2, a.init);
                                    } else {
                                        throw new Error("no atom init");
                                    }
                                }
                                return returnAtomValue(aState2);
                            }
                            const aState = readAtomState(batch, a);
                            try {
                                return returnAtomValue(aState);
                            } finally {
                                if (isSync) {
                                    addDependency(batch, atom, atomState, a, aState);
                                } else {
                                    const batch2 = createBatch();
                                    addDependency(batch2, atom, atomState, a, aState);
                                    mountDependencies(batch2, atom, atomState);
                                    flushBatch(batch2);
                                }
                            }
                        };
                        let controller;
                        let setSelf;
                        const options = {
                            get signal() {
                                if (!controller) {
                                    controller = new AbortController();
                                }
                                return controller.signal;
                            },
                            get setSelf() {
                                if ((false ? 0 : void 0) !== "production" && !isActuallyWritableAtom(atom)) {
                                    console.warn("setSelf function cannot be used with read-only atom");
                                }
                                if (!setSelf && isActuallyWritableAtom(atom)) {
                                    setSelf = (...args) => {
                                        if ((false ? 0 : void 0) !== "production" && isSync) {
                                            console.warn("setSelf function cannot be called in sync");
                                        }
                                        if (!isSync) {
                                            return writeAtom(atom, ...args);
                                        }
                                    };
                                }
                                return setSelf;
                            }
                        };
                        try {
                            const valueOrPromise = atomRead(atom, getter, options);
                            setAtomStateValueOrPromise(atom, atomState, valueOrPromise);
                            if (isPromiseLike(valueOrPromise)) {
                                (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());
                                const complete = () => {
                                    if (atomState.m) {
                                        const batch2 = createBatch();
                                        mountDependencies(batch2, atom, atomState);
                                        flushBatch(batch2);
                                    }
                                };
                                valueOrPromise.then(complete, complete);
                            }
                            return atomState;
                        } catch (error) {
                            delete atomState.v;
                            atomState.e = error;
                            delete atomState.x;
                            ++atomState.n;
                            return atomState;
                        } finally {
                            isSync = false;
                        }
                    };
                    const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));
                    const getMountedOrBatchDependents = (batch, atom, atomState) => {
                        var _a, _b;
                        const dependents = /* @__PURE__ */ new Map();
                        for (const a of ((_a = atomState.m) == null ? void 0 : _a.t) || []) {
                            const aState = getAtomState(a);
                            if (aState.m) {
                                dependents.set(a, aState);
                            }
                        }
                        for (const atomWithPendingPromise of atomState.p) {
                            dependents.set(
                                atomWithPendingPromise,
                                getAtomState(atomWithPendingPromise)
                            );
                        }
                        (_b = getBatchAtomDependents(batch, atom)) == null ? void 0 : _b.forEach((dependent) => {
                            dependents.set(dependent, getAtomState(dependent));
                        });
                        return dependents;
                    };
                    const recomputeDependents = (batch, atom, atomState) => {
                        const topSortedReversed = [];
                        const visiting = /* @__PURE__ */ new Set();
                        const visited = /* @__PURE__ */ new Set();
                        const stack = [
                            [atom, atomState]
                        ];
                        while (stack.length > 0) {
                            const [a, aState] = stack[stack.length - 1];
                            if (visited.has(a)) {
                                stack.pop();
                                continue;
                            }
                            if (visiting.has(a)) {
                                topSortedReversed.push([a, aState, aState.n]);
                                visited.add(a);
                                aState.x = true;
                                stack.pop();
                                continue;
                            }
                            visiting.add(a);
                            for (const [d, s] of getMountedOrBatchDependents(batch, a, aState)) {
                                if (a !== d && !visiting.has(d)) {
                                    stack.push([d, s]);
                                }
                            }
                        }
                        addBatchFunc(batch, "H", () => {
                            const changedAtoms = /* @__PURE__ */ new Set([atom]);
                            for (let i = topSortedReversed.length - 1; i >= 0; --i) {
                                const [a, aState, prevEpochNumber] = topSortedReversed[i];
                                let hasChangedDeps = false;
                                for (const dep of aState.d.keys()) {
                                    if (dep !== a && changedAtoms.has(dep)) {
                                        hasChangedDeps = true;
                                        break;
                                    }
                                }
                                if (hasChangedDeps) {
                                    readAtomState(batch, a);
                                    mountDependencies(batch, a, aState);
                                    if (prevEpochNumber !== aState.n) {
                                        registerBatchAtom(batch, a, aState);
                                        changedAtoms.add(a);
                                    }
                                }
                                delete aState.x;
                            }
                        });
                    };
                    const writeAtomState = (batch, atom, ...args) => {
                        let isSync = true;
                        const getter = (a) => returnAtomValue(readAtomState(batch, a));
                        const setter = (a, ...args2) => {
                            const aState = getAtomState(a);
                            try {
                                if (isSelfAtom(atom, a)) {
                                    if (!hasInitialValue(a)) {
                                        throw new Error("atom not writable");
                                    }
                                    const prevEpochNumber = aState.n;
                                    const v = args2[0];
                                    setAtomStateValueOrPromise(a, aState, v);
                                    mountDependencies(batch, a, aState);
                                    if (prevEpochNumber !== aState.n) {
                                        registerBatchAtom(batch, a, aState);
                                        recomputeDependents(batch, a, aState);
                                    }
                                    return void 0;
                                } else {
                                    return writeAtomState(batch, a, ...args2);
                                }
                            } finally {
                                if (!isSync) {
                                    flushBatch(batch);
                                }
                            }
                        };
                        try {
                            return atomWrite(atom, getter, setter, ...args);
                        } finally {
                            isSync = false;
                        }
                    };
                    const writeAtom = (atom, ...args) => {
                        const batch = createBatch();
                        try {
                            return writeAtomState(batch, atom, ...args);
                        } finally {
                            flushBatch(batch);
                        }
                    };
                    const mountDependencies = (batch, atom, atomState) => {
                        if (atomState.m && !isPendingPromise(atomState.v)) {
                            for (const a of atomState.d.keys()) {
                                if (!atomState.m.d.has(a)) {
                                    const aMounted = mountAtom(batch, a, getAtomState(a));
                                    aMounted.t.add(atom);
                                    atomState.m.d.add(a);
                                }
                            }
                            for (const a of atomState.m.d || []) {
                                if (!atomState.d.has(a)) {
                                    atomState.m.d.delete(a);
                                    const aMounted = unmountAtom(batch, a, getAtomState(a));
                                    aMounted == null ? void 0 : aMounted.t.delete(atom);
                                }
                            }
                        }
                    };
                    const mountAtom = (batch, atom, atomState) => {
                        if (!atomState.m) {
                            readAtomState(batch, atom);
                            for (const a of atomState.d.keys()) {
                                const aMounted = mountAtom(batch, a, getAtomState(a));
                                aMounted.t.add(atom);
                            }
                            atomState.m = {
                                l: /* @__PURE__ */ new Set(),
                                d: new Set(atomState.d.keys()),
                                t: /* @__PURE__ */ new Set()
                            };
                            if (isActuallyWritableAtom(atom)) {
                                const mounted = atomState.m;
                                let setAtom;
                                const createInvocationContext = (batch2, fn) => {
                                    let isSync = true;
                                    setAtom = (...args) => {
                                        try {
                                            return writeAtomState(batch2, atom, ...args);
                                        } finally {
                                            if (!isSync) {
                                                flushBatch(batch2);
                                            }
                                        }
                                    };
                                    try {
                                        return fn();
                                    } finally {
                                        isSync = false;
                                    }
                                };
                                addBatchFunc(batch, "L", () => {
                                    const onUnmount = createInvocationContext(
                                        batch,
                                        () => atomOnMount(atom, (...args) => setAtom(...args))
                                    );
                                    if (onUnmount) {
                                        mounted.u = (batch2) => createInvocationContext(batch2, onUnmount);
                                    }
                                });
                            }
                        }
                        return atomState.m;
                    };
                    const unmountAtom = (batch, atom, atomState) => {
                        if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {
                                var _a;
                                return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);
                            })) {
                            const onUnmount = atomState.m.u;
                            if (onUnmount) {
                                addBatchFunc(batch, "L", () => onUnmount(batch));
                            }
                            delete atomState.m;
                            for (const a of atomState.d.keys()) {
                                const aMounted = unmountAtom(batch, a, getAtomState(a));
                                aMounted == null ? void 0 : aMounted.t.delete(atom);
                            }
                            return void 0;
                        }
                        return atomState.m;
                    };
                    const subscribeAtom = (atom, listener) => {
                        const batch = createBatch();
                        const atomState = getAtomState(atom);
                        const mounted = mountAtom(batch, atom, atomState);
                        const listeners = mounted.l;
                        listeners.add(listener);
                        flushBatch(batch);
                        return () => {
                            listeners.delete(listener);
                            const batch2 = createBatch();
                            unmountAtom(batch2, atom, atomState);
                            flushBatch(batch2);
                        };
                    };
                    const unstable_derive = (fn) => buildStore(...fn(getAtomState, atomRead, atomWrite, atomOnMount));
                    const store = {
                        get: readAtom,
                        set: writeAtom,
                        sub: subscribeAtom,
                        unstable_derive
                    };
                    return store;
                };
                const deriveDevStoreRev4 = (store) => {
                    const proxyAtomStateMap = /* @__PURE__ */ new WeakMap();
                    const debugMountedAtoms = /* @__PURE__ */ new Set();
                    let savedGetAtomState;
                    let inRestoreAtom = 0;
                    const derivedStore = store.unstable_derive(
                        (getAtomState, atomRead, atomWrite, atomOnMount) => {
                            savedGetAtomState = getAtomState;
                            return [
                                (atom) => {
                                    let proxyAtomState = proxyAtomStateMap.get(atom);
                                    if (!proxyAtomState) {
                                        const atomState = getAtomState(atom);
                                        proxyAtomState = new Proxy(atomState, {
                                            set(target, prop, value) {
                                                if (prop === "m") {
                                                    debugMountedAtoms.add(atom);
                                                }
                                                return Reflect.set(target, prop, value);
                                            },
                                            deleteProperty(target, prop) {
                                                if (prop === "m") {
                                                    debugMountedAtoms.delete(atom);
                                                }
                                                return Reflect.deleteProperty(target, prop);
                                            }
                                        });
                                        proxyAtomStateMap.set(atom, proxyAtomState);
                                    }
                                    return proxyAtomState;
                                },
                                atomRead,
                                (atom, getter, setter, ...args) => {
                                    if (inRestoreAtom) {
                                        return setter(atom, ...args);
                                    }
                                    return atomWrite(atom, getter, setter, ...args);
                                },
                                atomOnMount
                            ];
                        }
                    );
                    const savedStoreSet = derivedStore.set;
                    const devStore = {
                        // store dev methods (these are tentative and subject to change without notice)
                        dev4_get_internal_weak_map: () => ({
                            get: (atom) => {
                                const atomState = savedGetAtomState(atom);
                                if (atomState.n === 0) {
                                    return void 0;
                                }
                                return atomState;
                            }
                        }),
                        dev4_get_mounted_atoms: () => debugMountedAtoms,
                        dev4_restore_atoms: (values) => {
                            const restoreAtom = {
                                read: () => null,
                                write: (_get, set) => {
                                    ++inRestoreAtom;
                                    try {
                                        for (const [atom, value] of values) {
                                            if (hasInitialValue(atom)) {
                                                set(atom, value);
                                            }
                                        }
                                    } finally {
                                        --inRestoreAtom;
                                    }
                                }
                            };
                            savedStoreSet(restoreAtom);
                        }
                    };
                    return Object.assign(derivedStore, devStore);
                };
                const createStore = () => {
                    const atomStateMap = /* @__PURE__ */ new WeakMap();
                    const getAtomState = (atom) => {
                        if ((false ? 0 : void 0) !== "production" && !atom) {
                            throw new Error("Atom is undefined or null");
                        }
                        let atomState = atomStateMap.get(atom);
                        if (!atomState) {
                            atomState = {
                                d: /* @__PURE__ */ new Map(),
                                p: /* @__PURE__ */ new Set(),
                                n: 0
                            };
                            atomStateMap.set(atom, atomState);
                        }
                        return atomState;
                    };
                    const store = buildStore(
                        getAtomState,
                        (atom, ...params) => atom.read(...params),
                        (atom, ...params) => atom.write(...params),
                        (atom, ...params) => {
                            var _a;
                            return (_a = atom.onMount) == null ? void 0 : _a.call(atom, ...params);
                        }
                    );
                    if ((false ? 0 : void 0) !== "production") {
                        return deriveDevStoreRev4(store);
                    }
                    return store;
                };
                let defaultStore;
                const getDefaultStore = () => {
                    if (!defaultStore) {
                        defaultStore = createStore();
                        if ((false ? 0 : void 0) !== "production") {
                            globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
                            if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
                                console.warn(
                                    "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
                                );
                            }
                        }
                    }
                    return defaultStore;
                };




                /***/
            })

    }
]);
! function() {
    try {
        var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : {},
            n = (new e.Error).stack;
        n && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[n] = "76dea4e7-1035-59c3-8da5-4801550bb5ee")
    } catch (e) {}
}();
//# sourceMappingURL=LottiePlayer.modern.js.map
//# debugId=76dea4e7-1035-59c3-8da5-4801550bb5ee